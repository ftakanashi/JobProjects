## 题目描述

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。

例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

示例 1：
```
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
```
示例 2：
```
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
```

提示：
- 0 <= pushed.length == popped.length <= 1000
- 0 <= pushed[i], popped[i] < 1000
- pushed 是 popped 的排列。

>注.本题同LC946.验证栈序列

### 解法 辅助栈模拟
一开始总想去找找两个数组符合/不符合条件的规律是什么。
但是想了一通之后没看出可以用代码表达的规律。

看了答案，原来是用栈模拟的…

设置两个指针i,j分别指向pushed和popped序列中的各个元素，从前向后扫描。

由于题目给出条件，所有数字都不相同，因此在pushed序列出现popped序列的第一个数字之前，所有数字都会按顺序进入辅助栈。

接着，如果此时栈顶和popped序列当前扫描的元素一样，说明这里有个pop操作，那么就pop一下即可。
这个pop也会进行多次直到栈顶和j指向的popped序列元素不同。

既然不同了，说明又要继续推动i扫描pushed序列直到popped[j]出现。

如此周而复始，上面的两步走：push和pop显然形成一个循环。

那么这个循环什么时候结束呢，显然当pushed中所有数字都已经入过栈，此时应当再给pop一次机会。
如果此时popped序列恰好也能pop完，此时栈空，i和j分别都走到头。
说明两个序列是一对合法的压入、弹出序列。

另一方面，如果popped中数没能用完，此时栈不为空，因此的出相反结论。

