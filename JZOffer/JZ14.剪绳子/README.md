## 题目描述

给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 `k[0],k[1]...k[m-1]` 。

请问 `k[0]*k[1]*...*k[m-1]` 可能的最大乘积是多少？

例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

示例 1：
>输入: 2
>
>输出: 1
>
>解释: 2 = 1 + 1, 1 × 1 = 1

示例 2:
>输入: 10
>
>输出: 36
>
>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36

提示：

- 2 <= n <= 58

### 审题
题目中提到的m并不是一个定值。从给出的例子中也可看到，输入只有n一个值。

也就是说只要你剪了，即剪的次数大于1，随便你剪几刀。

乘积最小当然是剪n-1刀，全部变成一小段长度为1的绳子，这样全部乘起来积是1。而题目问最大。

### 解法1 动态规划
典型的动态规划题目。定义`f(n)`是长度为n的绳子操作所能得到的最大乘积。

显然，`f(n) = f(i) * f(n - i)`，其中i是凑得最好的1到n-1中间的一个数字。

换言之，`f(n) = max( f(i) * f(n-i) )...0 < i < n`。这样只要依次遍历i就可以知道最大值了。
事实上，又由i和n-1是对称的，所以i只要遍历一半即可。

注意到这是一个递归式，如果按照朴素的递归想法，可能就直接自上而下地DFS探索就完事了。
当然由于大量重复的子问题计算，可以记忆中间结果。和之前做的LeetCode 140题有点像。

针对这种问题，这里用动态规划。
动态规划是自下而上地进行子问题计算保存并进一步解决更大一点规模的问题。

具体而言，一目了然的子问题答案是`f(1) = 1`。这里有个小坑，`f(2) = ?`。
如果按照上面的式子，`f(2)`似乎应该等于`f(1) * f(1)`，等于1。但是请注意，如果绳子本身
只长2，那没问题，如果2是作为"拼接部分"，即`f(i)`的形式出现的话，那么可以有一刀都不切的情况。
比如某种情况下，最后一刀剪出了一段2，显然直接乘以2，比把2剪成两段1来乘1乘1更大。

而这种要考虑片段本身长度的情况，仅限于`n < 4`的情况。因为在大于等于4时，再怎么着我切成2和n-2，其积
也大于n本身，因此n本身就无需考虑了。为了编码方便，不用考虑n本身长度这条分支，初始化
子问题答案的时候干脆一口气写到n=3的情况即可。

这么一来，最开始的几个小的子问题答案就有了：
```python
cache[0] = 0
cache[1] = 1
cache[2] = 2
cache[3] = 3
```

接下来，就是开始依次n++地递推。每次递推为了得到最大值，还需要对当前n的一般进行i的遍历。

最终，当`cache[n-1]`的值也求出来了，最后一轮，只需要遍历`for i in range(1, n//2)`,看哪个
i可以满足`max(cache[i] * cache[n-i])`即可。

### 解法2 贪心
总体来说，可以把握到的一个趋势是切得尽量细碎（但也不能太碎）越好。因为是乘法，
多乘以一个数就可以翻好几倍。

比如，9分成4，2，3比分成4，5更好。因为2*3是大于5的。当然全切成1就沙比了，所以
切成合适的长度要紧。

那么合适的长度是多少呢，2，3看似可行。4的话由于切成2 * 2等于其本身，所以已经可以看做是
需要切分的，不细碎的长度了。

而更大的，5，可以切分成2 * 3 比5大。6可以切分成3 * 3，比2 * 4或者6本身大。更大的就更不用说了。

虽然可以严格证明（但是我不会…），但是从规律中可以看出，一般只要能切成3，就尽量切出3来。

同时，如果是10这种，切完两个3之后，剩下4，此时3，1不如2，2，所以此时切2/2（或者不切也行，反正一样）

总的，算法描述如下。
一直切3切3，当剩余长度为4或者5时停止。4时可以切2/2，5时再切一个3。结束。

贪心，体现在不断地切3。

这种贪心，有坚实的数学证明的话，算法就确定了，因此可以用很少的时间空间来完成计算。