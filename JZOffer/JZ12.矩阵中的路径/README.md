## 题目描述
请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。

路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。

如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。

例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径。

```text
a  (b)   c   e
s  (f)  (c)  s
a   d   (e)  e
```

但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。

示例 1：
>输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
>
>输出：true

示例 2：
>输入：board = [["a","b"],["c","d"]], word = "abcd"
>
>输出：false

提示：

- 1 <= board.length <= 200
- 1 <= board[i].length <= 200

### 解法 DFS（回溯法）
书上写着解法名称叫回溯法，但是我还是更喜欢叫DFS。

这题和今天LeetCode的每日一题也很像（436.岛屿的周长）

简单来说，就是依次检查当前需要匹配的target字符，以及当前路径上矩阵中的字母。

如果两者匹配，那么就匹配下一个字符，而候选项则是当前位置的前后左右。

当所有字符都匹配完毕，则表明找到了一条路径，返回True即可。

注意两点，第一，因为不能重复使用字符，所以需要额外维护一个checked矩阵用来表示某个字符有没有被使用过。
同时需要注意，当某一条路走不通了，那么在返回False之前，也要把checked的状态给维护回去。

第二，由于不是确认某条给出路径正不正确而是确认某条路径存不存在。
所以并不是直接返回dfs的判断结果（True/False），而是要遍历所有可能。当有返回True时倒是可以直接返回True，
当返回是False时则需要继续检索。

另外别忘了边界处理等。

另外一个小感想，这题DFS函数要接收挺多东西做参数（包括地图本身以及checked矩阵等）

而Python的内部函数定义挺好用的。如果把dfs定义成Solution类的另一个方法，那参数要写好长一串。
但是写内部函数的话，board, checked, word这些东西都可以复用。