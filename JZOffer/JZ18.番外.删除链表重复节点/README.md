## 题目描述
**注：同LC原站82题**

给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。

示例 1:
>输入: 1->2->3->3->4->4->5
>
>输出: 1->2->5

示例 2:
>输入: 1->1->1->2->3
>
>输出: 2->3


### 解法1 三指针
首先想到用双指针i和j，用来标识重复区域的开始和结束，然后把这个区域删掉就行了。

不过对于链表而言，删除操作没那么简单。就如上面的两题说到的那样，如果重复区域的右边界就是原链表的最右边，
那么在不知道i的前序节点的情况下，无法顺利采用第二种节点删除法进行节点删除。

既然还需要知道i的前序节点，那么就再设置一个k指向它吧。

显然，最开始为了鲁棒head，所以有必要设置一个dummy放在head前面。

### 解法2 递归
链表有一个重要的性质就是，当你拿出其中任意一个节点，它将会是所有后续节点组成子链表的head。

那么就可以设计这样一个函数，他的功能类似于lstrip掉从头结点开始所有重复的节点。

然后返回去掉重复节点后新的head。

当然对于head开始并没有重复区域的，直接把递归调用head.next的结果接到head后面即可。比如`1 2 3 3 3 4`。
显然从2开始调用的话得到的是`2 4`，但是不能直接返回这个啊，就把这个给接到`1`后面就行了。

递归跳出条件，显然是`head.next is None`，此时直接返回head即可。(事实上写了代码之后发现，
如果开头重复区域直接持续到末尾，那`head is None`也要加入递归跳出条件)