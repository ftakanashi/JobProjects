## 题目描述
给定一个数组 `A[0,1,…,n-1]`

请构建一个数组 `B[0,1,…,n-1]`，其中 `B[i]` 的值是数组 A 中除了下标 i 以外的元素的积, 即 `B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]`
。不能使用除法。

示例:
```
输入: [1,2,3,4,5]
输出: [120,60,40,30,24]
```

提示：
- 所有元素乘积之和不会溢出 32 位整数
- a.length <= 100000

### 解法 维护前缀积
由于不能用除法，最朴素的一种思路是扫描数组，每扫过一个位置就把除本身以外的数乘起来收割结果。

但是这样的话显然会有很多重复计算。比如在扫描到所有`i>=2`的位置，`a[0] * a[1]`这个结果都被计算过了。
既然重复计算了，那么就像想能不能把这些结果缓存起来，
于是就想到了可以设置一个外部缓存，保存前缀积（前缀和经常可以听到，这里是乘积）。

而这些前缀积可以通过一次从左到右的扫描全部获得（连着乘过去即可）。

另外别忘了除了乘以`i`之前的数字，也要乘以之后的数字，因此还需要 有个"后缀积"，显然它要从右到左扫描一遍得来。

经过两次遍历之后，我们分别得到了一个前缀积和一个后缀积数组。

接下来构建结果数组时，碰到位置`i`，只需要将`prefix[i-1] * suffix[i+1]`作为结果即可！
当然，当`i == 0 or i == n-1`的时候要做边界处理。