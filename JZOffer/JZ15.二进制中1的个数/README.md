## 题目描述

请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。

例如，把 9 表示成二进制是 1001，有 2 位是 1。

因此，如果输入 9，则该函数输出 2。

示例 1：
>输入：00000000000000000000000000001011
>
>输出：3
>
>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

示例 2：
>输入：00000000000000000000000010000000
>
>输出：1
>
>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

示例 3：
>输入：11111111111111111111111111111101
>
>输出：31
>
>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。


### 解法1. API调用大法
以往我看到这种题目，肯定是写上这么一行代码…：
```python
return sum([int(i) for i in bin(n)[2:]])
```


### 解法2 位右移运算
面试中用上面这个作为一个备选答案未尝不可，但肯定不是标准答案。

既然题目都提到了二进制，很明显，要通过位运算来解决这个问题。

一个容易想到的思路就是，将数字不断位右移，并判断当前的末位数字是否是1。

判末位是否是1可以采取`n % 2`的办法，或者既然都用了位运算，可以采取`n & 1`的办法。再吹毛求疵一点，其实右移也可以写成`n // 2`。

这里需要注意一点，上面的求余也好，除法也好，运行机制上来说本身就肯定不如位运算快。

基于上述思路，可以写出第一版代码。
```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        res = 0
        while n > 0:
            res += n & 1
            n = (n >> 1)
        return res
```

上述代码虽然能跑过LC的所有case。但是还存在问题。
比如，如果输入是一个负数。位右移时左边补位补的都是1而不是0，这样循环永远没完，而且计数也会出现问题。

### 解法3 用"探针数"扫描原数
这个解法更加利用了位运算的性质。

"探针数"是我瞎取得名字，指那些二进制位上只有一个位置是1的数。

为什么叫它探针，是因为它和原数进行与运算后，得到的结果如果是它本身，则意味着原数相应位置
是1，而不是0。

这样操作不涉及补位，因此也就没有了正负数之间的差别，一视同仁全看做二进制数即可。

并且，扫描次数等于整数的位数，因此不存在死循环。

代码：

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        res = 0
        p = 1
        for _ in range(32):
            if n & p == p:
                res += 1
            p = p << 1
        return res
```

### 解法4 究极位运算综合做法
感觉这种解法没见过的话，要凭空想出来有点困难。。

考虑这样一种操作：
某个数n减去1之后，和原n做与运算，得到结果m。

n和m之间存在这样一种关系：
**在二进制表示中，m是把n最右边的1变成0的数。**

例子：
```text
n:   xxxxxx10000
n-1: xxxxxx01111
m:   xxxxxx00000
```
由于与运算，0&0=0, 1&1=1，所以前面的`xxxxxx`不会改变。

这样周而复始，每一次操作都可以把最右边的1变成0，直到m本身是0时结束循环。

这种做法不用操作32次，n有几个1操作几次即可。

位运算的奥秘尽在其中…

这种做法被称为Brian Kernighan 算法。
