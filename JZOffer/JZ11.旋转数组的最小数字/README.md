##题目描述

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。

例如，数组 `[3,4,5,1,2]` 为 `[1,2,3,4,5]` 的一个旋转，该数组的最小值为1。  

示例 1：
>输入：[3,4,5,1,2]
>
>输出：1

示例 2：
>输入：[2,2,2,0,1]
>
>输出：0


### 解法1 暴力
因为是个半排序的数组，所以一个很明显的思路，就是从头到尾扫描

当发现某个数字比前一个数字小说明扫描到了"断点"，输出就好了。

如果扫描完全程没有发现这样的数字，说明整个数组所有数字都相等或者长度仅为1。

因此直接输出最后一个数字即可。

显然时间是O(n)


### 解法2 二分查找

>题外话：LeetCode上提交了暴力和二分两份代码，但是暴力的效率更高…可能是数据的问题吧。

用二分查找解这个题，乍一看好像挺简单的，但是仔细一想还是比较难…

主要是他的二分查找的套路和传统二分查找不太一样。

这种套路可能需要记录一下。。

首先，分析这种所谓的数组旋转具有什么性质。这个旋转后的数组，实际上是被分成两部分。
前半部分，为了方便成为A，是一个不递减的数组；后半部分，称为B，也是一个不递减的数组。

并且存在，B中的任意一个元素都不大于A中的任意一个元素。因此把A直接append到B后面的话就可以形成一个
完整的不递增数组。

现在要找的是，最小数字。最理想的情况，当然是找到B的第一个数字,或者说找到A和B之间的断点所在。

这个解法就是通过二分查找来检索这个断点。

当然，这个断点的值是多少，不可能提前得知，这也就不是传统的二分查找的套路了（没有target值）

注意到，没有target值的话，能够利用的也就是二分查找的边界left和right对应的值了。

答案是用right（用left的话一些特殊case不能直接处理，需要通过额外的特殊情况处理来解决。可参考书上的解法）

一般而言，通过`mid = (left + right) // 2`可以得到中点位置。然后比较中点的值和right的值。

- 显然，如果`nums[mid] > nums[right]`，说明此时的mid仍然属于A部分，为了找到B的第一个位置，
可以直接将`left = mid + 1`。

- 另一方面，如果`nums[mid] < nums[right]`，说明此时mid已经属于B部分了。而要找的B的第一个位置，可能在
mid的左边或者就是mid本身。所以`right = mid`。

如此left和right不断逼近彼此，当某一天，两者相邻，可能的情况是A[-1]和B[0]或者B[0]和B[1]的组合。
不论哪种情况，下一次迭代时left和right将会重合在B[0]上。因此循环退出条件也有了，即`left < right`。

接下来是这解法最麻烦的地方，如果mid值`nums[mid]`和right值`nums[right]`相等怎么办。
实际上，由于题目对数组本身并没有做任何限制条件，甚至可能存在所有数字都一样的数组。
更加坏心眼一点的，比如
```python
[1, 0, 1, 1, 1]
[1, 1, 1, 0, 1]
```
这两个数组。可以看到不论哪个都符合条件mid值和right值相等。但是此时不论是left右移还是right左移都不好使。都可能会错过最小值0的所在。

因此mid和right值相等的时候不能那么粗暴的处理。

那么能怎么办呢，总不能不缩小范围吧。其实仔细一想，两者相等可能是两种情况。

1. mid和right同属于B部分。此时mid和right之间所有值都一样。（如上面那个）
2. mid属于A而right属于B。此时mid之前的A里的所有东西都应该等于mid值。（如下面那个）

不论哪一种情况，right其实都可以被舍弃。
第一种情况就不用说了，整个尾巴都可以被舍去的。第二种情况虽然right可能是B[0]，但是反正它和mid值相同，把它去掉后再剩下的数字里面继续探索也
还是能找到同样答案的数字。因此不影响

至此得到结论，当两者相同时，可以`right -= 1`

>再说一句，之前不拿left作为比较基准，就是因为上面这种相等的情况没办法很好处理。
>详情参考书上这题的解。