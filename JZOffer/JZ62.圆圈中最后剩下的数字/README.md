## 题目描述
0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

示例 1：
```
输入: n = 5, m = 3
输出: 3
```
示例 2：
```
输入: n = 10, m = 17
输出: 2
```

限制：
- 1 <= n <= 10^5
- 1 <= m <= 10^6

### 解法1 模拟
不解释。

注意Python中除`del nums[i]`的方法外还可以`nums.pop(i)`来删除指定下标的元素。

### 解法2 自底向上递推（也算某种DP吧）
其实这个问题是一个数学上被称为约瑟夫环的问题。其中含有一些数学规律，可以按照下面的方式来推导。

针对一个长度为n的序列，第一步需要删除的元素，下标是`i = (m - 1) % n`。
之后从下标`i + 1`开始进行长度为n-1的序列的删除工作。

此时，假设我们知道长度为n-1的序列，在删完一通之后最后剩下的元素在长度n-1序列的下标是x的话（注意这里是长度n-1序列的下标，即这算做一个独立问题了）

那么反推回长度为n序列的情况，可以知道长度为n的序列的场合中，最终剩下的元素的下标应该是`(i + 1 + x) % n`。
注意取余右边是n不是n-1。因为现在是针对长度n的序列操作。

更正式的，如果将`f(n,m)`表示为题目要求的最终剩下的元素的下标的话，
那么有
```text
f(n, m) = [(m - 1) % n + 1 + f(n-1, m)] % n
```

有了这个式子就好办了，可以递归的求解，递归结束条件是`f(n, m)`中的`n == 1`时返回0。

另一方面也可以自底向上地递推，这样更节省空间。
这种反过来递推的做法也很有DP的味道。