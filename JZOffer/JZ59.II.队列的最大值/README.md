## 题目描述
请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1

示例 1：
```
输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
```
示例 2：
```
输入: 
["MaxQueue","pop_front","max_value"]
[[],[],[]]
输出: [null,-1,-1]
```

限制：
- 1 <= push_back,pop_front,max_value的总操作数 <= 10000
- 1 <= value <= 10^5

>题目给出的条件"均摊"是O(1)，很多评论也表示描述并不清晰。看了几个网友的证明，感觉也都不对。这里只能先放一放了。

### 解法1 堆+哈希表
显然结构体中应该有一个主队列。
除此之外为了要每时每刻都能尽可能快地获取到当前队列中的最大值，显然需要一些附加结构。

这里第一种解法，是我自己想出来的用堆+哈希表。

时刻都能获取到数组中的最大值，很明显就想到了堆。
但是这里的堆显然面临一个问题，即如何延迟删除。

比如push了`3 5 8`这个序列，显然此时堆顶是`8`。然后再将三个数pop出来，pop前两个的时候，因为堆顶8还在队列中，所以堆不动。
但是pop出8后主队列明显空了，但是堆里还剩下3和5。

事实上，一个简单的解决办法就是给这两个3和5打个标记，这样下一次堆在pop的时候如果堆顶是他们，那么就直接pop掉。

上一题`JZ59.I.滑动窗口的最大值`中用的办法是把下标信息`i`也随着值一起入堆，这样通过检查下标是否在当前左边界左边来判断堆里的某个数是否已经失效。

这题，由于队列的长度并不固定，所以不能像上题那么方便。
给出的解决方案是设置一个counter哈希表。

还是以上面的`3 5 8`为例。前两个pop掉之后，虽然堆不变，在counter里将两者都减去1。
接下来pop掉8之后，发现剩下的堆顶5和3，在counter中都不存在了，因此直接pop掉。

不过这种方法耗费内存较多不说，按照给出的代码，其实只有pop操作是严格意义上的O(1)。
push时由于堆push操作，是O(logk)的。pop同理。

### 解法2 辅助队列
参考`LC155.最小栈`，彼时通过了一个辅助栈来时刻O(1)获取到栈中的最小值。
这道题也可用类似的思路。

因为核心数据结构是队列，所以辅助结构也是队列。只是队列中保存什么。
给出算法如下：
我们时刻保持辅助队列的不递增性质。
进行`push(value)`的时候，如果辅助队列的末尾小于`value`，则从其末尾开始pop，直到为空或者末尾大于等于`value`。

进行`pop`的时候，如果主队列此时出队的元素等于辅助队列队头，即最大值。则两者一起出队。
显然辅助队列的队头变化了，说明最大值也变化了。

获取最大值的时候只要获取辅助队列的队头即可。

以上操作，显然除了push其他都是O(1)的。而push操作最坏情况下可能要求pop整个辅助队列，所以感觉也不是很好…