## 题目描述
给定循环单调非递减列表中的一个点，写一个函数向这个列表中插入一个新元素 insertVal ，使这个列表仍然是循环升序的。

给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。

如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。

如果列表为空（给定的节点是 null），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。

示例 1：
![](https://assets.leetcode.com/uploads/2019/01/19/example_1_before_65p.jpg)

```
输入：head = [3,4,1], insertVal = 2
输出：[3,4,1,2]
解释：在上图中，有一个包含三个元素的循环有序列表，你获得值为 3 的节点的指针，我们需要向表中插入元素 2 。新插入的节点应该在 1 和 3 之间，插入之后，整个列表如上图所示，最后返回节点 3 。
```
![](https://assets.leetcode.com/uploads/2019/01/19/example_1_after_65p.jpg)

示例 2：
```
输入：head = [], insertVal = 1
输出：[1]
解释：列表为空（给定的节点是 null），创建一个循环有序列表并返回这个节点。
```
示例 3：
```
输入：head = [1], insertVal = 0
输出：[1,0]
```

提示：
```
0 <= Number of Nodes <= 5 * 10^4
-10^6 <= Node.val <= 10^6
-10^6 <= insertVal <= 10^6
```

### 解法 模拟
链表的题目就是这样，思路会有很多，而且只要盘清思路，照着思路写代码，总能做出来。
难的是从众多思路中找到一个最省事的。

这题就是如此。
一开始我的思路是先扫描一遍找到最大值和最小值节点的分界，然后以此为起点分类讨论，相当于扫描两遍。
而答案的思路更加优雅，且只要扫描一遍。

具体来说，我们先排除示例2和示例3的两种特殊情况，即`head is None`以及`head.next is None`。
这两种情况很好排除，就不多说了。
而对于最一般的情况，我们设置一前一后两个游标进行遍历，如`cur`和`nxt`。

遍历的时候，需要进行分类讨论。
具体的，首先`cur.val`和`nxt.val`之间可能会有一些关系需要讨论。
当`cur.val <= nxt.val`，这是绝大多数情况，此时若恰好有`cur.val <= insertVal <= nxt.val`的话，
那么直接在两者之间插入新节点即可。

当`cur.val > nxt.val`，此时说明恰好两者是最大值和最小值节点。此时若有`insertVal`比最大值还大或者比最小值还小，
那么很显然，依然可以再两者之间插入新节点。
由于题目说了head并非总是最小值节点，所以此时仍然有可能`insertVal`是一个中间值而尚未遍历到他应该插入的位置，所以此时应当继续遍历，
直到碰到第一种情况。

以上是对大多数情况的讨论，然而还有一些极端情况不在上述任何一种分支内。
比如所有节点都是同值的情况。此时倒也方便，随便找两个节点之间插入即可。

至此所有情况都讨论到了。
总的来看，不论是哪种情况，最终的插入操作总是在`cur`和`nxt`间插入新节点，因此可以将这个操作统一化写在循环外，
而循环用break控制跳出。

以上。