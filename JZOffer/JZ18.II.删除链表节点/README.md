## 题目描述
给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

**注意：此题对比书本原题有改动。这题是LeetCode上的题。**

示例 1:
>输入: head = [4,5,1,9], val = 5
>
>输出: [4,1,9]
>
>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.

示例 2:
>输入: head = [4,5,1,9], val = 1
>
>输出: [4,5,9]
>
>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
 

说明：
- 题目保证链表中节点的值互不相同
- 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点

### 解法 指针
书本原题给出的输入是head和待删除节点node自身。

而这里，给出的是head和待删除节点的val。

这么一来，遍历寻找定位值是val的节点是哪个，就不可避免了。时间O(1)是不用想了。

首先想到的，当然是设置一个指针i，然后`while i.val != val: i = i.next`去循环得到待删除的节点。

不过这么写有个很麻烦的问题，当val恰好是链表最后一个节点的值的时候，此时i已经在最后一个node上，我又不能回过头到倒数第二个node去改他的next，
所以第一种删除法无效。（两种删除法见 I.删除链表节点）

而第二种方法呢，第二种方法有个默认前提是，待删除node的.next一定是一个node而不是None。
如果是None，那么我是无法把当前节点变成None的，因为接口没有类似于destroy之类的方法，而只能改变val。

因此思路应该是采取第一种删除办法，并且为了避免要删除最后一个节点的麻烦情况，循环过程中也要
把握到待删除节点前一个节点。

这种想法最直白的就是差一个身位的双指针了。
当然，链表中相邻的两个节点都有next作为连接，因此也可以单纯的使用单指针，只不过判断条件都往后改一个身位。
比如上面的`while i is not None and i.val != val`改成
`while i.next is not None and i.next.val != val`。

最后别忘了拿边界case看看代码是否鲁棒。
边界情况无非就是，空链表，单节点链表，要删除的恰好是head(因为循环从i.next开始，所以无法处理这种情况)，
要删除的值不存在与链表中。