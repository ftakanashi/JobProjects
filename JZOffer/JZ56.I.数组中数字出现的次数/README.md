## 题目描述

一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

示例 1：
```
输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
```
示例 2：
```
输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]
```

限制：
- 2 <= nums.length <= 10000

### 解法 分组异或
这道题的解法真是妙蛙种子吃着妙脆角走进了米奇妙妙屋，妙到家了。

首先回顾经典题型，如果只有一个数字出现一次，其余都出现两次，那么就是一个简单的异或过去的运算。

这道题，如果采取同样做法，那么只能得到要求的答案的a,b两个数字的异或运算结果`a ^ b`。

显然，只知道这个结果是无法特定两个数字分别是什么的。
接下来就是骚操作了。

以示例1为例，得到的异或结果是`1 ^ 6 = 0b111`。这个`111`中，任意一个1，其实都含有这样一个隐藏的意思：
该位置，结果的a和b是不同的。（因为a和b是不同的，所以其异或结果必然是>0，至少含有一个1）。
同时，其余所有数在这个位置也有可能是0或者1，但是因为他们每个数都有配对的数存在且配对的数这个位置的01情况必然和本身相同，因此可以以这个位置的
01情况，将原数组分成两个子数组。

这两个子数组中，要求的答案a和b肯定被分开了。同时每个子数组中除了a和b，剩余数都是配对的。
那么只要再异或一波这两个子数组，就可以分别得到a和b了！

最初的异或结果中1的位置是任选的，下面以最低位出现1的情况为例说明算法。

首先异或整个数组得到`t = a ^ b`。

然后将`t = t >> 1`获得其最低位为1的那个位置。

然后要"分组"，但是真的分成两个子数组的话空间复杂度就上去了，所以这里可以仅仅动态维护两个子数组的异或结果。
即初始化`t_a, t_b = 0, 0`。

然后第二遍扫描数组，针对数字`n`，若它在指定位置是0，就`t_a = t_a ^ n`，否则就`t_b = t_b ^ n`。
最终得到的`t_a, t_b`就是所求答案。