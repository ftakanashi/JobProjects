## 题目描述
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。

输入一个数组，求出这个数组中的逆序对的总数。

示例 1:
>输入: [7,5,6,4]
>
>输出: 5
 

限制：
- 0 <= 数组长度 <= 50000

###解法 归并排序的副产物
求逆序数对两种套路，一种是哈希化的树状数组。因为不懂树状数组，暂且不看。
另一种就是归并排序的副产物了。

其实归并排序天然就可以用来求逆序对。

直接设想归并排序的最后一步，即左右两个等长为n/2的子数组，两者分别已经排好序了。
归并排序的下一步就是把两者合并成一个大数组，就完成了对原数组的排序。

注意到归并排序中一个不太引人注目的性质，任意一层的左右子数组，左子数组中的任意数字，
在原数组中，位于任意一个右子数组数字的左边。（有点拗口，仔细看看）也就是说，左右子数组的边界，
在原数组中也是存在的，边界左边的数不管在归并的递归中怎么折腾，都不会越过这个边界；右边也是。

这么一来，至少可以在这个情况下，统计一部分逆序对了。就是那些基准数在原数组后半而比他大的数在原数组左半的
逆序对。

具体来说，从左到右扫描右子数组。针对一个特定的右子数组的值`right[j]`，扫描左子数组。当某个左子数组中的位置i的值`left[i] > right[j]`，
说明从`i`开始到`left[-1]`为止所有的数字都是比`right[j]`大的（因为左子数组排好序了）。
那么逆序数对数目直接可以加上`len(left) - i`。进一步的，`j += 1`之后，没必要看0开始到当前i位置那部分数，因为他们都小于之前的`right[j]`，
肯定比现在的更小了。

如此扫描完一遍右子数组之后，这里说的"一部分的逆序对"就完成了统计。

至于左右子数组内部的逆序对，显然，可以用递归的办法解决。事实上，在归并排序自身的递归中就可以嵌入这部分代码。

注意以上操作的前提都是左右子数组是排好序的，也就是基本框架得是归并排序。所以归并排序的操作也得做。
因此才说，逆序对统计是归并排序的副产物。