## 题目描述

输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

示例 1:
```
输入: [10,2]
输出: "102"
```
示例 2:
```
输入: [3,30,34,5,9]
输出: "3033459"
```

提示:
- 0 < nums.length <= 100

说明:
- 输出结果可能非常大，所以你需要返回一个字符串而不是整数
- 拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0

### 解法 自定义规则排序
这道题非常有意思，而且严格来说还是很难的。

题目也说了，要求我们重排数组。但是显然，两个示例都表明，这个重排不是单纯地按照数字大小排序即可。

于是这里就有个奇思妙想，我们自定义排序规则。
在我们的定义中，a < b并不是绝对值的大小关系，而是两者排列起来后形成新的数字 `ab < ba`。
由于单纯排列后转int可能会有大数问题，所以采用字符串的比较形式，即`str(a)+str(b) < str(b)+str(a)`。

这样，在排序完成后，直觉上来说就是最小的。

严格的证明可以参考书本。
因为严格的证明还是比较麻烦的，所以说这题还是挺难的。
但是如果知道这种思路，实现起来并不复杂。
给出的代码是基于快排的实现。