## 题目描述
>本题同LC371.两整数之和


### 基本思想
用位运算，先求异或得到初步结果，再求 和运算 结果后左移一位得到需要进位的位置。

将两个结果递归地再加起来，直到某一次加法不需要任何进位即和运算的结果是0。

如果用java表述，可能是这样的：
```javascript
public int add(int a, int b){
    if(b == 0) return a;
    return add(a ^ b, (a & b) << 1);
}
```

这个代码也可以过。

### Python的修正
Python麻烦就麻烦在，默认的int不是32位，而是动态地，通常都是更高位数。

这就导致了一个问题。如果输入两个数字都是正数还好说，当有一个负数的时候时就会出现问题。

比如-1和2。在Python中，-1和2的二进制（假设其是64位）可能是这样：
```text
111...11 111...11
000...00 000...10
```
虽然我们不希望左边的高位参与运算，但是没有办法只能先带着他们算。
两者`^`和`& <<1`分别得到
```text
111...11 111...01
000...00 000..100
```
发现每进行一次递归，异或结果中间多个0且和+左移结果的1往左移一位。
在进行30次递归之后会得到：
```text
111...11 100...001
000...00 100...000
```
在32位限制的情况下，我们只关注最低的32位的话，再进行一次递归，和+左移结果回归成0，而异或结果恰好变成1。
直接返回便可得到正确答案。
但是现在由于高位的数字存在，两者都不能变正常。

事实上下面的那个数字，由于可以无限左移也不会变成0（Python的动态位数理论上可以保存无限大的数字），所以递归永远不会结束。

那么怎么办呢。首先，下面的和+左移的结果一旦大于2**31就手动将其重置为0。
其次，上面的异或结果只能取最低32位作为输出因此需要进行`% 2**32`操作。

经过以上修正，输入为-1和2（所有带负数但是最终结果为正的输入）可以正确处理了。
但是还是没完，如果输入-2和1，结果并非-1而是2**32-1。

这又是为什么。
还是和上面一样，我们一步一步看按照现有代码输入-2和1会经历什么过程。两者二进制是
```text
111...11 111...10
000...00 000...01
```
事实上，第一轮递归时，-2和1的异或结果是`111...11 111...11`，而和+左移结果已经是`0`了。
所以此时直接输出了`111...11 111...11`这个数。

但是在python中，负数的符号并非由二进制的头一位表示，因此需要手动将其解释为-1。

如何解释呢，首先当然还是取最低32位即`% 2**32`。
接着将最低32位根据32位带符号整数的规则进行转换即可。即如果最低32位首位是0，那么按正数解释，否则按负数解释。

按负数解释的具体转换方式有很多种，比如按规则可以"减一取反"。但是要注意，还是Python机制的关系，
虽然我们进行了取最低32位操作，但是一旦将这个数投入运算，
Python又会把他解释成`000...00 111..11`。因此如果减一取反，得到的是`111...11 000...10`。高位的1还是没去掉，所以不能这么搞。

其实简单粗暴的减去2**32就可以了。

综合以上三点修正，就可以得到正确的代码了。（虽然函数体中用了不少加减号…