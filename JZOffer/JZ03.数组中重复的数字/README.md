## 题目描述
在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

### 解法1
数组里找数字 -> hashtable

整一个字典，维护 {n: count} 信息。
因为只要输出一个数字就行，所以count只要大于1了，就可以中断扫描，直接输出。

显然这是一个时间空间都O(n)的解法。

### 解法2
时间上来说，毕竟要确认每一个数字的值，所以O(n)应该是不可避免的。
但是空间上的O(n)能不能优化？

数组在空间上优化O(n)无非就是进行inplace的重排。
注意到条件"所有数字都在0到n-1的范围内"，即若所有数字都没有重复，那么这就是一个range(n)数组。
即满足numbers[i] == i。

那么自然，一个O(1)的思路就是，扫描数组的过程中尽量保证numbers[i] == i，
这种保证可以通过互换元素位置进行。当某次想要互换时发生冲突，即当前数字是i时位置i上也已经是i，
那么i就是所求的一个答案了。

具体算法可看书 面试题3