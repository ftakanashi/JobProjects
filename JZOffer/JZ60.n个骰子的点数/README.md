## 题目描述

把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

示例 1:
```
输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
```
示例 2:
```
输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
```

限制：
- 1 <= n <= 11

### 解法1 记忆化DFS
骰子和点数的概率公式，无非就是`和为n的总频数/6^n`。
而对投掷n颗骰子而言，其和可能的取值是`[n, 6*n]`。

针对一个和其实可以通过DFS求得用n个`[1,6]`内的数字加起来恰好是其的排列种类数。

那么很显然，外层函数就是一个`for n in range(n, 6*n+1)`，每个for循环都调用一次
dfs函数求得总频数，除以6^n后，收割即可。

很容易想出dfs函数如下：
```python
def dfs(s: int, rest: int, target: int) -> int
```
其中，s是探索过程中已经探索过的骰子的点数和，rest是还可以扔几颗骰子，target是上面说的n值。

dfs函数的开头可以剪掉如下枝：
```python
if target - s > rest * 6 or (s >= target and rest > 0): return 0
```
这个式子意思是说，如果前几个骰子点数很小，比如全是1，导致剩下的骰子即便全是6也无法达到target；
或者前几个骰子点数很大，其和已经超过了target但是仍然有骰子没有扔；这两种情况全部可以直接返回0。

这个dfs函数意外地一直到`n=10`左右还跑的通。但是再往后就不行，超时了。

因此需要记忆化。比如`n=10`的时候如果某一轮dfs是`s=10, rest=5`，其实五个骰子组成和是10的pattern有很多。这里全部都要重新算。

记忆化也简单粗暴，不用考虑太多，直接参数的元组和count的对应即可。

### 解法2 状态压缩DP
其实很多时候，DFS和DP都有着千丝万缕的联系。
比如这道题，DFS从底向上探索的过程中，其实就是记录了一些中间状态之后的深度优先搜索。

而如果不深度，而是一个一个骰子算的话，某种意义上也是广度优先，就是DP了。

这里我们定义DP二维数组`dp[n][k]`。其中`n`是表示扔出n个骰子之后，`k`代表总和达到`k`的可能总数。
显然，对于`dp[n][k]`而言有
`dp[n][k] = sum(dp[n-1][k-6:k])`。注意后部游标不包括k本身（因为不能让第n个骰子扔出0）。

按照此规则写DP过程即可。
注意一些细节，比如初始化的时候，应该是`for j in range(1,7): dp[1][j] = 1`。

另外状态转移的时候，注意如果`k-x`小于等于0，那也是无效的。
所以不能算进去。

最后，注意到最终关心的只是`dp[n]`这一行，所以看能不能状态压缩把dp二维数组给压缩成一维数组。
按照一般思路，状态压缩之后也是从左向右扫描。
但这道题里这个方向的扫描显然有问题，因为任意一个位置的值的更新取决于其前6个值，而从左到右扫描会导致那些值被更新。

所以状态压缩后，这里要从右到左地扫描才能正确更新DP值们。