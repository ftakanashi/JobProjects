# 线段树

很早就听说了线段树的威名，直到今天才有兴致和勇气仔细看了一下。整体倒也不是特别复杂。

## 线段树的作用

线段树本质上是一个二叉树，只不过这个二叉树所维护的核心数据并不是其本身，而是另一个独立的数组`nums`。下面我们将其称为线段树的“原数组”。

对于任意一个数组`nums`，我们可以从中取出很多子数组或者叫切片，这些每一个切片都可能有一些可以用一个数字表示的性质，比如切片的最大值、最小值、和等等。

线段树要解决的问题，就是如何存储这些性质并且快速地获得到这些性质。下面就以区间和作为例子，来说明。

最简单的一个例子，求`nums`中任意一个子数组的区间和，我们第一时间可以想到用前缀和来做。
但是这只对静态的数组可用，如果在流程中我们需要实时动态的修改数组中的某些值，那么前缀和显然没法做到高效率地实时更新，此时就要用到线段树了。

### 和其他数据结构的区分

在三叶的这篇[解答](https://leetcode-cn.com/problems/range-sum-query-mutable/solution/guan-yu-ge-lei-qu-jian-he-wen-ti-ru-he-x-41hv/)中，提到了泛泛的数组求区间和问题的一些具体问题题设和解决方法之间的对应关系：

>针对不同的题目，我们有不同的方案可以选择（假设我们有一个数组）：
>
>数组不变，求区间和：「前缀和」、「树状数组」、「线段树」
>多次修改某个数（单点），求区间和：「树状数组」、「线段树」
>多次修改某个区间，输出最终结果：「差分」
>多次修改某个区间，求区间和：「线段树」、「树状数组」（看修改区间范围大小）
>多次将某个区间变成同一个数，求区间和：「线段树」、「树状数组」（看修改区间范围大小）

可以看到，线段树是包含最广最万能的。但是也应该意识到，线段树的实现相比于其他的如树状数组或者前缀和复杂许多，占用的空间也更大，因此需要判断这里的tradeoff。

## 线段树的结构

既然是二叉树，必然就有树的节点。在线段树中，每个树的节点都对应了一段原数组中的区间。
自然，每个节点的值就是对应区间的属性值（区间和）。

更具体的说，设原数组长度为`n`的话，那么根节点对应的就是`[0, n-1]`的区间和。
而根节点的左子节点和右子节点分别对应了`[0, m]`和`[m+1, n-1]`。

更一般的，对于节点，若其对应区间是`[a, b]`，那么就有左子节点对应`[a, m]`和右子节点对应`[m+1, b]`。其中`m = (a + b) // 2`。

## 线段树的操作

基于上面描述的这么一种结构，线段树可以做哪些操作呢？

### build

首先，在给出原数组之后，线段树可以基于原数组进行build操作，即构建线段树。

具体来说，这个应该是一个自底向上的过程。
从根节点出发，进行递归遍历，只要遍历到的节点对应的区间还不是单个值即`a == b`，那么就继续将其二分向下。
相对的，当遍历到叶子节点时，必然有`a == b`，此时只要将其值设置为`nums[a]`然后返回即可。
对于上层节点，其值等于左右子节点递归返回的值的和。（因为现在是以区间和为例，所以就是求和。根据具体要求的东西不同，可以灵活改为求最大值，最小值，平均值等等）

### change

其次，还可以有change操作，即在构建线段树完成后，给出某个指定的下标以及新值，将树中相关的节点做改动。

这同样是一个自底向上的递归过程。
具体来说，从根节点出发进行遍历，同时判断指定下标`index`和当前区间的中点的关系。
若`index <= m`则说明要修改的值处于当前节点的左子树中，向左子树继续遍历，否则向右子树。
当扫描到要修改的值所在的叶子节点，直接将其修改后结束本层递归返回上层。
在上一层，我们需要将节点值修改为下层子节点值更新后的情况。如此层层向上不断更新，相当于将相关叶子节点到根节点这条路径上的所有节点的值都更新一遍。

### range

最后还有一个range操作。即获取某个区间`[left, right]`的属性值（区间和）。

需要注意的是，`[left, right]`并不一定恰好对应着某个节点，因此我们从根节点出发进行遍历。
每遍历到一个节点时，首先判断其中点`m`是否满足`right <= m`或者`left > m`。

上述两个条件分别代表着，要求的区间`[left, right]`整个都处于当前节点对应区间的左半边或者右半边。
此时我们可以缩小遍历范围，直接进入左子树或者右子树。

而若都不满足，则说明要求的区间`[left ,right]`横跨了当前节点的中点。
此时我们应该进一步扫描左子树但是要求区间变成了`[left, m]`以及进一步扫描右子树但是要求区间变成了`[m+1, right]`。

## 线段树的实现

### 基于数组底层的实现

虽说他是一个树，但是和堆类似，可以用数组的存储结构来实现线段树。
在数组底层的实现中，需要注意的是左子树和右子树就不是`.left`和`.right`来访问了，而是有了当前节点的下标`i`后，访问下标为`i * 2 + 1`和`i * 2 + 2`。

下面是一个实现方案：

```python
class SegmentTreeInArray:
    def __init__(self, nums):
        self.nums = nums
        self.n = len(nums)
        self.seg = [0 for _ in range(self.n * 4)]    # 为有足够空间容纳每个节点，4倍是一个必要的量
        self._build(0, 0, self.n - 1)    # 递归入口：根节点填入对应整个原数组的值

    def _build(self, node, s, e):
        '''
        输入线段树某个节点以及其对应原数组中的哪个区间([s,e])，在线段树中将该节点的值求出并填入
        '''
        if s == e:
            self.seg[node] = self.nums[s]
            return self.seg[node]
        m = (s + e) // 2
        self.seg[node] = self._build(node * 2 + 1, s, m) + self._build(node * 2 + 2, m + 1, e)
        return self.seg[node]
    
```

到这里为止，线段树的构造就完成了。接下来是change操作。为了将对外接口留得尽量简单，我将递归过程用内部dfs函数实现了。

```python
    def change(self, index, val):
        '''
        将原数组的某个指定下标index的值修改为新值val
        '''
        def dfs(node, s, e):    # 这个dfs函数的作用是探索节点node对应的区间[s, e]，并且将处于其中的index节点找出，修改其值为val，然后将相关的节点值都更新
            if s == e == index:
                self.seg[node] = val
                return self.seg[node]
            m = (s + e) // 2
            if index <= m:
                dfs(node * 2 + 1, s, m)
            else:
                dfs(node * 2 + 2, m+1, e)
            self.seg[node] = self.seg[node * 2 + 1] + self.seg[node * 2 + 2]    # 因为目标是求区间和，所以用加和方式
            return self.seg[node]

        dfs(0, 0, self.n - 1)
```

最后是range操作。同样，递归过程还是以内部dfs函数的方式实现。

```python
    def getRange(self, left, right):
        '''
        获取原数组某个指定范围内的值
        '''
        def dfs(node, s, e):
            if s == e:
                return self.seg[node]
            m = (s + e) // 2
            if right <= m:    # 探索区间整体在左子树
                return dfs(node * 2 + 1, s, m)
            elif left > m:    # 探索区间整体在右子树
                return dfs(node * 2 + 2, m+1, e)
            else:    # 探索区间横跨左右子树
                return dfs(node * 2 + 1, s, m) + dfs(node * 2 + 2, m+1, e)    # 因为目标是求区间和，所以用加和方式

        return dfs(0, 0, self.n - 1)
```

### 基于树节点类的实现

未完待续…

## 线段树应用

`LC.307`是一道典型的用线段树做的题目。

不过很奇怪的是上面我自己写的数组底层的实现居然超时…。官方解答中原理是一样的，但是不将递归过程单独整合成一个dfs函数，而是结合在整个change和getRange方法中，这样就能AC，不知道为什么…