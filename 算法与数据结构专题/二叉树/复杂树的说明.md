# 复杂树

提起复杂树，有一堆名词会蹦出来，比如平衡树，红黑树，B树B+树什么的。今天就按从简单到难的顺序挨个来捋一捋这些树们。

## 二叉树

最基本概念，不解释

## 二叉搜索树（BST)

二叉树的每个节点都有值，而这些值之间有大小关系。现在将树结构进行调整，使得对任意一个节点而言都有，其左子树中所有节点的值都小于其本身的值；其右子树的所有节点的值都大于其本身的值。

在这种情况下，这个树是一个二叉搜索树。因为给定一个target值，从根节点开始根据target和当前节点值的大小关系，很快就可以确定target值是否存在于树中。总体复杂度显然是O(logn)的。

二叉搜索树有一个毛病，就是其结构很大程度上跟插入值的顺序有关。如果插入的是一个完全有序的序列，那么二叉搜索树会退化成一个一维链表。

## 二叉平衡树（AVL）

二叉平衡树的定义是，对于树中任意一个节点，其左子树的深度和右子树的深度的差不超过1。二叉平衡树和二叉搜索树是两个平行的概念。但是又可以联系起来。

当一个二叉搜索树在构建的过程中时刻注意保持平衡性（通过旋转操作来进行），那么就可保证，这个树在搜索上总是可以O(logn)。

换句话说，这样的一个二叉平衡搜索树，通过对插入时牺牲一定性能进行旋转等操作后，可以保证检索的效率。

## 红黑树

红黑树的概念源于AVL。上文中说到，AVL的定义是左右子树深度差不超过1，这可以被视为一个严格的平衡标准。因此只要平衡一旦失衡，就需要旋转操作来保持平衡。

这样，可能会有过多的旋转操作。而红黑树正是对这个方面的一个弱化。红黑树定义，左右子树的深度差不超过两倍即可。所以红黑树取得的是一个近似平衡，但不是严格意义的平衡。

## B树

以上所有基于二叉树的复杂树，都存在一个问题。因为是二叉的，所以随着数据的增加，树还是会以比较大的速度增高。而树一旦过高，搜索起来仍然效率不高。在一些场景，比如用作数据库的索引等时候，会影响应用性能。

解决方案很简单，把二叉变成N叉即可。但是变成N叉后需要考虑如何还能保持二叉搜索时那种顺序性。于是，将N叉树中N个子树的指针以一定顺序维护在当前节点中，并且把自身的值也维护在这个序列中。保证在这个序列中，从左到右每个实体（指针or本身的节点值）所能指向的值依次递增。

需要注意，以上描述仍然在平衡搜索树这个大范畴内。所以B树仍然是一个平衡搜索树。

图示：

![image-20210628112704559](/Users/wyzypa/Pictures/TyporaImages/复杂树的说明.asset/image-20210628112704559.png)

## B+树

B树中，任意一个磁盘块都是有大小限制的，比如16K。而上图中，指针和键值几乎不占存储空间，相比之下data会占用大量存储，每个data块占1K。这么一来，按照上面B树的架构能够存储的最多数据容量就可以知道了：

第一层级磁盘块最多存放个16个data块，因此可以确定16个数据范围，对应着16个指向下一层节点的指针。同理，第二层节点也可以确定16个范围，因此指向16个第三层的磁盘块。

总体的，在叶子节点上总共有`16*16*16=4096`个data块，即4096K数据。这里还可以加上第一二层叶子节点中的数据块，不过不是一个量级的了。总之，这样一个B树最大容量，在4096K这个量级。这显然，不够大。

那么如何尽可能地利用B树，让其存放尽量多的数据呢？显然，将每个第一层、第二层磁盘块中存放的data都去掉，把腾出来的空间，全部存放指针。此时指针不能忽略其占用空间了，通常一个指针占用10个字节。那么显然，第一二层磁盘块，一个块内可以存放1600个指针，如图：

![image-20210628114018713](/Users/wyzypa/Pictures/TyporaImages/复杂树的说明.asset/image-20210628114018713.png)

这么一来，到第三层的磁盘块时，就总共可以对应`1600*1600`个磁盘块，加上每个磁盘块放了16个data块，总共可以存放40960000K的数据了。现在够用了。

这也就是B+树，其与B树的区别就在于，B+树的非叶子节点上只保存指针，不存储任何数据。而其所有数据都放在叶子节点中。

顺便，以上提到的大小假设等都是真实的数值，换言之，在MySQL中使用B+树作为索引时，要存放千万级别的数据，只需要3-4层的B+树就够了。（此外B+树还有一些额外设定，比如叶子节点间互相用双向链表进行连接等）

## 字典树

字典树和上面的树倒是没什么关系，是一个全新的视角。

首先字典树是一个N叉树。如果规定其维护的数据都是小写字母组成的文本的话，那么N的值就是26。以此为例：字典树在每个节点中存放26个指针指向下层节点，分别对应26个字母。根节点表示BOS。

将一个输入文本按字符拆分后，可以将其挨个代入字典树。字典树关注的不是节点而是路径。每经过一个节点走向下一个节点时，该条路径对应的字母就是文本中对应位置的字符。

一个已经维护成型的字典树对应一些文本的集合。而对于一个新来的文本，通过字典树就可以在O(logn)的时间内查找到新文本是否存在于文本集合中，不用一个个单词去匹配了。

除了字母，字典树也有二进制串的变体。此时字典树是一个二叉树，左子树代表0，右子树代表1。