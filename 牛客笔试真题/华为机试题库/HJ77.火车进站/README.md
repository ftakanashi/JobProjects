## 题目描述
描述
给定一个正整数N代表火车数量，0<N<10，接下来输入火车入站的序列，一共N辆火车，每辆火车以数字1-9编号，火车站只有一个方向进出，同时停靠在火车站的列车中，只有后进站的出站了，先进站的才能出站。
要求输出所有火车出站的方案，以字典序排序输出。

输入描述：
有多组测试用例，每一组第一行输入一个正整数N（0

输出描述：
输出以字典序从小到大排序的火车出站序列号，每个编号以空格隔开，每个输出序列换行，具体见sample。

示例1
```
输入：
3
1 2 3
复制
输出：
1 2 3
1 3 2
2 1 3
2 3 1
3 2 1
复制
说明：
第一种方案：1进、1出、2进、2出、3进、3出
第二种方案：1进、1出、2进、3进、3出、2出
第三种方案：1进、2进、2出、1出、3进、3出
第四种方案：1进、2进、2出、3进、3出、1出
第五种方案：1进、2进、3进、3出、2出、1出
请注意，[3,1,2]这个序列是不可能实现的。 
```

### 解法 DFS
翻译一下，这题就是给出一个入栈顺序，让你求所有可能的出栈顺序。
这里用DFS来做。
dfs函数的参数是，当前扫描到的位置pos，当前栈的情况stack和当前已经记录到的部分出栈结果subres。

函数体中要做的事：尝试将当前位置元素`trains[pos]`追加到stack所有可能的位置上。
比如当前stack是`1 2 3`，而新扫描到一个4。
此时4可以加的位置是3、2、1以及空栈，换言之下一层搜索的dfs参数的stack和subres分别应该长这样：
```text
stack: 1 2 3 4      subres: 空
stack: 1 2 4        subres: 3
stack: 1 4          subres: 3 2
stack: 4            subres: 3 2 1
```

因此函数体中只需要不断地从stack中pop出东西，加入subres，然后追加`trains[pos]`进入下一轮递归即可。
注意如果参数是可变类型，那么要注意不要把值跨越层级。
一个好的办法是使用列表的加法运算而不是使用append等方法。

当然最后别忘了输出要按照字典序。
一时半会儿没想到有什么好的办法可以在扫描过程中保持有序。那就最终将结果容器重新排个序吧。