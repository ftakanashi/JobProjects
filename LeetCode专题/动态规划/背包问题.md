## 总起
经典意义的背包问题，给出两个数组`v[i]`和`w[i]`分别表示`i`号物品的体积和价值。
并给出背包容量`V`。

经典背包求的东西，是在总体积不超过`V`的前提下，能够拿到的最大价值。

背包问题的基本解法形态，是建立一个`(i+1)*(j+1)`的二维DP数组。
其中`i`表示物品个数而`j`表示容量大小。

`dp[i][j]`表示在只取用前i个物品、容量最大能达到`j`的情况下，能够拿到的最大价值是多少。
如此，推导完整个DP数组之后，最后的值`dp[-1][-1]`就是答案了。

## 01背包问题
01背包的基本题设是每个物品只有一件。也就是说每个物品只有取或者不取两种状态。

经典的01背包问题，DP数组全初始化为0。状态转移方程定义如下
```python
dp[i][j] = max(dp[i - 1][j], 
               dp[i - 1][j - v[i]] + w[i]  if j - v[i] >= 0)
```

### 衍生问题：恰好装满
如果题设要求恰好装满背包。那么在状态转移推到各dp值的过程中，选择取的时候必须要求`dp[i-1][j-v[i]]`必须是有值的
（即存在恰好放满`j-v[i]`的方案，此时取`i`后才能满足恰好装满`j`。）

为了方便地添加上述限制条件。那么可以选择初始化DP数组的时候所有值都初始化成-1。
而后将第一行和第一列修改为0。

之后，推到dp的过程中，如果`dp[i-1][j-v[i]]`是-1的话，那么也可以直接跳过。

### 空间优化
二维DP数组空间优化成一维。
但是在01背包问题中，决定`dp[i][j]`可能要用到`dp[i-1][j-v[i]]`，其中`j-v[i]`一定比`j`小，因此不能从左往右推。
相反的可以从右往左推。

空间优化后的转移方程：
```python
for j in range(V+1, 0, -1):    # 这里省略了一些上面提到的判断条件哦
    dp[j] = max(dp[j], dp[j - v[i]] + w[i])
```

## 完全背包
和01背包相对的，完全背包的题设中，物品不是件，而是种。即每个物品都可以取用无数次的情况。

基本解法的框架和01背包是类似的，还是要建立`(i+1)*(j+1)`的矩阵。
只不过这次，`i`指的是物品的种类数了。

DP推导上，针对第`i`种物品，如果一个都不取，那么和01背包的时候一样；
如果取，那么就要考虑事先是否已经取过。因此推导的基准值变成了`dp[i][j-v[i]]`。

总体来说，其状态转移如下：
```python
dp[i][j] = max(dp[i-1][j],
               dp[i][j - v[i]] + w[i]    if j - v[i] >= 0)
```

### 空间优化
和01背包正相反，完全背包问题的`dp[i][j]`依据的是`dp[i][j - v[i]]`，压缩成一维之后其实是本行之前已经更新过的数值。
因此可以大胆地从左到右推导更新状态。

方程如下：
```python
for j in range(V+1):
    dp[j] = max(dp[j], dp[j - v[i]] + w[i])
```

## 多重背包
多重背包是01背包和完全背包的中间体，题设给出的物品不止1个但是也没有无限多，而是给出了限定个数的有限多个。

此时有多种思路。

第一种思路：将物品按个数拆分开，以01背包问题求解。
这种思路比较朴素，容易操作，但是优化不是很好。

第二种思路：进行二进制分解。
基于这样一个事实：任意一个整数n，其一定可以分解成`1, 2, 4, 8, ..., 2^k`(其中`2^k`是比n小的最大的2的次幂)的和
加上一个`2^k ~ 2^(k+1)`之间的数`x`的和。
于是将题目给出的`n`个价值体积分别为`(w,v)`的物品，虚拟地分成`(w, v),(2w, 2v),(4w, 4v)...(2^k w, 2^k v), (xw, xv)`。
然后针对这些物品做01背包。