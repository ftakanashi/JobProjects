# 概述
## 什么是并查集
并查集解决的问题，是无向图的问题。

具体来说，当某个图确定时，构建并查集可以分析图中所有节点之间的关系。

构建完成后的并查集可以通过O(1)的时间和O(n)的空间，来找出图中每个联通分量。

以`LC 547.朋友圈`的场景来举例说明。

当我们有一群人，A是B的朋友，B是C的朋友，那么就认为A也是C的朋友。此时
`A-B-C`形成一个朋友圈。

如果此时，还有`D-E`两个人互为朋友，但是D，E任意一个都不与A，B，C中任意一个是朋友。

所以此时存在两个朋友圈，用图来解释就是：
```text
A-B-C
D-E
```
存在两个联通分量，所以就是两个朋友圈。

当给定你一些输入，比如像547题一样用一个矩阵表示各个节点之间边的关系，让你求出其中"朋友圈"个数，
即联通分量个数，这种情况就可以使用并查集。

## 并查集算法描述
具体如何想到并查集这样一种算法就不说了。总之就当他是既成事实，接受了就好。

我们使用一个长度为节点个数n的数组来实时维护各个节点处于哪个联通分量中，并扫描图。

这里有一个问题，"处于哪个联通分量中"该如何表示。或者说"连通分量"该如何表示。
最先容易想到的是用一个set来表示。但是一来set本身要空间比较大，二来后续会讲到的一些操作中，set并不是很方便。

前人研究出的办法是，用树来表示联通分量，并且在上述数组中存放各个联通分量的父节点。
>这里并没有实际实现树结构，而只是逻辑中有树并且用数组维护了父子节点之间的关系。
>
>和堆的思想类似

接下来，当我们发现`x`和`y`节点之间有连接时，根据数组**查找**到`x`节点所属联通分量的父节点，
而父节点可以进一步回溯，迭代地找到这个联通分量的根节点`root_x`。

同理，根据`y`节点也可以查找到所属联通分量的根节点`root_y`。

如果`root_x`和`root_y`相同，显然两者已经处于同一连通分量中了，不必做任何操作。
如果两者不同，那么就将其中一个联通分量中的根节点指向另一个根节点，完成树的**合并**操作。

如此，先查找，再合并，随着图的扫描，不断地减少连通分量个数，直至扫描结束。

也是因为查找+合并的策略，这算法被称为，并查集。

## 如何实现并查集

初始化状态下，我们假设图中没有任何连接着的边，此时联通分量个数显然就和节点个数相当。
此时这个数组是类似于`fa = [i for i in range(n)]`。即每个联通分量的根节点都是节点自己。`

实现并查集的本质是实现这样一个接口：
```python
class UnionFindSet:
    __init__(self, n: int)
    find(self, x: int) -> int
    union(self, x: int, y: int)
```

`find`方法接收一个合法的下标`x`，并迭代地寻找根节点，返回根节点的下标。

`union`方法接收两个合法下标`x, y`，将找到他们各自所属联通分量的根节点，并且进行根节点之间的合并。

于是第一版代码就有了：
```python
class UnionFind:
    def __init__(self, n):
        self.fa = [i for i in range(n)]
    
    def find(self, x):
        while x != self.fa[x]:    # 当某个位置下标的值就是下标自己，说明其是联通分量的根节点
            x = self.fa[x]
        return x

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x != root_y:
            # 此时self.fa[root_x] == root_x，因为root_x是这个联通分量的根节点
            # 然后，将父节点重置为root_y，相当于将两个连通分量合并
            # 合并后的分量，根节点是原root_y
            self.fa[root_x] = root_y
```

### 路径压缩优化
上述算法有一个问题，当图本身退化成一个链表的时候，`find`方法每次都要O(n)时间。

事实上可以想见，使用`find`回溯寻找根节点的过程，存在大量重复的计算。

所以，可以考虑改变`fa`中值的定义，
不是保存每个节点的父节点，
而是直接保存每个节点的根节点。因为我们也只关心某个节点和跟节点之间的关系，
所以中间那些父节点是什么，这部分信息完全删掉也没事。

但是这样修改之后，union时不能简单地`self.fa[root_x] = root_y`了。事实上`x`所属联通分量中，所有节点都要做这个改变。
如果直接在union中加代码，会显得比较困难。因为要从根节点开始从上向下搜索。

解决办法是，将这个过程在find中实现。

find改造如下：
```python
def find(self, x):
    r = x
    while r != self.fa[r]:
        r = self.fa[r]
    # 此时r是x节点所属连通分量的根节点
    while x != r:
        # 向上搜索root的过程中，途径所有节点的值都换成r
        tmp = self.fa[x]
        self.fa[x] = r
        x = tmp
    return r
```

如此，在每一次union过后，虽然被union的分量中各个节点的根节点信息还不会被实时更新。
但是只要这些节点后续被`find`，那么就可以保证最新信息被更新上去。

## 分析和其他
理想情况下，当并查集构建完成并被`find`够一定次数后，可以认为所有的信息都被更新了。
此时再根据下标查找连通分量时就只需要O(1)时间。

空间方面，显然全程只用了O(n)的数组。

以上说明的并查集，前提都是在开始扫描前n的值是固定的，即节点数量不变。
如果节点数量可变，比如朋友圈问题中，新加入一个人，并给出其与其他人的朋友关系，问朋友圈数量是否有变化。

此时，显然`self.fa`中里要新append上一个元素。然后再扫描此节点和其他节点的关系，适当更新fa即可。

此外这个算法好像还有个小bug，当最后一次union完了之后，被union的那个分量的非根节点，此时信息都还没被更新。
要解决这个似乎只能最后再针对所有位置再find一遍。