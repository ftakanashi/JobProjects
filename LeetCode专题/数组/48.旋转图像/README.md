## 题目描述

给定一个 n × n 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

说明：

你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

示例 1:

>给定 
>```
>matrix = 
>[
>  [1,2,3],
>  [4,5,6],
>  [7,8,9]
>],
>```
>
>原地旋转输入矩阵，使其变为:
>```
>[
>  [7,4,1],
>  [8,5,2],
>  [9,6,3]
>]
>```

示例 2:
>给定 
>```
>matrix =
>[
>  [ 5, 1, 9,11],
>  [ 2, 4, 8,10],
>  [13, 3, 6, 7],
>  [15,14,12,16]
>],
>``` 
>
>原地旋转输入矩阵，使其变为:
>
>```
>[
>  [15,13, 2, 5],
>  [14, 3, 4, 1],
>  [12, 6, 8, 9],
>  [16, 7,10,11]
>]
>>```

### 解法1 分治
乍一看很简单的操作，其实仔细想想也没那么简单。

观察输入和输出，其实可以发现，旋转是分成几个独立的部分进行的。

比如示例2中的4*4矩阵，最外层的12个元素时一组。

而抛开最外层，里面的一层也就是第二层的旋转又和最外层不相干。事实上，完全里面完全可以看做是一个2*2矩阵的旋转。

因此可以按照层的不同，分别处理各自层的旋转操作。

更具体的，每层里面发生了什么事呢？以最外层为例，其实各个元素又被分成了4个一组的小组。
比如`5,11,16,15`或者`1,10,12,13`。小组内四个元素的位置是互相关联且小组间相互独立。

小组内的操作，其实和【189.旋转数组】类似。

所以可以写出伪代码：
```text
for layer in layers
    for group in layer
        rotate(group)
```

剩下的问题可能就是rotate具体怎么办了。
对于原来处于第i行，第j列的元素而言，旋转之后会变成第j行，倒数第i列。

因此这个下标的关系也知道了：`i, j -> j, n - i - 1`

根据上述思路就可写出代码。

### 解法2 通过转置解
首先应该注意，题目中的旋转和矩阵的转置是两种不同的操作。
转置指所有`[i, j]`元素变成`[j, i]`。

尝试转置之后发现，转置和题意的旋转有关系：
```text
1 2 3
4 5 6
7 8 9
-> 转置后
1 4 7
2 5 8
3 6 9
-> 反转
7 4 1
8 5 2
9 6 3
```

所以按照这个办法，可以更快更简洁地解决这个问题。