## 题目描述
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:
>输入: [2,2,1]
>
>输出: 1

示例 2:
>输入: [4,1,2,1,2]
>
>输出: 4


### 解法 位运算
用外部空间或者非O(n)的方法就不说了。

这里重点说O(n)的方法。

其实我率先想到的思路是这样的，从前向后扫描，然后维护一个类似于和的累计值。只要重复数字，第一次遇到时就加上他，
第二次遇到就减去他，最终遍历完成时剩下的累计值就是那个单个的数字了。

但是这显然不靠谱，和会覆盖数字性质，并且也没法判断是第一次还是第二次遇到。

然后想到了位运算。因为刚好要去除的数字都是两个一对的，而只有相同数字的异或运算会得到0。
但是想了一会儿还是没想到到底怎么把这个性质用进去。

其实还是知识的不足够，异或有这样一个性质：
```python
x^y^x = y
```
这在x和y表示任意的一位的时候成立，表示一个十进制数的时候也成立。

所以，基于这个性质就可以很容易想到解法。如果重复数字都只重复两次，那么可以一路异或过去即可。
比如给出输入是`a b c b a`，那么`a^b^c^b^a`的值就是`c`

代码：
```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return reduce(lambda x, y: x^y, nums)
```

reduce这个函数恰好在这里很好用。