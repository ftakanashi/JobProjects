## 题目描述
给出基数为 -2 的两个数 arr1 和 arr2，返回两数相加的结果。

数字以 数组形式 给出：数组由若干 0 和 1 组成，按最高有效位到最低有效位的顺序排列。例如，arr = [1,1,0,1] 表示数字 (-2)^3 + (-2)^2 + (-2)^0 = -3。数组形式 中的数字 arr 也同样不含前导零：即 arr == [0] 或 arr[0] == 1。

返回相同表示形式的 arr1 和 arr2 相加的结果。两数的表示形式为：不含前导零、由若干 0 和 1 组成的数组。

示例 1：
```
输入：arr1 = [1,1,1,1,1], arr2 = [1,0,1]
输出：[1,0,0,0,0]
解释：arr1 表示 11，arr2 表示 5，输出表示 16 。
```
示例 2：
```
输入：arr1 = [0], arr2 = [0]
输出：[0]
```
示例 3：
```
输入：arr1 = [0], arr2 = [1]
输出：[1]
```

提示：
```
1 <= arr1.length, arr2.length <= 1000
arr1[i] 和 arr2[i] 都是 0 或 1
arr1 和 arr2 都没有前导0
```

### 解法 数学 模拟
这题比看起来还是要难一些…让我今天开局心态就有点崩…

做这道题的一个前提知识，是如何基于位数进行二进制的加法。其实这个是有个固定的套路的。
具体的，我们设置一个进位值carry。初始化为0。

然后将两个二进制数从低到高依次进行基于位数的加和。
在考虑到加起来的和大于1时要向前进一位，此时将carry值设置为1。而每个位置的加和考虑两个数对应位置的和加上carry。
如此一来，在考虑到进位的情况下，某个位置的加和值的可能性总共有 0,1,2,3 四种情况。（比如3是两个数原本各自位置都是1，再加上有来自低位的进位时的情况

总结一下， 普通的逐位二进制加法的算法大概是：
```python
carry = 0
ans = []
for a, b in zip(arr1, arr2):
    x = a + b + carry
    if x in (0, 1):
        ans.append(x)
        carry = 0
    elif x in (2, 3):
        ans.append(x - 2)
        carry = 1
```

当变成这道题目的题设，即基数是-2的时候，则需要一些调整。
比如，当两个位置的各自的和超过1的时候，此时应当进位。可是由于在-2基数中各个位置的正负号是互相交错的，所以进位应当是-1而不是1。
比如这样两个数相加：`11000`和`1000`。只看从右往左第四位的情况，转化成十进制，应该是`-2^(3) + -2^(3) = -16 = -(-2^(4))`。
也就是说，此时进位到从右往左第五位的时候，应该加一个-1上去，因此结果是把原本位于最高为的1给抵消掉了。

由于进位后加的值是-1，随之而来的另一个问题是，当某个位置加出来是-1的时候应该怎么处理。
此时假设十进制表示为`-1 * -2^(k)`，这个数可以表示为`-2^(k+1) + -2^(k)`。
也就是说，比如某个位置两个数各自都是0，低位进位过来一个-1，总的加起来是-1的时候，应当把本位置置为1（对应上式中`-2^(k)`的部分），
然后向上进位一个1（相当于是正常进位了）。

总结一下，上述普通二进制的逐位加法的算法中的核心部分代码，应该改成：
```python
if x >= 2:    #  x = 2或者3
    ans.append(x - 2)
    carry = -1
elif x >= 0:    # x = 0或者1
    ans.append(x)
    carry = 0
else:    # x = -1
    ans.append(1)
    carry = 1
```

再结合考虑一下两个位数长度不一致的情况，以及以-2为基数时特有的，最终加完后可能会存在前导零的问题（比如上面距离中提到的`11000 + 1000`的情况，
会把`11000`中最高位的`1`给抵消，最终变成`0`。
这部分逻辑今天时间不够了，就不多说了，可以看代码体会一下。