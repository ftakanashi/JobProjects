## 题目描述
给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。

示例 1：
```
输入：nums = [3,6,5,1,8]
输出：18
解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。
```
示例 2：
```
输入：nums = [4]
输出：0
解释：4 不能被 3 整除，所以无法选出数字，返回 0。
```
示例 3：
```
输入：nums = [1,2,3,4,4]
输出：12
解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。
```

提示：
```
1 <= nums.length <= 4 * 10^4
1 <= nums[i] <= 10^4
```

### 解法1 贪心
不难看出，所有 `nums` 中的数字都可以根据对3的余数分成三类。余数是0、1、2的。我们分别将这三部分的数字成为`r1, r2, r3`吧。
显然，余数是0，r1中的那些数字是否选择不影响最终结果，由于要求最终结果的数字尽可能大，因此可以将r1全部选选上。

麻烦的在于r2,r3。理想情况下，如果r2和r3中的数字个数相等，那么直接全部取，由于两者中的数字可以一一对应，所以最终加和出来的总数一定是可以被3整除
同时全部选取所有数字可以保证最终的和最大。

而不论是哪种数字，在能否被3整除这方面，只要凑够同余数的3个，也一定可以凑出最终总和能被3整除的情况。

另外一个总的原则是，余数相同时，应该尽量选择绝对值大的数。所以可以先对r2和r3进行从大到小排序，然后从前往后取。

综合考虑上述两种情况，需要制定一种合理的贪心策略。

一开始我考虑了优先将r2和r3中数字一一配对如果哪边多出来了再去凑3个一组的情况。
但是这样是不对的。比如r2中的数字全部都很大，且总数恰好可以被3整除。那么此时与r3中的小数字进行配对的收益不如r2直接内部全选的收益大。

其实这里可以稍微"暴力"一点。
由于3个一组数这个限制在，r2中的数字的选择，一定只有除去最后两个、除去最后一个、全选，这三种情况。r3则也是类似的。
所以，其实只要把r2和r3两个数组整理出来之后，经过一个两重循环，尝试 3 * 3 = 9 种可能（当然判断的标准是总和是否被3整除），那么最终答案一定是包含在其中的。

最后别忘了加上 r1 的全部数字总和。

### 解法2 DP
用DP可以在更简单的复杂度下完成。
定义dp数组，尺寸为 `n * 3`。`dp[i][j]`用来表示，前`i`个数字自由选择，其总和除以3余数为`j`时的最大和。
最终返回`dp[-1][0]`即可。

稍微复杂一些的是状态转移方程。
对于`dp[i]`中的三个数字来说，可以发现`nums[i]`是否取用，以及这个数字对3的余数是两个重要因素。
如果不取用，那么`dp[i]`直接沿用`dp[i-1]`的所有值即可。
如果取用，则需要考虑`nums[i]`对3的余数。

如果`nums[i] % 3 == 0`，此时`dp[i][j]`显然是`dp[i-1][j] + num`就行了。
如果`nums[i] % 3 == 1`，那么就会有`dp[i][0]`由`dp[i-1][2]`决定；`dp[i][1]`由`dp[i-1][0]`决定；`dp[i][2]`由`dp[i-1][1]`决定。
也就是说把余数凑一下。
同理`nums[i] % 3 == 2`的情况类似，不赘述。

总的来说，也就是要根据扫描到的`nums[i]`对3的余数分类讨论，将`dp[i][j]`更新为`dp[i-1][j]`和上述规则下`dp[i-x][x] + nums[i]`的较大值。

除此之外，这题DP的初值也是一个稍麻烦的点。
按照DP的惯例，可以将DP的第一维度长度设置为`n+1`。
而`dp[0]`应当设置为`[0, INF, INF]`。以表示不选择任何数字的时候，对3余数为零的总和是0，另两种情况不可能，所以总和是负无穷。

这个初值可以说取的必须是这样的。不能是`[0,0,0]`或者三个负无穷。否则都会导致后面递推崩坏…


不管多难，到这里，DP数组定义有了，递推方程有了，初值也有了，就好写了。
剩下的就是优化代码了。

可以发现`dp[i]`中值的更新只和`dp[i-1]`中的有关，状态压缩有了。
另外，上面根据`nums[i]`对3余数分类讨论，从而把`dp[i-1]`中的某个下标对应到`dp[i]`中的某个下标，中间的这个对应关系，实际上也可以总结。
总结一下就是：
```python
(x + num % 3) % 3 -> x
```
箭头右边是`dp[i-1]`中的下标，箭头左边是`dp[i]`中的下标。

综合考虑以上所有，代码就出来了。