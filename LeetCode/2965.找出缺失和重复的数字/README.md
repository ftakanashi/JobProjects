## 题目描述
给你一个下标从 0 开始的二维整数矩阵 grid，大小为 n * n ，其中的值在 [1, n2] 范围内。除了 a 出现 两次，b 缺失 之外，每个整数都 恰好出现一次 。

任务是找出重复的数字a 和缺失的数字 b 。

返回一个下标从 0 开始、长度为 2 的整数数组 ans ，其中 ans[0] 等于 a ，ans[1] 等于 b 。

示例 1：
```
输入：grid = [[1,3],[2,2]]
输出：[2,4]
解释：数字 2 重复，数字 4 缺失，所以答案是 [2,4] 。
```
示例 2：
```
输入：grid = [[9,1,7],[8,9,2],[3,4,6]]
输出：[9,5]
解释：数字 9 重复，数字 5 缺失，所以答案是 [9,5] 。
```

提示：
```
2 <= n == grid.length == grid[i].length <= 50
1 <= grid[i][j] <= n * n
对于所有满足1 <= x <= n * n 的 x ，恰好存在一个 x 与矩阵中的任何成员都不相等。
对于所有满足1 <= x <= n * n 的 x ，恰好存在一个 x 与矩阵中的两个成员相等。
除上述的两个之外，对于所有满足1 <= x <= n * n 的 x ，都恰好存在一对 i, j 满足 0 <= i, j <= n - 1 且 grid[i][j] == x 。
```

### 解法 原地哈希
如果用哈希集遍历一次做的话毫无难度，就不说了。

这里讲一个稍微有挑战性一点的做法，目标是用O(1)空间。
当然这个也不是太难，远古时期的数组上就有类似的做法，只不过这里改成了二维矩阵了。

就是遍历一次矩阵，并尽可能将数字`k`放到下标为 `(k-1)//n, (k-1)%n` 的位置上。
当某一次目标位置的值已经是预期值了，说明此值为重复值。
将其记录下来并将当前位置置空。

随着遍历完一遍矩阵，所有数字都归为并且会有一个位置值为空，将其对应下标找出来，得到缺失值。