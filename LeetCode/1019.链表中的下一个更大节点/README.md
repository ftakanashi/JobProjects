## 题目描述
给定一个长度为 n 的链表 head

对于列表中的每个节点，查找下一个 更大节点 的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值 严格大于 它的值。

返回一个整数数组 answer ，其中 answer[i] 是第 i 个节点( 从1开始 )的下一个更大的节点的值。如果第 i 个节点没有下一个更大的节点，设置 answer[i] = 0 。

示例 1：

![](https://assets.leetcode.com/uploads/2021/08/05/linkedlistnext1.jpg)
```
输入：head = [2,1,5]
输出：[5,5,0]
```
示例 2：

![](https://assets.leetcode.com/uploads/2021/08/05/linkedlistnext2.jpg)
```
输入：head = [2,7,4,3,5]
输出：[7,0,5,5,0]
```

提示：
```
链表中节点数为 n
1 <= n <= 104
1 <= Node.val <= 109
```

### 解法 单调栈
找出数组内左边/右边下一个更大/更小的元素，经典的用单调栈的场景。

虽然这题的数据不是数组，而是链表，不过因为数据范围不大，所以依然可以暴力地把链表整合成一个数组来解。

顺便回顾一下单调栈的对应方式。
找左边/右边的，就从左到右/从右到左遍历。
找更大/更小的，就维护一个递减/递增单调栈。

这题是求右边的下一个更大的元素，所以就是从右到左遍历并且维护一个递减单调栈。

更具体的，从右到左遍历时，遍历到数字`num`时先判断当前栈顶是否大于`num`，若是则弹出栈顶直至栈空或者栈顶大于`num`。
记录栈顶值（空栈时则记录一个特殊值）表示当前数字右侧下一个更大数字的下标，然后将当前下标入栈。

多说一句，正是因为在上述算法下要从右到左遍历，所以没办法直接处理链表，才迫不得已将链表转化为连续表处理，最终也能85%+。

但是官方似乎有更高明的方法。有空可以看一下。