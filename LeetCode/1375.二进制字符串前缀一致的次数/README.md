## 题目描述
给你一个长度为 n 、下标从 1 开始的二进制字符串，所有位最开始都是 0 。我们会按步翻转该二进制字符串的所有位（即，将 0 变为 1）。

给你一个下标从 1 开始的整数数组 flips ，其中 flips[i] 表示对应下标 i 的位将会在第 i 步翻转。

二进制字符串 前缀一致 需满足：在第 i 步之后，在 闭 区间 [1, i] 内的所有位都是 1 ，而其他位都是 0 。

返回二进制字符串在翻转过程中 前缀一致 的次数。

示例 1：
```
输入：flips = [3,2,4,1,5]
输出：2
解释：二进制字符串最开始是 "00000" 。
执行第 1 步：字符串变为 "00100" ，不属于前缀一致的情况。
执行第 2 步：字符串变为 "01100" ，不属于前缀一致的情况。
执行第 3 步：字符串变为 "01110" ，不属于前缀一致的情况。
执行第 4 步：字符串变为 "11110" ，属于前缀一致的情况。
执行第 5 步：字符串变为 "11111" ，属于前缀一致的情况。
在翻转过程中，前缀一致的次数为 2 ，所以返回 2 。
```
示例 2：
```
输入：flips = [4,1,2,3]
输出：1
解释：二进制字符串最开始是 "0000" 。
执行第 1 步：字符串变为 "0001" ，不属于前缀一致的情况。
执行第 2 步：字符串变为 "1001" ，不属于前缀一致的情况。
执行第 3 步：字符串变为 "1101" ，不属于前缀一致的情况。
执行第 4 步：字符串变为 "1111" ，属于前缀一致的情况。
在翻转过程中，前缀一致的次数为 1 ，所以返回 1 。
```

提示：
```
n == flips.length
1 <= n <= 5 * 104
flips 是范围 [1, n] 中所有整数构成的一个排列
```

### 解法 一次遍历
需要透过现象看本质。

所谓的二进制数其实就是一个幌子，本质就是给出了一个`1-n`的排列，然后需要判断存在多少位置`p`，
使得排列`flips`的前`p`个数字，恰好也是`1-p`的一个排列。

那么如何才能确定`p`是否符合这个要求呢？
注意到当前`p`个数字是`1-p`的排列时，此时有个性质就是前`p`个数字的最大值就是`p`本身。

于是稍微多想一点就知道，当从左到右扫描`flips`时，维护扫描到过的最大值。
只有当最大值等于当前位置`p`时，说明此时的前`p`个数字一定是一个`1-p`的排列。

因此从左到右一次扫描，然后记录符合条件的位置个数即可。