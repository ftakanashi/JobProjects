## 题目描述
给你一个整数数组 arr，请你将该数组分隔为长度 最多 为 k 的一些（连续）子数组。分隔完成后，每个子数组的中的所有值都会变为该子数组中的最大值。

返回将数组分隔变换后能够得到的元素最大和。本题所用到的测试用例会确保答案是一个 32 位整数。

示例 1：
```
输入：arr = [1,15,7,9,2,5,10], k = 3
输出：84
解释：数组变为 [15,15,15,9,10,10,10]
```
示例 2：
```
输入：arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4
输出：83
```
示例 3：
```
输入：arr = [1], k = 1
输出：1
```

提示：
```
1 <= arr.length <= 500
0 <= arr[i] <= 109
1 <= k <= arr.length
```

### 解法 DP
这题是属于比较容易脑补的DP。
读完题目，可以发现，是否将某一段作为单独的子数组分隔出来，与前面如何分割有关，所以得用DP。

看到这种数组的DP，很容易就想到定义`dp[i]`为到位置`i`为止，能够形成的最大和。
接下来就是找这个最大和和前面的最大和之间的关系，从而得到状态递推方程了。

对于这道题，随着对`arr[i]`这个数字的引入，随之而来的可能的分隔方法就是将`arr[i]`以及之前的多个数字组成一个子数组的情况。最多不超过`k`。
我们设选取下标`j`为边界，`j < i`，实际上`j`的取值范围应该是`range(i-k, i)`。
显然，此时有`dp[i] = dp[j] + max(arr[j+1:i+1]) * (i - j)`。

其实到这里，这道题就可以AC了，但是还有一个优化点。

上述状态转移方程中，`max`部分其实是一个遍历过程，结合最外层对`i`的遍历，以及内层对`j`的遍历，加上这个遍历，整体复杂度是`O(n * k^2)`。
而如果可以对`j`的遍历逆向进行，由于尾巴部分中的数字始终都会存在于截取出来的子数组中，所以可以一次遍历完成上述后两个遍历的事情。
复杂度也可以降低到`O(n * k)`。

也就是说，对`j`的遍历，实际上可以是`range(i-1, i-k-1, -1)。

以上就是最核心部分的算法了。其余的比如对`k >= len(arr)`的情况，以及`dp`数组中前`k`个位置等特殊情况的优化很简单，就不多说了。