## 题目描述
一个公司在全国有 n 个分部，它们之间有的有道路连接。一开始，所有分部通过这些道路两两之间互相可以到达。

公司意识到在分部之间旅行花费了太多时间，所以它们决定关闭一些分部（也可能不关闭任何分部），同时保证剩下的分部之间两两互相可以到达且最远距离不超过 maxDistance 。

两个分部之间的 距离 是通过道路长度之和的 最小值 。

给你整数 n ，maxDistance 和下标从 0 开始的二维整数数组 roads ，其中 roads[i] = [ui, vi, wi] 表示一条从 ui 到 vi 长度为 wi的 无向 道路。

请你返回关闭分部的可行方案数目，满足每个方案里剩余分部之间的最远距离不超过 maxDistance。

注意，关闭一个分部后，与之相连的所有道路不可通行。

注意，两个分部之间可能会有多条道路。


示例 1：

![](https://assets.leetcode.com/uploads/2023/11/08/example11.png)

```
输入：n = 3, maxDistance = 5, roads = [[0,1,2],[1,2,10],[0,2,10]]
输出：5
解释：可行的关闭分部方案有：
- 关闭分部集合 [2] ，剩余分部为 [0,1] ，它们之间的距离为 2 。
- 关闭分部集合 [0,1] ，剩余分部为 [2] 。
- 关闭分部集合 [1,2] ，剩余分部为 [0] 。
- 关闭分部集合 [0,2] ，剩余分部为 [1] 。
- 关闭分部集合 [0,1,2] ，关闭后没有剩余分部。
总共有 5 种可行的关闭方案。
```

示例 2：

![](https://assets.leetcode.com/uploads/2023/11/08/example22.png)

```
输入：n = 3, maxDistance = 5, roads = [[0,1,20],[0,1,10],[1,2,2],[0,2,2]]
输出：7
解释：可行的关闭分部方案有：
- 关闭分部集合 [] ，剩余分部为 [0,1,2] ，它们之间的最远距离为 4 。
- 关闭分部集合 [0] ，剩余分部为 [1,2] ，它们之间的距离为 2 。
- 关闭分部集合 [1] ，剩余分部为 [0,2] ，它们之间的距离为 2 。
- 关闭分部集合 [0,1] ，剩余分部为 [2] 。
- 关闭分部集合 [1,2] ，剩余分部为 [0] 。
- 关闭分部集合 [0,2] ，剩余分部为 [1] 。
- 关闭分部集合 [0,1,2] ，关闭后没有剩余分部。
总共有 7 种可行的关闭方案。
```

示例 3：
```
输入：n = 1, maxDistance = 10, roads = []
输出：2
解释：可行的关闭分部方案有：
- 关闭分部集合 [] ，剩余分部为 [0] 。
- 关闭分部集合 [0] ，关闭后没有剩余分部。
总共有 2 种可行的关闭方案。
```

提示：
```
1 <= n <= 10
1 <= maxDistance <= 105
0 <= roads.length <= 1000
roads[i].length == 3
0 <= ui, vi <= n - 1
ui != vi
1 <= wi <= 1000
一开始所有分部之间通过道路互相可以到达。
```

### 解法 Floyd算法 暴力
这题如果能立刻想到用Floyd算法其实就不难了，因为`n`的最大值也不过是10而已。所以大体的思路是：

首先我们遍历所有子集，尝试所有关闭部分分部的方案。
这个自己可以通过一个长度为`n`的opened数组，其中值是0或1来表示某个分部是否被关闭（0是关闭）

显然一个特定的opened数组就对应一个关闭分部的方案。

基于这个方案，通过floyd算法算得这种方案下任意两个节点之间的最短路。
然后再次遍历所有节点对，看节点两两之间是否其最短路超过了可接受的最大值即 `maxDistance`。

以上思路很清晰了，但是实现起来还是稍微有点诀窍的。

首先是遍历所有可能的方案，对于这种每个元素都有取或者不取两种情况的遍历，（也就是排列组合中的组合问题）有一种遍历窍门。
```python
opened = [0 for _ in range(n)]
for mask in range(1 << n):
    for i in range(n):
        opened[i] = mask & (1 << i)
```

可以看到，直接遍历0到`1 << n` 之间的所有数，从二进制的视角来看，其实就是遍历了`n`个位置上所有取0或者1的情况了。
在某个mask下，通过取 `mask & (1 << i)` 即可判断某个位置是0还是1了。

Floyd算法的详细就不说了。建议再看看整体代码和其中的注释。