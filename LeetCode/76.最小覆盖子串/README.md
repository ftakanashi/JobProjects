## 题目描述
给你一个字符串 s 、一个字符串 t 。

返回 s 中涵盖 t 所有字符的最小子串。

如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。

示例 1：
>输入：s = "ADOBECODEBANC", t = "ABC"
>
>输出："BANC"

示例 2：
>输入：s = "a", t = "a"
>
>输出："a"
 

提示：
- 1 <= s.length, t.length <= 105
- s 和 t 由英文字母组成
- 进阶：你能设计一个在 o(n) 时间内解决此问题的算法吗？

### 解法 滑动窗口
看到求一个连续的子串，想到了可以用滑动窗口。

前段做到一个题目看似用滑窗结果最后用了DP。不过那题好像只是就一个最值数字，而这里要求最终的子串，所以还是得用滑窗。

问题在于，怎么滑动呢。

复习一下滑动窗口的定义。
>在一维数组上，前后两个游标`i,j`依次从左到右移动，保持`i`始终小于`j`并且保持任意时刻只有一个游标在动。
所以滑窗的关键在于确定什么时候让`j`动，什么时候让`i`动。
>
>某种意义上来说，滑窗的本质是贪心。

这道题，先尝试性地想，`j`先从左到右扫描到第一个符合条件的窗口。
注意，示例很具有迷惑性恰好s的第一个字母在t内。其实不一定。
比如把`s`换成`XXXADOBECODEBANC`这样可能会更清晰一些。

这其实作为一个时间节点。扫描到此处时，差不多可以考虑停止`j`的扫描开始`i`的扫描了。

那么`i`开始扫描的节点又在哪里?显然`i`移动过`A`之后，窗口就不是一个有效的答案了。
此时继续回到`j`去扫描。

整体算法描述就是，`i,j`窗口初始化后向右滑动。
当窗口内不是符合条件的字符串（即含有所有t中字符），那么移动`j`扩大扫描范围。

当达到符合条件时，停止`j`的右移，开始`i`的左移。
注意结果在此时间点收集。因为第一个会使得窗口失效的字母可能在比较靠后的位置，这样左移`i`可以获得长度更小的结果。

就是这么一个简单的算法。

某种意义上，**我觉得这道题应该是一道滑动窗口的经典题，最小覆盖子串，好好记住这种套路吧。**

最后，实现上唯一的难点可能是如何确定一个窗口是否有效了。
因为题目没有限制条件，意味着t中可能有重复字母。

所以目前想到也是唯一想到的，是搞一个counter记录t的各个字母在窗口中的"消耗情况"。
注意其可能变成负数（指窗口内含某个字母个数多余t中个数）。

这样，随着滑动实时维护这个counter的话，只要判断`max(counter.values())`是否小于等于0即可。
如果小于等于0，说明窗口完全覆盖t中每个字母，是合法有效的，否则无效。
