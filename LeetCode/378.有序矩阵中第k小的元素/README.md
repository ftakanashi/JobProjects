## 题目描述

给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。

请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。

示例：
>
>```text
>matrix = [
>   [ 1,  5,  9],
>   [10, 11, 13],
>   [12, 13, 15]
>],
>```
>k = 8,
>
>返回 13。 

提示：
- 你可以假设 k 的值永远是有效的，1 ≤ k ≤ n^2 。


### 解法1 flatten后排序
不解释。时间O(n^2 logn)。空间O(n^2)

注意此时的n代表的是矩阵的边长，所以是n^2，而log(n^2)实际上又是2logn，所以可以简化成logn

### 解法2 用堆部分排序
上述排序方法，有个很明显的问题，就是明明只需要求第k个小的数，但是却把所有数都排了个序，浪费了很多算力。

注意到，对于整个矩阵而言，全局最小值总是左上角那个数。如果把它pop掉，那么剩余内容中最小值，只可能是`0,1`或者`1,0`位置这两个数。
接着再去掉其中较小的数，那么把相应游标后移或者下移，可以继续得到两个候选数。

如此，想到可以用两个游标分别来始终指向两个候选数，模拟依次pop出矩阵剩余数中最小值，pop出k次就可得到答案。

这样做当然可以，不过细节可能比较麻烦。比如两个游标指向同一个数后怎么办，换行，换列的情况也需要考虑。

下面介绍用堆来简化这一部分的实现。

具体而言，选定第一列建堆，堆长为n。
然后按照下述操作循环。
pop出最小元素。最开始当然就是堆顶也就是左上角元素被pop出。然后将第一行的第二个元素入堆。这就是上面说的第二个候选数。
重建堆序之后，再pop一次。循环往复。