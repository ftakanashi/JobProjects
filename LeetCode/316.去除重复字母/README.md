## 题目描述
给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。

注意：该题与 1081 https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters 相同

示例 1：
```
输入：s = "bcabc"
输出："abc"
```
示例 2：
```
输入：s = "cbacdcbc"
输出："acdb"
```

提示：
```
1 <= s.length <= 104
s 由小写英文字母组成
```

### 解法 单调栈
这题其实和`LC402`很像。
先思考简单一点的问题，对于一个字符串，去掉一个字母后使得剩余字符串字典序最小，该怎么办。

参考`LC402`可以知道，其实是用一个单调栈来扫描各个字符。
当碰到当前字符比栈顶要小的时候，说明舍弃栈顶字符更加合理。

具体到这题，因为题目没有具体说要舍弃几个字符，而是要我们保证最终字符串没有重复，于是很自然地，只能通过一个计数器来保证了。

回到上面说的算法，舍弃栈顶时的判断条件，除了当前字符比栈顶小以外，还需要保证栈顶字符计数是大于1的。

如果栈顶字符计数等于1，说明这已经是唯一的一个了，不能再舍弃。唯一性要优先于保证字典序。

此外，加上计数器后虽然可以保证不会多舍弃，但是还没有保证无冗余。比如`abcabc`这种序列，其实扫描到第二个a的时候，因为前面已经出现过a了，
所以可以直接continue掉的。

这个过程，显然可以用一个`seen = set()`来实时维护栈中有哪些字符，从而避免冗余。

最后还有一个注意点，看例子`bbcaac`。
如果扫描到重复字符后直接continue，此时counter会出现一定问题。
比如扫描到第一个a的时候，栈里应该是`b c`，而counter的`b`的计数还是2。此时会导致第一个b被pop掉。
这样最终结果里就没b了。
说明重复字符的continue之前，应该也实时地进行counter的更新维护。

实际上，counter的意义是，目前还没有决定被舍弃的字符的计数情况。而当发生continue的时候其实就是舍弃了，因此需要实时更新。