## 题目描述
你的任务是计算 a^b 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。

示例 1：
```
输入：a = 2, b = [3]
输出：8
```
示例 2：
```
输入：a = 2, b = [1,0]
输出：1024
```
示例 3：
```
输入：a = 1, b = [4,3,3,8,5,2]
输出：1
```
示例 4：
```
输入：a = 2147483647, b = [2,0,0]
输出：1198
```

提示：
```
1 <= a <= 231 - 1
1 <= b.length <= 2000
0 <= b[i] <= 9
b 不含前导 0
```

### 解法 快速幂
先说个题外话，Python的整数运算因为不存在溢出的概念，因此完全可以暴力直接算直接求解，也能AC。
当然这题本意不是暴力。

分析题目，发现我们主要需要解决的，其实是两方面的问题。

第一，不论是a还是b，很大的时候进行乘方，必然会溢出。因此需要考虑运算过程中的及时取余。
而运算过程中直接取余的前提条件就是取余运算是可传递的。
比如某个底数`a`对`1337`取余得到`123`。那么其平方就可以表示为:
```text
[1337*k + 123] * [1337*k + 123]
```
拆分后可以发现，其实其结果与`123^2`直接对`1337`取余等价。
而把平方扩展成三次、四次、n次方，这个结论也都成立。
并且我们没有明确指定`a`是多少，说明即便是二次结果的`123^2`这种，也可以进行进一步的对`1337`的取余。
这就给了我们一个没有明确证明，但是相对有底气的结论：当你觉得计算过程的中间结果可能会比较大时，取余就完了。

第二，因为b表示的数字很大，所以肯定不能真的计算出来然后进行线性的乘方计算。
这里，很明显可以想到，用快速幂。快速幂的具体解释可以参考`LC.50`的说明。
问题在于如何将快速幂应用到以数组表示的幂中去。
这里其实是一个套娃。

举个例子，比如b形如`[..., 8, x, x]`。此时倒数第三位是8，说明`a ^b`中会有一个累乘的因子是`a ^ 800`。
这可以表示成`(a ^ (100)) ^ 8`。
更一般的，对数组b，要求的结果`a ^ b`可以表示成：
```text
连乘base ^ (b[i]) for i in range(n)
其中，base = a ^ ( 10^(n-1-i) )
```
这其实本身就是快速幂思想的再次应用，在扫描过程中，和快速幂算法中一样，base的翻倍可以通过对上轮迭代base的`base ^ 10`算出，从而避免了线性的计算。
而另一方面，`base ^ b[i]`以及`base ^ 10`都可以通过经典的二进制快速幂算法计算得出。

最后，别忘了计算过程中可能的溢出，因此对计算的中间结果及时进行取余。
