## 题目描述
给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效的 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效的 IP 地址。

示例 1：
```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```
示例 2：
```
输入：s = "0000"
输出：["0.0.0.0"]
```
示例 3：
```
输入：s = "1111"
输出：["1.1.1.1"]
```
示例 4：
```
输入：s = "010010"
输出：["0.10.0.10","0.100.1.0"]
```
示例 5：
```
输入：s = "101023"
输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
```

提示：
- 0 <= s.length <= 3000
- s 仅由数字组成

### 解法 DFS
很明显用DFS。可能难度就在于如何设计dfs函数。

对于这种在一维数组上进行搜索的问题，通常问题建模时考虑将问题规模缩小化。
因为是一维数组，所以经常考虑的，是当不是从头开始，而是从某个特定位置`start`开始搜索一个更短的数组时是什么情况。
因此，DFS函数中会有`start: int`这个参数。

其次，由于本质上这是个区块分割，中间结果也要用list来保存，所以这个DFS函数也应该有一个中间结果容器`res: List`。

然后就是递归终止条件。显然，当res长度到达4，或者start超过界限时就应该终止递归。
然而两者并不一定同时达到，因此只有对两者同时达到的情况进行结果收割，否则直接而终止即可。