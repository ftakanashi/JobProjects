## 题目描述
给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。

注意，删除一个元素后，子数组 不能为空。

示例 1：
```
输入：arr = [1,-2,0,3]
输出：4
解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。
```
示例 2：
```
输入：arr = [1,-2,-2,3]
输出：3
解释：我们直接选出 [3]，这就是最大和。
```
示例 3：
```
输入：arr = [-1,-1,-1,-1]
输出：-1
解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。
     我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。
```

提示：
```
1 <= arr.length <= 105
-104 <= arr[i] <= 104
```

### 解法 DP
一开始以为要用滑窗，看了眼提示就开始想DP。
注意审题，题目说的是子数组而不是子序列，所以意味着必须是连续的。

我们设计一个size为 n * 2 的DP数组。
其中，`dp[i][0]`表示以下标第`i`个数字为结尾的子数组，在不删除数字的情况下所能获取到的最大和。
`dp[i][1]`则表示以下标第`i`个数字为结尾的子数组，在删除一个数字（注意，并不一定是删除`arr[i]`，只要有删除一个数字的情况，都归类到这里）所能或得到的最大和。

显然，初始情况的`dp[0]`的值应该是`[arr[0], 0]`。
这里还有一个小坑，就是`dp[0][1]`的这个0可能是不能取的。这里后续在说明。

接着推导状态转移方程。设`arr[i]`为`num`。
首先考虑`dp[i][0]`的情况。由于不删除数字，所以转移到`dp[i][0]`的最大可能是`dp[i-1][0] + num`。
但是不要忘了还有一种情况是无法体现在从`dp[i-1][0]`处转移过来这件事的，那就是`num`本身自成一个子数组的情况。，比如示例2的最终答案就是这种情况。
因此，有`dp[i][0] = max(dp[i-1][0] + num, num)`。

接着考虑`dp[i][1]`的情况。在明确知道要删除一个数字的情况下，又可以讲情况分为，被删除的数字是否在之前就已经被删除，
即从`dp[i-1][1] + num`转移而来，或者是之前没有删除，而是删除`num`本身，此时子数组和就是`dp[i-1][0]`。不用加`num`因为`num`此时被删掉了。

综上所述，转移方程：
```python
dp[i][0] = max(dp[i-1][0] + num, num)
dp[i][1] = max(dp[i-1][0], dp[i-1][1] + num)
```

递推过程中找dp的全局最大值即可。

但是遍历过程中肯定要有一个ans变量来保存当前最大值，这个变量的初值该设置成`-inf`吗？
不能，这就是之前提到的`dp[0][1]`的那个0不一定能取到的情况。
如示例3中，所有数字都是负数的情况，如果简单地`ans = max(dp[i])`的话，最终答案会是零，对应着选取一个-1然后删除-1的情况。
但是题目不允许这个情况。

所以ans初值只能赋`arr[0]`。

最后，发现递推过程中`dp[i]`之和`dp[i-1]`有关，可以状态压缩。