## 题目描述
你有 k 个服务器，编号为 0 到 k-1 ，它们可以同时处理多个请求组。每个服务器有无穷的计算能力但是 不能同时处理超过一个请求 。请求分配到服务器的规则如下：

第 i （序号从 0 开始）个请求到达。
如果所有服务器都已被占据，那么该请求被舍弃（完全不处理）。
如果第 (i % k) 个服务器空闲，那么对应服务器会处理该请求。
否则，将请求安排给下一个空闲的服务器（服务器构成一个环，必要的话可能从第 0 个服务器开始继续找下一个空闲的服务器）。比方说，如果第 i 个服务器在忙，那么会查看第 (i+1) 个服务器，第 (i+2) 个服务器等等。
给你一个 严格递增 的正整数数组 arrival ，表示第 i 个任务的到达时间，和另一个数组 load ，其中 load[i] 表示第 i 个请求的工作量（也就是服务器完成它所需要的时间）。你的任务是找到 最繁忙的服务器 。最繁忙定义为一个服务器处理的请求数是所有服务器里最多的。

请你返回包含所有 最繁忙服务器 序号的列表，你可以以任意顺序返回这个列表。

示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/03/load-1.png)
```
输入：k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] 
输出：[1] 
解释：
所有服务器一开始都是空闲的。
前 3 个请求分别由前 3 台服务器依次处理。
请求 3 进来的时候，服务器 0 被占据，所以它呗安排到下一台空闲的服务器，也就是服务器 1 。
请求 4 进来的时候，由于所有服务器都被占据，该请求被舍弃。
服务器 0 和 2 分别都处理了一个请求，服务器 1 处理了两个请求。所以服务器 1 是最忙的服务器。
```
示例 2：
```
输入：k = 3, arrival = [1,2,3,4], load = [1,2,1,2]
输出：[0]
解释：
前 3 个请求分别被前 3 个服务器处理。
请求 3 进来，由于服务器 0 空闲，它被服务器 0 处理。
服务器 0 处理了两个请求，服务器 1 和 2 分别处理了一个请求。所以服务器 0 是最忙的服务器。
```
示例 3：
```
输入：k = 3, arrival = [1,2,3], load = [10,12,11]
输出：[0,1,2]
解释：每个服务器分别处理了一个请求，所以它们都是最忙的服务器。
```
示例 4：
```
输入：k = 3, arrival = [1,2,3,4,8,9,10], load = [5,2,10,3,1,2,2]
输出：[1]
```
示例 5：
```
输入：k = 1, arrival = [1], load = [1]
输出：[0]
```

提示：
```
1 <= k <= 105
1 <= arrival.length, load.length <= 105
arrival.length == load.length
1 <= arrival[i], load[i] <= 109
arrival 保证 严格递增 。
```

### 解法 有序集合 堆 模拟
这题倒是没什么特别的套路，就是一个比较复杂的模拟。这里直接抄了官方答案的作业。
并且其中的一些功能恰好可以用到有序集合这种数据结构，所以通过这题也可以顺便学习一下这个结构。

我们来思考，当拿到一个task的时候，应该做哪些判断。
显然，我们应该确认当前task的编号，从而通过`i % k`得到这个task应该分配给哪个服务器。
另外由于服务器的busy情况不同，所以还需要维护一个available结构，里面保存了所有可用的服务器，从而确定当`i % k`号服务器不可用时的分配情况。

而available这个结构一个很重要的需求是，要尽可能高效地找出当`i % k`不在其中时通过题目描述的规则找到下一个可用的服务器。
最朴素的做法当然是做线性扫描，而一个更高级的做法是在有序列表中做一个二分搜索。
然而这个操作并不是一锤子买卖，因为服务器根据task分配和完成情况，需要在available中加入或删除。
所以如果只是单纯的一个始终维护有序的列表，其并不十分高效。

此时就用到了有序集合这种结构了。`from sortedcontainers import SortedList`。
`SortedList`的接口有很多，这里主要用到的是`__getitem__`和`bisect_left`这两个。
下面是一段用于表示这种结构一些常用接口的片段代码：
```python
s = SortedList([50, 40, 20, 10, 30])
s.add(60)
s.remove(60)
pos = s.bisect_left(15)
print(s[1])
```

因为available只是维护了"可用"服务器，对于不可用的那部分，如果没有什么特殊的操作，那直接用全集减去可用部分自然是不可用部分。
然而考虑到一个服务器什么时候能从不可用变成可用，还和task的处理时间相关，所以选择一个小顶堆来维护"不可用"这部分。
具体的，我们维护一个名为`busy`的小顶堆，其中每个item是`(time, server)`。
其表示一直到`time`时间点为止服务器`server`都处于busy状态。

由于是小顶堆，所以那些离现在最快能结束task处理转为available的服务器在堆顶。

有了上面两个数据结构后，就可以做出比较完整的模拟流程了。
拿到task后，首先提取其到达时间以及消耗时间。这两者分别是`arrival[i]`和`load[i]`。

接着判断busy堆顶是否有比`arrival[i]`更小的`time`。
若有，那么说明当前这些服务器是可用的，需要将他们pop出来加入available。

接着利用available的接口找到要将task分配到的server，这里称之为`target`。
显然，若此操作前available为空，那么我们只能drop掉这个task。

找到target之后就简单了，将其从available中移除，然后将`(arrival[i] + load[i], target)`入busy堆。

以上就是整个逻辑，按照此逻辑写代码即可。