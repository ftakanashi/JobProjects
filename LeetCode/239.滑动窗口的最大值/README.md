##题目描述
给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。

你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

示例 1：
>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
>
>输出：[3,3,5,5,6,7]
>
>解释：
>```
>滑动窗口的位置                最大值
>---------------               -----
>[1  3  -1] -3  5  3  6  7       3
> 1 [3  -1  -3] 5  3  6  7       3
> 1  3 [-1  -3  5] 3  6  7       5
> 1  3  -1 [-3  5  3] 6  7       5
> 1  3  -1  -3 [5  3  6] 7       6
> 1  3  -1  -3  5 [3  6  7]      7
>```

示例 2：
>输入：nums = [1], k = 1
>
>输出：[1]

示例 3：
>输入：nums = [1,-1], k = 1
>
>输出：[1,-1]

示例 4：
>输入：nums = [9,11], k = 2
>
>输出：[11]

示例 5：
>输入：nums = [4,-2], k = 2
>
>输出：[4]
 

提示：
- 1 <= nums.length <= 105
- -104 <= nums[i] <= 104
- 1 <= k <= nums.length

### 解法1 大顶堆
乍一看以为这是道简单题呢。

因为暴力法是显而易见的，i,j两个游标标记滑动窗口，依次向右扫描。

然后返回窗口中的最大值即可。显然这个做法的复杂度是O(nk)。

试了一下，果然超时了。于是需要想想更好的办法。

以`1 3 -1 -3 -5`这个例子举例。首先，为什么暴力超时了呢。

显然，`i=0`和`i=1`时最大值都是3，但是暴力法在后者又重新找了一次最大值。

在不同的情况下时刻能找到最大值，很容易想到，用堆就行了。

然后顺理成章地想到，用堆的话，如何删去元素是问题。比如从`i=0`到`i=1`虽然确实最大值没变，但是第一个1，不在窗口中了。
从堆里删除一个非堆顶的元素还挺麻烦的。这个问题先忽略掉，默认不删除，继续考虑其他细节。

若不删除，当`i=2`的时候，堆顶仍然是3，但此时3已经不在窗口中了，此时窗口中最大的值是-1。那么该怎么办。自然想到了，pop掉3不就行了。
但是pop掉3之后发现，1也属于仍在堆中但是不在窗口中了，于是继续pop。最终pop两次之后，得到了`-1 -3 -5`的堆，堆顶-1，完事。

以上描述中还有一个小问题，代码中如何实现"3已经不在窗口中了"这个判断。如果采用`3 in [-1, -3, -5]`这种办法显然又要线性时间做检查，不太好。

注意到窗口只是一味地向右移动，所以其实只要判断3的下标在不在i,j之间，更严格地说，只要判断3的下标是不是比i小就行了。
于是解决方法就是，把下标和值一起入堆即可。这样我们就可以知道堆里任何一个值的原下标。

窗口移动后先将新值入堆，然后判断堆顶的原下标是否还在窗口内，如否，则从堆中pop堆顶，直到某个顶下标在窗口内，收割。

复杂度方面，由于n个元素全部都需要入堆一次，所以时间是O(nlogn)。空间方面，由于不是随着窗口滑动实时删除窗外元素，所以空间是O(n)。

### 解法2 单调双向队列
以`1 3 -1 -3 -5 -6`为例。注意到一个特点，在从3开始的序列中，任意一个窗口的最大值都是第一个数，因为后面这个序列是严格递减的。

反之，第一个窗口的前半子序列`1 3`中，其实1这个数并没有什么用。甚至，假如在1前面添加更多的比3小的数字也是没用的，只要3还在窗口内，这些数字
就不可能是窗口内的最大值。

所以设计这样一个内容严格递减的双向队列，其中维护的是各个窗口可能的最大值。当窗口移动扫描到新数的时候，从队列右端开始移除所有比新数小的数。
这些数在当前以及将来一段时间内都不可能成为窗口内最大值了。

要收割结果时，显然拿队列左端值就可以。

至于为什么不用栈而是用双端队列，则和上一个解法的考虑一样，我们需要一个机制把已经脱出窗口左端的那些可能最大值给剔除。

以`1 3 -1 -3 5 3 6 7`为例，这个队列在各个窗口的情况是如下：
```text
3 -1        (1 3 -1) -3 5 ...
3 -1 -3     1 (3 -1 -3) 5 ...
5
5 3
6
7
```

各个时刻队首的元素排列起来恰好是，答案。