## 题目描述
给你一个整数数组 nums ，请你找出 nums 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。

如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集 不同 。

对数组 a 执行 按位或 ，结果等于 a[0] OR a[1] OR ... OR a[a.length - 1]（下标从 0 开始）。

示例 1：
```
输入：nums = [3,1]
输出：2
解释：子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：
- [3]
- [3,1]
```
示例 2：
```
输入：nums = [2,2,2]
输出：7
解释：[2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 23 - 1 = 7 个子集。
```
示例 3：
```
输入：nums = [3,2,1,5]
输出：6
解释：子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：
- [3,5]
- [3,1,5]
- [3,2,5]
- [3,2,1,5]
- [2,5]
- [2,1,5]
```

提示：
```
1 <= nums.length <= 16
1 <= nums[i] <= 105
```

### 解法 DFS
题目不难。

由于或运算的性质，放入尽量多的数肯定可以得到尽量大的结果。
因此，题目虽然只给出输入数组，但是将数组所有数字都或一遍就可以求出所谓的按位或能得到最大值是多少。
即 `target = reduce(lambda a,b: a|b, nums)`

另外，由于是或运算，所以从直觉上来说，应该尽量选用大的数字。
极端来说，最大的那个数字是一定要选的。
我们可以将数组从大到小排序，然后从大到小依次考虑是否在子集中选用这些数字。
这个过程可以通过DFS回溯来实现。

更具体的还有优化的地方。
比如当我们扫描到某个数字，将其加入当前维护的子集后发现，子集的按位或结果已经到达了`target`。
此时从当前位置到数组末尾那些更小的数字，其取舍情况不论如何，都不会影响按位或的结果了，
因此在这个空间中无需进一步DFS，只要在结果种类数中直接加上2的相关次方即可。

具体的，
定义dfs函数`dfs(pos, curr)`。
其中`pos`表示当前扫描到的位置，`curr`表示当前维护的子集能够得到的按位或的结果。
由于两个参数都可哈希且未使用外部结构推进搜索，因此可以直接加上记忆化。

更多细节看代码

