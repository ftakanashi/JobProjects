## 题目描述

给出一个无重叠的 ，按照区间起始端点排序的区间列表。

在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。

 

示例 1：
>输入：intervals = [[1,3],[6,9]], newInterval = [2,5]
>
>输出：[[1,5],[6,9]]

示例 2：
>输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
>
>输出：[[1,2],[3,10],[12,16]]
>
>解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。


### 解法 模拟
粗粗一看感觉想不到什么高级做法。一看解答，大家也都是用最朴素的逻辑模拟整个插入过程。

这道题，与其说是插入，其实不如说是数组的合并问题。

他的逻辑是，新给出的区间`newInterval`实际上像是胶水一样，可以把原来的一部分区间给粘合起来。
这么一来，其实只要遍历原数组，看和`newInterval`区间有交集的，然后把所有有交集的以及`newInterval`自身
给粘合到一起，形成一个新的并集，然后把这个并集放到原数组合适的位置即可。

此时两个重要的操作：判是否有交集，以及求并集怎么做呢？其实不用想内部元素的情况什么的，只要看两边的left,right值即可。

一般来讲，对于区间`[left_a, right_a]`和`[left_b, right_b]`而言：
```text
right_a < left_b or right_b < left_a 表示两者无交集，前面加个not就是有交集

求并集：min(left_a, left_b), max(right_a, right_b)
```

有了这两个操作的实现之后，就可以磨算法了。

我们依次遍历原数组的所有区间`(l, r)`，并且比较其与`newInterval: (new_l, new_r)`的大小。

当`(l, r)`和`(new_l, new_r)`之间没有交集，那么分两种情况，如果`(l, r)`完全在左边，此时直接收割它。
当完全在右边，则可收割`(new_l ,new_r)`并且停止遍历。因为这个时候，`l, r`及其在原数组中所有右边的区间，肯定
都是大于`newInterval`并且无交集的。可以后续一股脑全部收割掉。

稍微麻烦点的是有交集的情况。有交集时，我们把两者的并集求出来，并且把`newInterval`更新成这个并集。
后续的区间，只要和`newInterval`还有交集，就不断扩充`newInterval`，直到某一个区间没有了交集，
此时`newInterval`的扩充也就完成，可以收割并且停止遍历了。

至此，算法基本完成，还有一些小的边界问题需要处理。比如，当`newInterval`恰好吸收了原数组最后一个区间，也就说
`newInterval`的右边界此时也是总数组的右边界，由于它的右边没有比他更大且互相无交集的区间了，因此目前的代码实现中
他无法被收割。

针对这个问题，我的解决办法是在原intervals最后加上一个dummy区间`(inf, inf)`。这可以保证不论你的右边界延伸多大，
最终总会有一个和你无交集且比你大的dummy区间存在，因此代码上来说可以顺利收割`newInterval`。
另一方面，这种办法也顺便处理了原数组为空以及`newInterval`本身和任何区间无交集且最大，这两种特殊情况。

最后别忘了把dummy从返回结果中去掉。如果要求intervals原数组不能被改变，也把dummy从中去掉。