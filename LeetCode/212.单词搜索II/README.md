## 题目描述
给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。

单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

示例 1：

![](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)
```
输入：board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
输出：["eat","oath"]
```
示例 2：
```
输入：board = [["a","b"],["c","d"]], words = ["abcb"]
输出：[]
```

提示：
```
m == board.length
n == board[i].length
1 <= m, n <= 12
board[i][j] 是一个小写英文字母
1 <= words.length <= 3 * 104
1 <= words[i].length <= 10
words[i] 由小写英文字母组成
words 中的所有字符串互不相同
```

### 解法 字典树 + DFS
第一时间能想到的思路肯定是用DFS。但是这里因为要判断是否存在的单词不止一个，所以第一时间想到是不是用哈希集保存words。

但是随即发现问题，对于DFS搜索到的任意一个时刻，我并不知道是搜索到单词的第几个字母了。
换言之，哈希集将单词内部的信息全部都隐去了，从而导致探索时无法判断当前探索的是否是正确的路径。

需要一个数据结构，满足1.能够快速判断某个单词是否存在其中；2.还能提供一些单词内部字母级别的信息。于是想到了用字典树。

针对words，构建起一个字典树（这个过程本身并不难有很多种方法，就不多说了。
接着想要干嘛。

其实可以从board中的每个位置开始进行扫描，扫描时，探索上下左右四个位置，并且维护一个实时字典树指针指向当前扫描到位置的节点。
此时只要看上下左右四个位置是否有字母，其在字典树中对应的子节点是否不为空就好了。
只要不是空，就可以往字典树下一层探索，board上则是向下个位置探索。

别忘了字典树节点中有个end属性，当探索到某个位置后字典树节点的end是True，那么显然，就有一个符合要求的单词了。直接收割即可。

另外为了避免循环探索，别忘了dfs过程中维护一个seen。

更多细节写在了代码的注释中。
注意，这版代码虽然能AC，但是耗时很长，存在很大可优化空间。
具体的优化可以参考官方解答，这里指出几个方向：

1. 不一定需要`path`保存中间结果，实际上探索到某个字典树节点时形成的部分单词，可以在树节点自身内维护一个量来解决
2. 可以使用"修改位置值 - 回溯"的模式进行已经路过节点的标记，这样连seen都可以省了。