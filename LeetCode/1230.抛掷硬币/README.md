## 题目描述
有一些不规则的硬币。在这些硬币中，prob[i] 表示第 i 枚硬币正面朝上的概率。

请对每一枚硬币抛掷 一次，然后返回正面朝上的硬币数等于 target 的概率。

示例 1：
```
输入：prob = [0.4], target = 1
输出：0.40000
```
示例 2：
```
输入：prob = [0.5,0.5,0.5,0.5,0.5], target = 0
输出：0.03125
```

提示：
```
1 <= prob.length <= 1000
0 <= prob[i] <= 1
0 <= target <= prob.length
如果答案与标准答案的误差在 10^-5 内，则被视为正确答案。
```

### 解法 DP（类似背包问题）
一些物品中选取一部分，然后怎么怎么样，可以想到背包问题。

实际上一旦想到了背包问题，虽然这不是经典的背包题设，但是继续推理下去就不困难了。

显然，设总共有m个硬币，我们可以初始化一个`(m+1) * (target+1)`的二维DP数组。
这个数组`dp[i][j]`的意思是，
前`i`个硬币中抛出了`j`个正面的概率。

初始化时显然`dp[0][0] = 1`。
接着，从`1,1`开始扫描，对于一般的`dp[i][j]`来说，
其实这个第`i`个硬币若抛出正面，则需要取前`i-1`个硬币抛出`j-1`个正面的概率乘以当前硬币正面的概率；
若抛出反面，则取前`i-1`个硬币抛出`j`个正面的概率乘以当前硬币抛出反面的概率。
两者之和才是`dp[i][j]`的值。

综上，这是一个很类似背包问题的思想。
只不过背包问题的DP值，是取若干个前序状态的DP值的最值，而这里是求和。