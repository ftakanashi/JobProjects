## 题目描述
给你一个字符串 s 以及两个整数 a 和 b 。其中，字符串 s 的长度为偶数，且仅由数字 0 到 9 组成。

你可以在 s 上按任意顺序多次执行下面两个操作之一：

累加：将  a 加到 s 中所有下标为奇数的元素上（下标从 0 开始）。数字一旦超过 9 就会变成 0，如此循环往复。例如，s = "3456" 且 a = 5，则执行此操作后 s 变成 "3951"。
轮转：将 s 向右轮转 b 位。例如，s = "3456" 且 b = 1，则执行此操作后 s 变成 "6345"。
请你返回在 s 上执行上述操作任意次后可以得到的 字典序最小 的字符串。

如果两个字符串长度相同，那么字符串 a 字典序比字符串 b 小可以这样定义：在 a 和 b 出现不同的第一个位置上，字符串 a 中的字符出现在字母表中的时间早于 b 中的对应字符。例如，"0158” 字典序比 "0190" 小，因为不同的第一个位置是在第三个字符，显然 '5' 出现在 '9' 之前。

示例 1：
```
输入：s = "5525", a = 9, b = 2
输出："2050"
解释：执行操作如下：
初态："5525"
轮转："2555"
累加："2454"
累加："2353"
轮转："5323"
累加："5222"
累加："5121"
轮转："2151"
累加："2050"​​​​​​​​​​​​
无法获得字典序小于 "2050" 的字符串。
```
示例 2：
```
输入：s = "74", a = 5, b = 1
输出："24"
解释：执行操作如下：
初态："74"
轮转："47"
累加："42"
轮转："24"​​​​​​​​​​​​
无法获得字典序小于 "24" 的字符串。
```
示例 3：
```
输入：s = "0011", a = 4, b = 2
输出："0011"
解释：无法获得字典序小于 "0011" 的字符串。
```
示例 4：
```
输入：s = "43987654", a = 7, b = 3
输出："00553311"
```

提示：
```
2 <= s.length <= 100
s.length 是偶数
s 仅由数字 0 到 9 组成
1 <= a <= 9
1 <= b <= s.length - 1
```

### 解法 暴力枚举
这题没那么多技巧，直接暴力枚举即可。
虽说是暴力，但是如果纯纯暴力地从s开始不断尝试累加或者轮转，即便是加了cache、哈希集去重之类的优化，在部分case中还是会超时。

这里我们采用一种更加聪明一点的暴力方法。

不难发现，其实对于任意的字符串s，累加操作能玩出的花是有限的。
对于所有奇数/偶数位，每个数字最多最多也就10种状态，并且由于`a`不变，所以再累加10次之后必然会循环。
更不用说当`b`是偶数的时候（由于题目保证s的长度也是偶数），偶数位不论如何轮转都轮转不到奇数位，所以累加实际上对其不生效。

同理，轮转能玩出的花也是有限的。最极限的情况也不过是`b = 1`并且轮转`len(s)`次。之后也必然陷入循环。

因此，实际上所有可能得到的结果字符串，就被限制在这个空间里。
最多也就 轮转了`n`次，奇数位累加了`10`次，偶数位累加了`10`次。
而根据具体情况不同，甚至会更少。
而`n`最大是100，所以整体数据量不大，可以暴力枚举。

具体的，我们可以先在最外面套一层`for _ in range(n)`。遍历轮转`n`次的情况（这里还有个优化点，下面再说）

然后尝试给轮转后的奇数位累加（最多10次），此时再根据`b`的奇偶性考虑偶数位的累加（最多10次，最少0次）。

在每一种轮转 + 每一种奇数位累加后 + 每一种偶数位累加后 的可能性组合起来，然后与当前答案取小值。
便可枚举到每一种可能性，并且找出全局字典序最小值。

另外，实际上最外层轮转多少次会陷入循环实际上是可以提前算出，而直接遍历`n`次是相对比较不明智的选择。
这里我优化了一点点，就是将最外层的轮转每次得到的值维护一个哈希集，以避免重复。

更多细节看代码。