## 题目描述
给你一个点数组 points 和一个表示角度的整数 angle ，你的位置是 location ，其中 location = [posx, posy] 且 points[i] = [xi, yi] 都表示 X-Y 平面上的整数坐标。

最开始，你面向东方进行观测。你 不能 进行移动改变位置，但可以通过 自转 调整观测角度。换句话说，posx 和 posy 不能改变。你的视野范围的角度用 angle 表示， 这决定了你观测任意方向时可以多宽。设 d 为你逆时针自转旋转的度数，那么你的视野就是角度范围 [d - angle/2, d + angle/2] 所指示的那片区域。

对于每个点，如果由该点、你的位置以及从你的位置直接向东的方向形成的角度 位于你的视野中 ，那么你就可以看到它。

同一个坐标上可以有多个点。你所在的位置也可能存在一些点，但不管你的怎么旋转，总是可以看到这些点。同时，点不会阻碍你看到其他点。

返回你能看到的点的最大数目。

示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/89a07e9b-00ab-4967-976a-c723b2aa8656.png)
```
输入：points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]
输出：3
解释：阴影区域代表你的视野。在你的视野中，所有的点都清晰可见，尽管 [2,2] 和 [3,3]在同一条直线上，你仍然可以看到 [3,3] 。
```
示例 2：
```
输入：points = [[2,1],[2,2],[3,4],[1,1]], angle = 90, location = [1,1]
输出：4
解释：在你的视野中，所有的点都清晰可见，包括你所在位置的那个点。
```
示例 3：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/5010bfd3-86e6-465f-ac64-e9df941d2e49.png)
```
输入：points = [[1,0],[2,1]], angle = 13, location = [1,1]
输出：1
解释：如图所示，你只能看到两点之一。
```

提示：
```
1 <= points.length <= 105
points[i].length == 2
location.length == 2
0 <= angle < 360
0 <= posx, posy, xi, yi <= 100
```

### 解法 极坐标转换 滑窗
这道题挺有意思的。
题意不难懂，给出一些平面上的点。再给出你当前的位置和一个视角大小，问在当前位置，当前视角大小的情况下，转一周最多能有多少个平面上的点能够进入你的视野。
恰好处于视角边上的点，以及和当前位置相同的点都算入可见的点。

这道题，首当其冲要解决的一个问题就是，给定一个视野后如何判断某个点是否在视野内。
这个问题如果在笛卡尔坐标系下可能有些难搞，但是转换一个角度，用极坐标就会简单不少了。

因为视野的深度没有限制，所以在极坐标系下，针对当前位置location，特定点point的相对极角可以通过arctan求得。设其为`d_p`。
给定一个视角的起始角度`d`，那么只要`d <= d_p <= d+angle`，这个点point就可见。
因为起始角度`d`并没有给出，而定义域又是连续的，所以这里我们只能遍历每个平面上的点，将其极角作为起始角度做尝试。

换言之，求出points中所有点`p_i`的极角`d_i`，并按照升序排序。接着遍历每个`d_i`，查找这个升序数组内有多少点在`[d_i, d_i + angle]`范围内即可。
后者其实就可以通过一个`O(nlogn)`的二分，或者`O(n)`的滑窗来做。

大体思路框架有了，接下来稍微补充一些细节。

第一，是arctan的用法。
数学上的arctan函数，定义域是R而值域是`[-pi/2, pi/2]`。这里面一个比较麻烦的问题就是数学上的arctan函数，在我们这个场景下，
无法分辨第一、三象限的点以及第二、四象限的点之间的区别。因为输入是一个实数值，而导致这个输入值是正还是负的具体的"源头"是不知道的，被一次除法给掩盖了。
比如`arctan(1)`其输出值是`pi / 4`，然而在我们场景下，若location是原点，那么点`[1,1]`和`[-1,-1]`都符合这个要求。无法给出一个确定的极角。

基于arctan函数做一些正负的讨论当然可以解决这个问题，不过大多数语言的math库都提供了类似于`arctan2`这样的函数。
这个函数输入就不是一个简单的实数值，而是具体的y和x的差值。相当于就帮你讨论完了。
用法大概如下：
```python
atan2(point[1] - location[1], point[0] - location[0])
```
这里，函数的输出值域是`[-pi, pi]`。相当于覆盖了整个平面了。

第二，要注意角度的周期性。
比如通过上述处理我可能得到了三个点的极角的升序数组是`[d1, d2, d3]`。
以`d1`为起始角度设置视角似乎没什么毛病，但是以`d3`为起始角度时，其可能跨过原点再次扫到`p1`和`p2`这两个点。然而在这样一个长度为3的数组里，是得不到这个结果的。
为了适应这种角度的周期性，我们干脆可以将数组扩充为
```python
[d1, d2, d3, d1 + 2*pi, d2 + 2*ip, d3 + 2*pi]
```
这样可以保证不漏掉任何一种可能。当然因为扫描最多扫过一圈就完事了，所以扩充这些加上2PI的就行了，没必要扩充更后面的周期。

第三，location出现在points中的处理。
若输入`atan2(0, 0)`，即目标点和当前位置重合的情况，是输出0.0的。但是实际上根据题意，此时无论如何目标点都可见，因此可以再预处理一波，
将重合的数目统计出来，最后加上即可。

注意以上三点，最后再加一个滑窗进行一波探索，得到扩充升序极角数组中两端差值不超过angle的最大长度，就是答案了。