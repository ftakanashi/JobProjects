## 题目描述
给你一个整数 n ，以二进制字符串的形式返回该整数的 负二进制（base -2）表示。

注意，除非字符串就是 "0"，否则返回的字符串中不能含有前导零。

示例 1：
```
输入：n = 2
输出："110"
解释：(-2)2 + (-2)1 = 2
```
示例 2：
```
输入：n = 3
输出："111"
解释：(-2)2 + (-2)1 + (-2)0 = 3
```
示例 3：
```
输入：n = 4
输出："100"
解释：(-2)2 = 4
```

提示：
```
0 <= n <= 109
```

### 解法 数学
题目里的所有`^`符号好像都被吞了…

传统的求正数进制的方法在这里仍然适用。
也就是说，针对一个数字`n`，只要不断地除以 -2 然后取余即可。

当然由于除以-2会涉及到符号的变化，取余比较麻烦。（Python中直接使用`%`对负数取余的逻辑似乎也不是这样的）
这里建议还是以2作为基底取余，再除以-2。

具体来说，比如数字6，首先对2取余余数是0。
然后除以-2，得到-3。
继续，-3对2取余，余数是1，此时应当先减去余数再除以-2。
先得到-4，除以-2后得到2。

以此类推，然后将每一步的余数倒序排序，得到的就是最终的-2进制的表示了。

#### 2024/04/28 update
以上是直觉以及试错后发现对于负进制而言，这套方法也是通用的。
至于为什么可以这么做，今天思考了下，是和进制的底层息息相关的。

对于一个基底 `n`，不论其是正还是负，用`n`进制表示数字时就是：
```
num = x_{k} * n^k + x_{k-1} * n^{k-1} + ... + x_{0} * n^0
n进制下，num表示为 (x_{k} x_{k-1} ... x_{0})(n)
```

而上述取余+除法的操作，对应到上面这个式子中，本质上就是将最后的一项逐渐剔除的过程。
可以发现，上述过程并不涉及到`n`正负性的讨论，因此是通用的。

只是对于负数而言，上述过程中 `num` 的变化不是单向递减的，而是有可能反复横跳的。