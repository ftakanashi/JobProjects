## 题目描述
给你两个整数 left 和 right ，表示区间 [left, right] ，返回此区间内所有数字 按位与 的结果（包含 left 、right 端点）。

示例 1：
```
输入：left = 5, right = 7
输出：4
```
示例 2：
```
输入：left = 0, right = 0
输出：0
```
示例 3：
```
输入：left = 1, right = 2147483647
输出：0
```

提示：
```
0 <= left <= right <= 2^31 - 1
```

### 解法1 基于gap的思考
第一次看到这题，我的思路是这样的。
多个数的与运算，一个显著特征是，在某个位上，只要有一个数的值是0，
那么其最终与运算的结果就是0。

而题目的输入又是一个连续的范围，于是简单写了一下之后发现，
若定义最低位是第0位，那么第`n`位在连续范围递增过程中呈现出`2**n`的周期性。

即，第`n`位从0开始增长的过程中，是连续`2**n`个0，接着`2**n`个1，接着又是`2**n`个0…

这也就意味着，当给出`left`和`right`之后，就知道他们之间的区间跨度（gap）是多大的。
而对于那些`2**n + 1 <= gap`的第`n`位，最终结果中这些位都是0，因为必然有跨越一片连续的0或1，从而带来至少一个0。

而对于那些更高的位，存在两种可能。
第一，整个区间刚好落在一片连续的0或者连续的1中间。此时只有后者有可能让最终结果的这个位是1。
第二，整个区间刚好横跨了一片连续0和一片连续1，此时最终结果该位是0。

总的来看，我们只要考察`left`和`right`的该位置是否都是1。只有都是1的情况，才有可能满足第一种可能的后半种情况。
否则都是0。

按照上述思路，两步走。
第一步，先过滤掉一些必然是0的低位；
第二部，扫描高位并考察`left`和`right`的相关位置的情况。
最终就可以拼出一个最终答案了。

### 解法2 Brian Kernighan算法
所谓的Brian Kernighan算法，就是很久以前就知道的，
将`n & (n-1)`可以去除`n`的二进制表示中最靠右的1的套路。
比如在`LC.191`中就使用过这种套路。

彼时只是将这种算法用于统计二进制位中1的个数。
实际上，这种算法的另一种广泛应用，就是求两个数之间的共同二进制前缀。

比如有两个数`m`和`n`，且`m < n`。此时，按如下操作：
```python
while m < n:
    n = n & (n-1)
```
循环结束时的`n`的值，就是`m`和`n`的共同前缀。
（此时`n`是一个类似于`xxx00...00`这样一个值。不必考虑右边的一片0，只要考虑xxxx部分即可。xxx部分是所谓的共同前缀。

而这道题，区间的连续与运算的结果，实际上就是求了一个共同前缀。
当给出`left`和`right`，假设其共同前缀长度为`x`，那么在低的`32-x`位上，每一个位在连续区间中必然有一个0。
这个可以反证，如果都是1，那么这个位就应当连同所有更高的位一起进入共同前缀了。
（这点说话很难说清楚，若想研究建议纸上写一写思考一下

因此，只需要简单地应用上面的求共同前缀的算法，将right最右的1不断消除，就可以得到结果了。