## 题目描述
假设有一个同时存储文件和目录的文件系统。下图展示了文件系统的一个示例：



这里将 dir 作为根目录中的唯一目录。dir 包含两个子目录 subdir1 和 subdir2 。subdir1 包含文件 file1.ext 和子目录 subsubdir1；subdir2 包含子目录 subsubdir2，该子目录下包含文件 file2.ext 。

在文本格式中，如下所示(⟶表示制表符)：
```
dir
⟶ subdir1
⟶ ⟶ file1.ext
⟶ ⟶ subsubdir1
⟶ subdir2
⟶ ⟶ subsubdir2
⟶ ⟶ ⟶ file2.ext
```
如果是代码表示，上面的文件系统可以写为 "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext" 。'\n' 和 '\t' 分别是换行符和制表符。

文件系统中的每个文件和文件夹都有一个唯一的 绝对路径 ，即必须打开才能到达文件/目录所在位置的目录顺序，所有路径用 '/' 连接。上面例子中，指向 file2.ext 的绝对路径是 "dir/subdir2/subsubdir2/file2.ext" 。每个目录名由字母、数字和/或空格组成，每个文件名遵循 name.extension 的格式，其中名称和扩展名由字母、数字和/或空格组成。

给定一个以上述格式表示文件系统的字符串 input ，返回文件系统中 指向文件的最长绝对路径 的长度。 如果系统中没有文件，返回 0。

示例 1：
```
输入：input = "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext"
输出：20
解释：只有一个文件，绝对路径为 "dir/subdir2/file.ext" ，路径长度 20
```
示例 2：

![](https://assets.leetcode.com/uploads/2020/08/28/dir2.jpg)
```
输入：input = "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"
输出：32
解释：存在两个文件：
"dir/subdir1/file1.ext" ，路径长度 21
"dir/subdir2/subsubdir2/file2.ext" ，路径长度 32
返回 32 ，因为这是最长的路径
```
示例 3：
```
输入：input = "a"
输出：0
解释：不存在任何文件
```
示例 4：
```
输入：input = "file1.txt\nfile2.txt\nlongfile.txt"
输出：12
解释：根目录下有 3 个文件。
因为根目录中任何东西的绝对路径只是名称本身，所以答案是 "longfile.txt" ，路径长度为 12
```

提示：
```
1 <= input.length <= 10^4
input 可能包含小写或大写的英文字母，一个换行符 '\n'，一个制表符 '\t'，一个点 '.'，一个空格 ' '，和数字。
```

### 题意解析
题干一大堆文字，看着就烦…
简化一下。这题的要点如下。

题目给出一个字符串，其中带有`\n`和`\t`，用于表示一个目录结构，如上面的文本格式的形式。
这个目录结构中，有子目录也有子文件。这题限制了文件必须有后缀名。而目录没有。
此外，所有目录、文件名都由字母、数字、空格，当然为了后缀名还有`.`组成。

而在这样一个目录结构中每个文件都会有一个绝对路径。
这题要求输出的，就是所有文件的绝对路径的最长长度（指文本的最长长度而非目录节点的深度）

### 解法 栈
朴素的想法，这题分两步走。
第一步如何将输入字符串解析成一个目录结构。
第二步，构建出目录结构之后找出所谓的最长绝对路径。
这样做固然可以，而这题其实有更简单的办法。

分析输入字符串可以看到，其实`\n`是一个很重要的分割符。
每个`\n`结尾的部分，其实都对应着一个文件或者目录，不论其层级的高低。

另一方面，上述这样每个单元内部，开头的`\t`的个数其实就表示了层级的高低。
比如对于一级子目录和文件，前面有一个，二级则两个，依次类推。

要找到题目要求的最大路径长度，很显然需要遍历到每个文件的绝对路径。而如果针对每个文件都单独发起一次遍历，
上层的大多数目录都会被重复扫描。
为了解决这个重复操作，我们可以借用栈。

具体的，以示例2为例。
我们现在栈中加入dir，再加入subdir1，再加入file1.ext，此时便可以计算file1.ext这个文件的绝对路径长度。
接着，我们pop出file1.ext，再加入subsubdir1，进一步进行探索。

显然，为什么只pop到file1.ext为止，因为当前新扫描到的subsubdir1，其层级是和file1.ext同级别的。

换言之，我们的算法中，面对新扫描到的一个目录/文件，可以先分析出其层级（即开头有几个`\t`），
再将栈pop，直到当前栈顶的目录，其层级比当前这个新玩意层级高一级。
而事实上，由于stack每个时刻都维护着一个合法路径，因此层级直接和栈长度相关。所以可以利用栈长度的变化作为pop的依据。

仔细思考一番后发现，这符合直觉，而且几乎没有什么需要特别处理的细节，很完美。