## 题目描述
在 NBA 季后赛中，我们总是安排较强的队伍对战较弱的队伍，例如用排名第 1 的队伍和第 n 的队伍对决，这是一个可以让比赛更加有趣的好策略。现在，给你 n 支队伍，你需要以字符串格式输出它们的 最终 比赛配对。

n 支队伍按从 1 到 n 的正整数格式给出，分别代表它们的初始排名（排名 1 最强，排名 n 最弱）。我们用括号（'(', ')'）和逗号（','）来表示匹配对——括号（'(', ')'）表示匹配，逗号（','）来用于分割。 在每一轮的匹配过程中，你都需要遵循将强队与弱队配对的原则。

示例 1：
```
输入: 2
输出: (1,2)
解析: 
初始地，我们有队1和队2两支队伍，按照1，2排列。
因此 用 '(', ')' 和 ','来将队1和队2进行配对，得到最终答案。
```
示例 2：
```
输入: 4
输出: ((1,4),(2,3))
解析: 
在第一轮，我们将队伍1和4配对，2和3配对，以满足将强队和弱队搭配的效果。得到(1,4),(2,3).
在第二轮，(1,4) 和 (2,3) 的赢家需要进行比赛以确定最终赢家，因此需要再在外面加一层括号。
于是最终答案是((1,4),(2,3))。
```
示例 3：
```
输入: 8
输出: (((1,8),(4,5)),((2,7),(3,6)))
解析: 
第一轮: (1,8),(2,7),(3,6),(4,5)
第二轮: ((1,8),(4,5)),((2,7),(3,6))
第三轮 (((1,8),(4,5)),((2,7),(3,6)))
由于第三轮会决出最终胜者，故输出答案为(((1,8),(4,5)),((2,7),(3,6)))。
```

注意:
```
n 的范围是 [2, 2^12].
保证 n 可以写成 2^k 的形式，其中 k 是正整数。
```

### 解法 模拟
注意示例2和3。括号套了好几层。比如示例3，整个输出其实是组织成如下形式:
```text
(
    (
        (1, 8),    -> 1和8的胜者
        (4, 5)     -> 4和5的胜者
    ),    -> 1,8中胜者和4,5中胜者再打一轮，得到晋级决赛的胜者
    (    -> 同理
        (2, 7),
        (3, 6)
    )
)
```
也就是说一对括号表示一轮比赛，会有一个胜者，而胜者可迭代地晋级和同样晋级的其他对手继续打一轮。以此类推。

其实仔细依次思考一下示例1，2，3都是怎么来的，基本上就能撸出算法了。

对于第一轮比赛，显然需要将`1`和`n`，`2`和`n-1`，… 这些配对。
这些配对后，可以得到一个新的数组：`["(1,n)", "(2,n-1)", "(3,n-2)", ...]`
而基于这个数组，可以再做一次上述逻辑，即第一个和最后一个配对，第二个和倒数第二个配对…

可以看出，这种迭代过程中，只要时刻维护一个数组，以字符串的形式保存每轮比赛的胜者，为胜者前后加上括号。
随着迭代的进行，数组长度越来越小，而单项字符串的长度越来越大，
最终数组长度为1，而其中的那个字符串就是要求的答案。

借助Python的f-string，上述字符串操作也不困难了。