## 题目描述
在由 2D 网格表示的校园里有 n 位工人（worker）和 m 辆自行车（bike），n <= m。所有工人和自行车的位置都用网格上的 2D 坐标表示。

我们为每一位工人分配一辆专属自行车，使每个工人与其分配到的自行车之间的曼哈顿距离最小化。

p1 和 p2 之间的曼哈顿距离为 `Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|`。

返回每个工人与分配到的自行车之间的曼哈顿距离的最小可能总和。

示例 1：
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/06/01/1261_example_1_v2.png)
```
输入：workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]]
输出：6
解释：
自行车 0 分配给工人 0，自行车 1 分配给工人 1 。分配得到的曼哈顿距离都是 3, 所以输出为 6 。
```
示例 2：
```
输入：workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]]
输出：4
解释：
先将自行车 0 分配给工人 0，再将自行车 1 分配给工人 1（或工人 2），自行车 2 给工人 2（或工人 1）。如此分配使得曼哈顿距离的总和为 4。
```

提示：
```
0 <= workers[i][0], workers[i][1], bikes[i][0], bikes[i][1] < 1000
所有工人和自行车的位置都不相同。
1 <= workers.length <= bikes.length <= 10
```

### 解法1 记忆化DFS
和`LC.1057`不同，这题要求的是总体距离和的最小值。
一开始想尝试用DP，不过没搞出来。看了眼数据最长不过10个，所以用就DFS暴力回溯搜试试。

第一波代码过了大部分case，但是有个case死活过不去。看了好久才意识到，又犯了`LC.1239`的错误。
即DFS使用cache的条件。或者说一般的回溯法框架不能使用cache，因为要考虑 "已经搜索过的状态" 也要作为搜cache的一个键，否则会导致错误结果。

解决的办法很简单，将上述 "已经搜索过的状态" 也放入dfs函数参数里就好了。然而直接放哈希集显然不合适，于是选择用二进制位表示，即
放进一个数就可以了。

以上修改代码后虽然AC，但是效率很低。考虑一下后发现，是因为使用了自顶向下的DFS，使得参数过多导致cache其实并没有发挥太大作用。
再次优化一波代码，总算可以接受了。

#### 关于DFS中的cache的两点思考
第一点，在`LC.1239`中，曾经提到过，回溯法不能随意用cache，其容易导致错误答案。
在这题的背景下解释一下的话，比如定义了dfs函数`dfs(start)`。`start`表示当前正扫描到第`start`个worker。
此时要考虑其获取哪个bike，显然需要`for j in range(m)`遍历，并且遍历过程中应该要有类似`if j in used_bikes: continue`之类的防止选择冲突的机制。

问题就出现在这里。
假设我们有0，1，2三个worker和0，1，2三个bike。当比如我开始`dfs(2)`的搜索的时候，显然，来到这个搜索时前面两个worker的配对情况可能会
是`0-0,1-1`或者`0-1,1-2`或者`0-2,1-0`等等。如果这个dfs使用了cache，显然这些情况是无法在这里得到区分的。
换言之，如上面题解中说的，如果一定要用cache，那么必须把之前扫描过的位置的选择，也体现在参数中。
这个办法就是将哈希集`used_bikes`换成一个`mask`，用二进制位表示bike的使用情况。

第二点，参数过多导致cache效率低的问题。
其实最开始，我习惯性的写了这样的dfs:
```python
dfs(start, total_dist, mask):
    if start == n: return total_dist
    # dfs内部代码
```
这其实是一种自顶向下的dfs策略，dfs函数表示的，是当扫描到`start`位置且扫描过的worker的总距离是`total_dist`时，接下来能够选择得到的最小距离。

由于cache是按照参数列表为键进行缓存，这样做相当于把整个探索空间都装进了缓存，并没有起到加速作用。
这里应该采用自底向上的策略：
```python
def dfs(start, mask):
    if start == n: return 0
    # 内部代码
```
事实上，跳出来想一下，确定扫描到`start`位置后剩余的最小距离，确实只需要知道之前的worker都选了哪些bike。
至于worker和bike之间具体的对应关系，完全没必要知道，是冗余的信息。自底向上就把这部分冗余给去除，从而配合cache大大提升了搜索效率。