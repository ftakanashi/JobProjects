## 题目描述
给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

找到所有在 [1, n] 范围之间没有出现在数组中的数字。

您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

示例:
```
输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]
```

### 解法1 交换法
一旦使用外部空间，那么整个set就可以很简单的解决，就不说了。

在不使用外部空间的前提下，第一个能想到的办法是交换法。
以前也有一道类似的题目，
即在扫描数组的过程中，我们尽可能保证每个数字`n`都位于下标`n-1`的位置。

这样最后扫描一遍，那些数字和下标不匹配的数就是所求了。

这里有一个实现上的小坑，不能写这样：
```python
nums[i], nums[nums[i] - 1] = nums[nums[i] - 1], nums[i]
```
因为这个交换过程是两个赋值过程前后进行，不是同步的。
换言之，应该这样：
```python
a, b = nums[i], nums[nums[i] - 1]
nums[i], nums[nums[i] - 1] = a, b
```

### 解法2 加n法
由于题目限定了所有数字都小于等于n，所以我们可以在确定已经出现的下标位置上+n来表示其已经存在。

具体算法就是扫描数组，对数字`nums[i]`，`nums[nums[i] - 1] += n`。

这样扫完所有位置后，最终再扫一遍，所有还没有大于n的位置对应的下标就是缺失的数字。