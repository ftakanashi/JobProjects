## 题目描述
给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 `(answer[i], answer[j])` 都应当满足：

`answer[i] % answer[j] == 0` ，或`answer[j] % answer[i] == 0`

如果存在多个有效解子集，返回其中任何一个均可。
 

示例 1：
```
输入：nums = [1,2,3]
输出：[1,2]
解释：[1,3] 也会被视为正确答案。
```
示例 2：
```
输入：nums = [1,2,4,8]
输出：[1,2,4,8]
```

提示：
```
1 <= nums.length <= 1000
1 <= nums[i] <= 2 * 109
nums 中的所有整数 互不相同
```

### 审题
这道题看似不难，没想到拖了我这么长时间…

其实审题之后，关键在于要意识到下面这一点才能比较快地做题：
对于一个子集和一个新元素，
如果新元素是子集最大值的整数倍 或者 新元素是子集最小值的约数，
那么，那么这个新元素可以加入以扩充子集。

如果意识不到这一点，算法很容易会向 检查子集中每个元素与新元素是否能整除这个方向想。这样复杂度肯定太高了。

而意识到这一点后，可以先对数组进行预处理排序。比如从小到大排序。
然后从左到右扫描各个数字，逐渐构建答案子集。由于从左到右扫描，新元素总是比当前子集的最大元素大，所以只要看倍数关系即可。

在以上基础上，给出两种解法：

### 解法1 DFS
第一个想到的DFS函数的构造，是接收某个下标位置，以及到当此下标为止找出的子集是什么。

之后从当前下标开始继续往右枚举，如果扫描到某个数是当前子集最大值的整数倍，那么就在此位置开始递归dfs。
扫描完所有右边的数，取这个过程中dfs探索到的最长的子集作为返回。
注意，可能右边所有数都不满足其实当前子集最大值的整数倍，这种情况下直接返回当前子集。

按上述想法写了第一版代码，但是超了内存限制：
```python
class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
        nums.sort()

        @cache
        def dfs(start, path):
            res = path
            for j in range(start, len(nums)):
                if not path or nums[j] % path[-1] == 0:
                    tmp = dfs(j + 1, path + (nums[j], ))
                    if len(tmp) > len(res):
                        res = tmp
            return res
        
        return dfs(0, ())
```
对于一些等比数列的case，每个后面的数都是前面的数的整数倍，这就导致会有`O(n^2)`种path需要记录在cache里。

另一方面，其实当start和path中的最大值决定了之后，这个问题其实是递归寻找所有`nums[start:]`中是`max(path)`的整数倍的数。
其只和path最大值`path[-1]`相关而和之前的值没关系。

换句话说，其实只要确定`start`和`path中最大值`，就可以知道`nums[start:]`中探索得到的最长子集。

这样，就可以自底向上（从右到左）进行DFS而非上面代码的那样自上而下（从左到右）。

具体的，定义dfs函数`dfs(start, resmax)`的返回是："`nums[start:]`中递归寻找得到的最长子集"。用代码描述：
```python
def dfs(start ,resmax):
    res = []
    for j in range(start ,len(nums)):
        if nums[j] % resmax == 0:
            tmp = [nums[j], ] + dfs(j + 1, nums[j])
            if len(tmp) > len(res):
                res = tmp

    return res
```

最后，初始调用的resmax可以设置为1，任何数 % 1都是0所以可以保证第一次循环时可以进入。

### 解法2 DP
如很多DFS的题，都可以用DP解。

关于这题，首先基本思想和审题中说的一样。难点可能在于定义什么作为dp状态。
一般如果是求长度什么的，自然直接设置dp状态为最长子集长度即可。根据审题中提到的思路，很容易确定以下DP规则。

dp数组初始化全是1，表示子集长度至少为1。
之后从`i=1`处开始扫描，状态转移方程如下：
```text
for j in range(i):
    dp[i] = max(dp[j] + 1 if nums[i] % nums[j] == 0)
```
即，来到`i`之后扫描所有比`i`小的`j`，如果`nums[i]`可以被`nums[j]`整除，那么表示`nums[i]`可以填充到以`nums[j]`为最大值的子集中去。
因此最大长度+1。
>因为是对当前之前所有位置的扫描，相当于dp过程有两层循环，这样的话其实和`LC.300`很像

比如输入`1 2 3 6 9`可以得到结果是`1 2 2 3 3`。整个dp数组的最大值`3`就代表了最长的整除子集的长度是3。
只是问题是如何解析出具体的子集是什么。

这样这个问题其实就是从数组中探索一条路径的问题。

注意到路径中任意两个相邻的节点，其dp值一定是`k`和`k+1`。只不过像上面这样的例子中，同样的2和3有四种组合，其中只有两种是对的。而判定对不对则
需要看数字之间的整除关系。

因为诸多路径只要找到一条能通的就行，所以还是可以自底向上。
具体的，从右向左扫描dp值并维护一个剩余需要探索的节点数p。
当`dp[i] == p`且`res[-1] % nums[i] == 0`两个条件同时满足时，收割结果并将`p -= 1`。
当`p`归零后停止搜索。