## 题目描述
给你一个正方形矩阵 mat，请你返回矩阵对角线元素的和。

请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。

示例  1：
```
输入：mat = [[1,2,3],
            [4,5,6],
            [7,8,9]]
输出：25
解释：对角线的和为：1 + 5 + 9 + 3 + 7 = 25
请注意，元素 mat[1][1] = 5 只会被计算一次。
```
示例  2：
```
输入：mat = [[1,1,1,1],
            [1,1,1,1],
            [1,1,1,1],
            [1,1,1,1]]
输出：8
```
示例 3：
```
输入：mat = [[5]]
输出：5
```

提示：
```
n == mat.length == mat[i].length
1 <= n <= 100
1 <= mat[i][j] <= 100
```

### 解法 模拟
题目很简单。之所以这里记录一下，是想表明一个观点，那就是对于这类简单的题目或者说场景，并非第一时间想到的做法就是最优的。

比如这题，读完题就想到了只要遍历一遍所有位置，当`i == j`或者`i + j == n - 1`时表明这个元素处于对角线上，此时可以直接加到累计和中。
但是显然这么做的复杂度是O(n^2)。

一个更优化的做法：
遍历每行，然后收割`mat[i][i]`和`mat[i][n-1-i]`。
这么做会有一个小问题就是当`n`是奇数时必然会像示例1中的那样，把最中间的那个数字重复计算一遍。

所以可以根据n的奇偶性，看是否需要多减去一个多加的数字。
具体的更巧妙的办法是可以乘以`(n & 1)`。

以上这个优化后的做法， 由于只遍历一次所有行，所以复杂度就降低到了O(n)。
看起来似乎没什么大的变化，但是复杂度大大下降了。