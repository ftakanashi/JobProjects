## 题目描述
树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。

给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条无向边。

可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中，具有最小高度的树（即，min(h)）被称为 最小高度树 。

请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。

树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。

示例 1：

![](https://assets.leetcode.com/uploads/2020/09/01/e1.jpg)
```
输入：n = 4, edges = [[1,0],[1,2],[1,3]]
输出：[1]
解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。
```
示例 2：

![](https://assets.leetcode.com/uploads/2020/09/01/e2.jpg)
```
输入：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
输出：[3,4]
```

提示：
```
1 <= n <= 2 * 104
edges.length == n - 1
0 <= ai, bi < n
ai != bi
所有 (ai, bi) 互不相同
给定的输入 保证 是一棵树，并且 不会有重复的边
```

### 解法 模拟 （某种意义上是个特殊的拓扑排序）
这题一看好像不难，一个显而易见的做法是，遍历每个节点，计算将其作为树的根节点时的最大高度。
然后取全局最小高度的那些节点即可。
但是出乎意料的是，上述略暴力的做法居然在这里会超时（通常图的题暴力都能过…

加上昨天肠炎了身体不好，也没细看。今天恢复过来了就来仔细思考一下。

上述暴力做法，无论是BFS还是DFS，都不可避免地重复计算以某个节点为根时一部分子树的高度。
而这个高度还没法用DFS中的cache等机制来避免计算，因为根节点不同，方向不同，具体的子树高度也会不同。

跳出上述思维，从更高的高度来看这道题。
我们发现，所求的节点往往是最靠近整个图的中心位置的节点。这是显而易见的。
举个极端的例子，比如一个链表形状的图，显然能够使得最终树高度最小的根节点是整个链表的中点或者中点附近的两个点。

再仔细思考后我们会发现，因为题目保证给出的结构是无环的，因此最终的答案只可能是一个或者两个节点。

基于上述思考，我们可以想出这样一个算法：
首先我们扫描全图，将所有处于边缘的节点找到并去除。所谓处于边缘，就只需要找到当前图中那些度数为1的节点即可。
再去除掉所有边缘节点后，图里就会出现新一批边缘节点。
我们重复以上操作。

如此，一层层剥皮，不断将边缘节点去除，最终整个图的中心必然会剩下一个或者两个节点，这就是我们要找的最终答案了。

以上算法虽然说起来简单，但是实现的方式是多种多样的。
而且我写了一个基于哈希表的实现后发现clear了几乎所有例子，但是就是有一个例子会超时…
也懒得细究了，于是照抄答案将代码改成现在这个基于数组的实现。
更多解释见注释。