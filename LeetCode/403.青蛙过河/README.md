## 题目描述
一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。

给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。

开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。

如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。

示例 1：
```
输入：stones = [0,1,3,5,6,8,12,17]
输出：true
解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。
```
示例 2：
```
输入：stones = [0,1,2,3,4,8,9,11]
输出：false
解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。
```

提示：
```
2 <= stones.length <= 2000
0 <= stones[i] <= 231 - 1
stones[0] == 0
```

### 解法1 DP
在一番探索之后，我设计了这么一个二维的DP数组：
大小是`m * (n+1)`，其中`m`表示总共的石头个数，`n`表示终点的那个石头的值。数组中保存的都是bool值。

`dp[i][j]`表示下标为`i`的石头能否从之前的某个石头出发，跳了距离`j`到达。

显然，`dp[0][0] = True`，`dp[1][1] = True`。
按照常见的二维DP的推导套路，写出了转移方程如下：
```python
for step in range(1, n+1):
    if stones[i] - step in stones:
        dp[i][step] = (dp[i-1][step-1] or dp[i-1][step] or dp[i-1][step+1])
```
用文字描述一下，就是遍历所有可能的步数，如果恰好当前石头值减去某个步数`step`的那个石头值也在输入中，那么再看到达这个"上一个石头"时的步数，
其减一或本身或加一是否等于`step`，如果这个条件也满足，那么就说明当前石头可以通过上述方案到达。

方案有了，但是总感觉怪怪的。
跑了一下，果然超时。还超空间。
比如如果输入是`0 1 2**31-1`，虽然输入就3个值，但是DP数组长度特别特别长了，再加上要遍历所有可能的步数，超时超空间也不意外了。

在这个基础上我又做了很多优化，比如实时维护当前所能到达的最远距离，用哈希表而非数组来实现DP等。都不太好用且怪怪的…

看了一眼答案恍然大悟。
为什么要纠结于"遍历步数"呢？其实完全可以遍历石头啊。可能是被二维DP数组一定要固定一行遍历列的思维定式迷惑了。

简单来说，当我遍历到`stones[i]`的时候，我再循环遍历所有之前的石头`j in range(1, i)`。
这么一来，只要看转移方程就变成了:
```python
for j in range(1, i):
    diff = stones[i] - stones[j]
    dp[i][diff] = dp[i-1][diff-1] or dp[i-1][diff] or dp[i-1][diff+1]
```
然而上述方法还是没能避开很长的DP数组，这时就用到了刚才用过的优化，用哈希集而不是数组来实现bool值的DP数组。
因为原DP数组中可能会出现很多很多没用的False，把这部分空间可以省下来。

具体的，我们为每个石头初始化一个`set()`，用于保存到达其时，跳过的可能的路径。
初始情况下：
```python
dp[0].add(0)
dp[1].add(1)
```
接下来：
```python
for j in range(1, i):
    diff = stones[i] - stones[j]
    if diff - 1 in dp[j] or diff in dp[j] or diff + 1 in dp[j]:
        dp[i].add(diff)
```
就可以了。

最后只要检查最终位置的dp哈希集是否为空，就知道能否到达终点。

### 解法2 记忆化DFS
这道题标"困难"，所以虽然看着很能用DFS做，但是我头铁直接想DP做法了……

其实做完DP之后，回头撸了一个记忆化DFS，发现简单的一批…

dfs函数的参数当然是起始位置和达到这个起始位置时跳过的距离。
其他几乎没什么可说的了，为了知道某个点是否在数组中，可能实现用一个哈希表保存下石头值和下标的对应关系更方便。