## 题目描述
给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。

请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。

返回分配方案中尽可能 最小 的 最大工作时间 。
 

示例 1：
```
输入：jobs = [3,2,3], k = 3
输出：3
解释：给每位工人分配一项工作，最大工作时间是 3 。
```
示例 2：
```
输入：jobs = [1,2,4,7,8], k = 2
输出：11
解释：按下述方式分配工作：
1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11）
2 号工人：4、7（工作时间 = 4 + 7 = 11）
最大工作时间是 11 。
```

提示：
```
1 <= k <= jobs.length <= 12
1 <= jobs[i] <= 107
```

### 审题
此题看似不复杂，但是需要比较多的优化的工夫。

抽象一下题目的意思，就是将输入数组分成k个子集，使得各个子集的和的最大值最小。
此题一看就觉得可以用DFS和DP两种办法来做。
但是两种办法也都不简单。实际上，两种办法如果都还是使用最简单朴素的思路去做的话都会超时。

下面来详细说一下。

### 解法1 二分查找 + DFS剪枝
最初的朴素DFS想法是这样的：
初始化一个`times`数组，用于保存每个工人的总的工作时间。
这样，dfs函数只需要逐个扫描工作，将其加到某个工人头上，扫描完成后，记录当前工作时长最长的工人的工作时长。
找到这些记录中的最小值即可。

这个想法对应的代码也还留在LeetCode的记录里了。
后来还试图采用不同的数据结构、使用记忆化等办法看能不能解决超时的问题，但是都失败了。

无奈之下看了答案，才发现原来虽然用DFS，但是根本性思路就错了。

答案是这样的：
从输入数组中凑各种分配方案，收割方案中的最大值，并且比较获得这些最大值中的最小值，是一种top-down的方式。在这题里，由于工人无顺序等等原因，
很难做。
正确的做法，是换一个视角。
就像`LC.1011`那样，当工人数量大于等于工作数量时，要求的值必然是`max(jobs)`；
当工人数量等于1时，要求的值必然是`sum(jobs)`。
其余情况，要求的值介于这两者之间。因此，从大框架来说，可以用二分查找来找到符合要求的值。

具体的，缩小二分查找范围的条件`f(mid)`，应该定义为：
在最大工作量为`mid`的情况下，能否找到一种分配方案，使得把`jobs`分配给`k`个工人后可以做到每个工人的工作量都不超过`mid`。

大框架有了之后，接下来就要考虑如何实现`f(limit)`这个函数了。
此时就可以应用DFS了。

思路和朴素方法的差不多，在dfs的过程中，时刻维护当前情况下每个工人的工作量的情况。
只不过此时，多了`limit`这个限制之后，每当`times[i] + job > limit`时，这样的情况都无需探索，直接放弃这种情况的所有子情况，直接下一步探索即可。
相比于最朴素的全空间DFS，这也算一种剪枝。
代码如下：
```python
def check(jobs, k, limit):
    times = [0 for _ in range(k)]
    def dfs(start):
        if start == len(jobs): return True
        job = jobs[start]
        for i in range(k):
            if times[i] + job > limit: continue
            times[i] += job
            if dfs(start + 1): return True
            times[i] -= job

        return False
    
    return dfs(0)
```

若只有上述剪枝，实践证明仍然超时，还需要继续优化。
注意到这样一点：当进行回溯`times[i] -= job`之后，如果此时`times[i]`是0，说明将job分配给第i个人的前提下没有有效的分配方案。
此时按照代码，下一步会保持job之前的那些工作分配方式不变而将job分配给第i+1个人。

但是，这题中所有工人都是同等对待，不存在顺序差别的。所以，即使你将job分配给第i+1个人，然后继续进行探索，这个时候的探索的场景，实际上和将job
分配给第i个人后探索的场景一模一样（你可以想象，第i和第i+1两个人互换位置）。
换言之，在填充times的过程中，不允许非零值出现在零值右边。
因此这里可以多加一条判断，直接`if times[i] == 0: break`。

你可能在纠结，这样的话岂不是`jobs[0]`这个工作永远都分给第一个人了么？
但是请注意，不存在"第一个人"这种概念。因为工人是无序的！
这里其实是不妨将第一个工作分给第一个人，因为每个工作总要有一个人来承担的。

以上思路已经可以AC。但是仍然可以继续优化。
继续优化也很简单。看上面的dfs函数，jobs是从左到右按顺序被扫描的。
如果jobs开头是很零碎的工作，而后面又有较大的工作，因为dfs是深度优先，是优先将零碎工作统一安排给一个人的，因此可能会导致一些无必要的计算。
比如`limit=10, k=5`的情况下输入数据`1 1 1 1 1 9 9 9 9 9`。写一下就明白，会有大量计算。
相反，如果是`9 9 9 9 9 1 1 1 1 1`，此时从左到右扫描很快就能得到正确结果是True。
因此，最后这条优化，就是将jobs逆序排序后再传入函数进行计算。
没有这条优化时，平均用时在200ms左右，而添加后用时可以降到50ms左右。

### 解法2 位运算 + DP
>这种解法在LeetCode的Python中无法AC。但是确实是有效的。因此简单记录一下。

说实话，看到这题第一反应是用DP。
但是写写画画了一会儿没找到合适的状态转移方程。然后就看答案了。

正确的做法是这样的，定义一个DP数组，大小为`k * 2**n`。
是的，列并不是每个工作，而是每一种工作的组合方式。
由于DP数组是数组，所以列的标识肯定不能用set之类的数据结构。
由于在组合中任意一个工作只有被选了和没被选两种状态，所以可以用二进制的方式表示。

可以这么做的另一前提也是题目规定了工作数量<=12，因此2**n最大也只有4096，尚处于可以接受的范围之内。

接下来就是DP状态定义和状态转移方程了。
`dp[i][j]`被定义为，分配`j`这些工作给`i+1`个工人时需要的最长时长。显然，`dp[k-1][2**n-1]`是我们要求的把所有工作分配给`k`个工人后需要的工作时长。

状态转移方程稍微有点tricky。
针对位置`i,j`，其实我需要扫描j的每一种两两组合的方式。这两个组合分别是，前`i-1`个人要做的工作和第`i`人要做的工作。
上面这句话比较拗口。举个例子。比如总工作数量是3时，`j=5`，二进制是`101`。此时它可以拆分成如下的两两组合：
```text
000和101
001和100
100和001
101和000
```
上述两两组合分别表示为`x`和`y`，分别分配给当前工人和前`i-1`个工人的话那么状态转移方程就是：
```text
min_time = min( max(dp[i-1][y], dp[0][x]) for x,y in 上述所有组合 )
dp[i][j] = min_time
```
其中`dp[0]`可以视为一个基准数组，他表示只有一个人做某组工作组合时要用的时间。这既是dp数组第一行，也是后续遍历过程中可以使用的基准数组。

接下来唯一的问题可能就是，给出一个二进制表达后如何将其中所有1的组合给遍历出来了。
这个问题的算法是这样的：
```text
x = j
while x > 0:
    y = j - x
    x,y是一种组合
    x = (x-1) & j    # 关键在这句，通过这句可以迭代到所有j中符合上述要求的组合
```

可能讲得不太详细，可以再去看看代码。不过说实话在真实的笔试过程中，不太指望能回想起这种方法。。