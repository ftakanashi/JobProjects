## 题目描述
给定一个非重叠轴对齐矩形的列表 rects，写一个函数 pick 随机均匀地选取矩形覆盖的空间中的整数点。

提示：
```
整数点是具有整数坐标的点。
矩形周边上的点包含在矩形覆盖的空间中。
第 i 个矩形 rects [i] = [x1，y1，x2，y2]，其中 [x1，y1] 是左下角的整数坐标，[x2，y2] 是右上角的整数坐标。
每个矩形的长度和宽度不超过 2000。
1 <= rects.length <= 100
pick 以整数坐标数组 [p_x, p_y] 的形式返回一个点。
pick 最多被调用10000次。
```

示例 1：
```
输入: 
["Solution","pick","pick","pick"]
[[[[1,1,5,5]]],[],[],[]]
输出: 
[null,[4,1],[4,1],[3,3]]
```
示例 2：
```
输入: 
["Solution","pick","pick","pick","pick","pick"]
[[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]]
输出: 
[null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]
```

输入语法的说明：
```
输入是两个列表：调用的子例程及其参数。Solution 的构造函数有一个参数，即矩形数组 rects。pick 没有参数。参数总是用列表包装的，即使没有也是如此。
```

### 解法 前缀和 二分
标题中的非重叠很好的给出了一个提示。
由于不用担心给出输入的各个矩形之间互相重叠，于是一个很自然的想法就是，我可以分两步走。
取样时，第一步先选出我具体在哪个矩形中取点；第二步，去矩形中通过randint之类的方法选出一个点即可。

由于要求是要均匀取点，显然，每个矩形被选择的概率是不同的。朴素的来思考，若矩形的面积大，则其被选中的概率就大。
而有了概率之后如何根据概率分布去选择矩形也是一个小问题。通常可以通过`numpy`中的一个方法去做（忘了具体方法叫啥了

如果不用`numpy`，也可以通过前缀和数组+二分查找的办法来做。
比如四个矩形的概率分布或者说权重依次是1，2，3，4。那么就构建如下前缀和数组
```python
[0, 1, 3, 6, 10]
```
然后随机一个0到10之间的浮点数，看其落在哪个区间。比如随机出`3.1415926`的话，其落在3和6中间，所以取第三个矩形。

实现上述算法后跑了下发现没过。
仔细思考后发现，上面直觉是选择矩形概率和面积相关。
但是实际上因为返回的都是整数点而不是连续的，因此并非面积而是和这个矩形可以提供的整数点数量有关。
一个最简单的例子，`[0, 0, 1, 1]`这个矩形面积是1，但是却可以提供4个符合要求的整数点。
因此将基于面积为权重改成基于矩形包含整数点数量为权重，具体来说就是不是用`w * h`的面积，而是用`(w+1) * (h+1)`，就AC了。