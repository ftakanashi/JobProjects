## 题目描述
给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

示例 1：
```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```
示例 2：
```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```
示例 3：
```
输入：s = ""
输出：0
```

提示：
```
0 <= s.length <= 3 * 104
s[i] 为 '(' 或 ')'
```

### 解法1 栈
看到求连续区间，第一个想到了滑动窗口。
但是仔细想了想感觉没有什么很明显的，指示两个指针进行滑动的规则。

另一方面，括号匹配的问题，一般都可以用栈，于是用栈试了一下。

一开始想法很单纯，将各个括号按顺序压入栈，如果碰到栈顶是左括号且当前字符时右括号的情况，
直接pop出栈顶然后`res += 2`。
又因为题目要求连续的区间，因此一旦括号不合法了就应该将res置零重新开始计数。

于是就遇到了问题，比如`()(()`这个，前两个没问题，扫到第三个字符时，怎么办？
该判它非法，从而将res置零吗？可如果输入是`()(())`的话，不应该判非法。
换言之，在没扫描到最后一个位置前，我没办法判断当前位置是否非法，从而无法判断是否置零res。

基于这个情况，维护一个随时要置零的量有点麻烦。于是想到能不能模仿某些单调栈的套路，
将下标放到栈里。这样只要通过当前位置和弹出的下标求个差，就知道长度了。

然而这样还是不够的，比如还是`()(())`这个例子，明明答案是6，但因为前后两块括号是分开的，
用以上算法只能侦测到后段更长的4而看不到前面的2也应该计入结果。

于是继续改进算法。减去的不是pop出来的，而是pop出来后栈顶的下标。这样可以做到一口气回溯到当前合法字符串最左端从而得到最大长度。
还有最后一个小问题，如果此时栈空了怎么办，那其实就是回溯到了整个字符串的最左端，只要当前下标+1就是最大长度了。

以`()(())`为例具体说明一下。
栈首先是`0`，而后pop出`0`后因为栈空，更新结果为`1 + 1`即2。
而后入栈两个左括号，即栈是`2 3`。

随后来了一个右括号，因此pop出3，当前坐标是4，因此更新结果是`4 - 2`。这里的2指当前栈顶值。

之后再来一个右括号，此时pop出2，当前坐标是5，栈空，更新结果为`5 + 1`为6。

### 解法2 DP
DP重要的无非就是确定DP数组的含义以及状态转移方程。

DP数组的含义按感觉还是比较好确定的。
肯定是到某个位置为止，最长的有效括号的长度。

需要注意的是，这里是严格包含当前位置的。因此如果当前位置是左括号，那么其DP值应该是0。这也是这题的一个小陷阱。

其次，状态转移方程稍微需要开个脑洞。
上面说了，只需要讨论当前位置是右括号的情况。
可当前位置是右括号的时候又分成两种情况。即查看其前面是左括号还是右括号：

如果`i-1`是左括号，此时比较容易想到，`dp[i] = dp[i-2] + 2`。

如果`i-1`也是右括号，即字符串是类似于`xxxx))`形式的时候，这时候其实得看在前面有一点远的地方，存不存在一个左括号和`s[i]`这个右括号匹配了。
而这个遥远的位置，其实是`i - dp[i-1] - 1`。这个是最妙的一点。如果这个位置是左括号，那么`dp[i] = dp[i-1] + 2`。否则就是0。

嗯？完了吗？其实还没有。上述算法计算的其实还是"非贪婪"的最长有效括号。
例子如`()(())`，最后一个位置如果按照上述状态转移去计算，得到的值是4而不是6。
因此其实上述`i`是右括号、`i-1`也是右括号，`i - dp[i-1] -1`是左括号的这个分支情况，
其状态转移方程应该是`dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]`。

最后，需要注意上述所有dp用到的下标都应该大于等于0，否则就不要加啦。