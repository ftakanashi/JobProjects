## 题目描述
一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。

骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。

有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。

为了尽快到达公主，骑士决定每次只向右或向下移动一步。

编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。
```
例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。

-2 	-3	3
-5	-10	1
10	30	-5
```

说明:
- 骑士的健康点数没有上限。
- 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。

### 解法 DP
一看就知道肯定要DP。
一开始我自然考虑DP数组定义为`dp[i][j]`表示从起点位置开始走到`i,j`位置需要的最少的血量。
于是状态转移方程就定义为左边和上面dp值中小的加上本格子需要扣除的血量：
```python
dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + abs(dungeon[i][j])
```
如果地图中没有魔法球，或者说将所有大于0的格子全都置零的话，上述算法是可行的，这就是个很简单的DP问题。

但是，有了魔法球可以补血之后，情况就复杂了。
比如到达某个位置，从左边来可以尽可能保持必要血量一直很低，从上边来虽然必要血量高一点，但是图中可以吃到很多魔法球从而使得到达时血量很高，方便
之后的探索。

以上两种情况，都有可能是对后续探索更有利的，而没有明确的条件可以筛掉其中一种。
>上述思考可以参考题解(https://leetcode-cn.com/problems/dungeon-game/solution/di-xia-cheng-you-xi-by-leetcode-solution/)以及其中的图
>
>![](https://assets.leetcode-cn.com/solution-static/174/174_fig2.png)

于是做不出来了 看答案……

原来，正向推很难获得明确的规则的时候，可以反向推。
dp状态定义修改为`dp[i][j]`表示从`i,j`位置走到终点需要的最少的血量。从终点向起点反推，最终返回`dp[0][0]`即可。

具体的，状态转方呢？
显然，终点如果值是负数，那么dp值就是其绝对值加1；如果是正数，则只要到达终点时还有一颗血就没问题，因此dp值是1，即：
```python
dp[m-1][n-1] = max(1 - dungeon[m-1][n-1], 1)
```
然后从后往前推的过程中，对于任意一个格子，其右或者下格有一个能走到终点即可，为了让必要血量最小，自然应该选择下一步需要血量小的格子。
同时，本格至少需要的血量减去本格的损耗之后才是下一格至少需要的血量，因此还要计入本格的损耗。
```python
dp[i][j] = min(dp[i][j+1], dp[i+1][j]) - dungeon[i][j]
```
别忘了本格可能是正数，此时减去损耗之后变负数。
意义是走到本格时即使血是负数也没问题。当然因为题目定义中明确血数非负，所以这里还需要取和1的大值，即
```python
dp[i][j] = max(min(dp[i][j+1], dp[i+1][j]) - dungeon[i][j], 1)
```
意义是，即使走到本格最少最少也得有1颗血。只要你有1颗，本格的魔法球还可以给你续一会儿。

上式也就是转方的最终形态。
可以说这题换个视角之后，就简单的一批了。