## 题目描述
沿街有一排连续的房屋。每间房屋内都藏有一定的现金。现在有一位小偷计划从这些房屋中窃取现金。

由于相邻的房屋装有相互连通的防盗系统，所以小偷 不会窃取相邻的房屋 。

小偷的 窃取能力 定义为他在窃取过程中能从单间房屋中窃取的 最大金额 。

给你一个整数数组 nums 表示每间房屋存放的现金金额。形式上，从左起第 i 间房屋中放有 nums[i] 美元。

另给你一个整数 k ，表示窃贼将会窃取的 最少 房屋数。小偷总能窃取至少 k 间房屋。

返回小偷的 最小 窃取能力。

示例 1：
```
输入：nums = [2,3,5,9], k = 2
输出：5
解释：
小偷窃取至少 2 间房屋，共有 3 种方式：
- 窃取下标 0 和 2 处的房屋，窃取能力为 max(nums[0], nums[2]) = 5 。
- 窃取下标 0 和 3 处的房屋，窃取能力为 max(nums[0], nums[3]) = 9 。
- 窃取下标 1 和 3 处的房屋，窃取能力为 max(nums[1], nums[3]) = 9 。
因此，返回 min(5, 9, 9) = 5 。
```
示例 2：
```
输入：nums = [2,7,9,3,1], k = 2
输出：2
解释：共有 7 种窃取方式。窃取能力最小的情况所对应的方式是窃取下标 0 和 4 处的房屋。返回 max(nums[0], nums[4]) = 2 。
```

提示：
```
1 <= nums.length <= 105
1 <= nums[i] <= 109
1 <= k <= (nums.length + 1)/2
```

### 解法 threshold 二分 贪心
打家劫舍系列的做法基本都是DP。不过这题倒是不太一样。

首先是题意有点绕。其实意思是，在不偷两家相邻的屋子的前提下，偷`k`个屋子。
这显然有很多种方案，每一种方案中都会有一个单次从屋子里偷得数量的最大值。
现在要求的是，所有方案中，这个最大值的最小值。

显然，两个不同方案是互相独立的。所以并不太适用DP。
而既然用threshold二分，关键就在于规定一个需要通过二分查找来逼近的值，以及check函数。

我们直接抄答案…：
我们可以二分逼近单屋可以偷到的最大值，显然这个值在`min(nums)`和`max(nums)`之间。
对于某个特定的值`t`，我们可以用check函数检查这个值的情况下，能否偷够`k`个屋子。

具体逻辑是，规定了`t`之后，遍历所有`nums`，并维护一个变量`prev`表示当前位置的左边相邻位置是否有偷。
只要`prev` 是 `False` 且 当前屋子的`num <= t`，出于"尽可能偷更多的屋子以尽快达到偷够`k`个屋子的目标"的贪心原则，我们选择偷当前屋子。
否则不偷并且将`prev`至为`False`。

在外围，我们通过二分查找不断逼近能够满足偷够`k`个屋子的最小的`t`即可。