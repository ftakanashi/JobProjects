## 题目描述
给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

首先找到需要删除的节点；
如果找到了，删除它。

示例 1:

![](https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg)
```
输入：root = [5,3,6,2,4,null,7], key = 3
输出：[5,4,6,2,null,null,7]
解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。
另一个正确答案是 [5,2,6,null,4,null,7]。
```
示例 2:
```
输入: root = [5,3,6,2,4,null,7], key = 0
输出: [5,3,6,2,4,null,7]
解释: 二叉树不包含值为 0 的节点
```
示例 3:
```
输入: root = [], key = 0
输出: []
```

提示:
```
节点数的范围 [0, 104].
-105 <= Node.val <= 105
节点值唯一
root 是合法的二叉搜索树
-105 <= key <= 105
```
```
进阶： 要求算法时间复杂度为 O(h)，h 为树的高度。
```

### 解法 DFS 分类讨论
这题看着不复杂，但实际上按照我的做法分类讨论起来，整体逻辑还是有点麻烦的。

首先应当明确一个事情，就是删除一个BST中的节点的方法有很多。其中一个方案是，面对一个节点，将其右子树最靠左下的节点放到被删除节点位置，

虽然一句话可以概括完，但是实际上里面需要考虑的细节还有很多。
我们构建一个dfs函数`dfs(node)`表示尝试从以node为根节点的树中删除目标值的节点。
显然，当`node.val != key`时，按照BST的规则分别向左或者向右继续dfs即可。

而对于`node.val == key`的情况。则需要仔细讨论。
现讨论如下：

第一，若`node`是一个叶子节点，那么可以将其直接摘除。由于二叉树的单向指针特性， 所以dfs的时候可以带上parent，从而通过parent操作摘除叶子节点。
又因为只知道parent，而不知道node是parent的左子节点还是右子节点也还是不行的，所以我还在dfs函数上加了个L或者R的标识。
用于表示node是parent的哪个节点。

第二，若`node`是一个非叶子节点，但是其没有右子树，此时的操作应该是直接将其左子树接到parent上。

第三，若`node`是一个非叶子节点，且有右子树，但右子树无左子树。
此时实际上需要将`node.right`替换到`node`的位置，并将`node.right.right`放到`node.right`的位置。
注意不能直接用`parent.xx = node.right`，因为这忽略了可能存在的`node.left`。

第四，若`node`是一个非叶子节点且有右子树，且右子树有左子树。
此时才是最一般的情况，需要找到最左下方节点。找到后将其放到被删除节点位置并且将原位置进行调整。
由于这里又涉及到节点的切除，所以这个找最左下方节点的过程还得是双指针的。

以上讨论覆盖到了所有情况，因此就AC了。
再次提醒，只要摘除节点后的树仍是BST，就是合法答案，所以答案不止一种。
我写完代码后有个用例的结果和LC给的结果不一样，看了好长时间…结果发现原来都可以。

最后，为了处理删除的节点就是root本身等情况，可以设置一个dummy连在root上面，这样最后只要返回`dummy.left`，就可以万无一失了。