## 题目描述
给你一个整数数组 nums ，返回其中 按位与三元组 的数目。

按位与三元组 是由下标 (i, j, k) 组成的三元组，并满足下述全部条件：
```
0 <= i < nums.length
0 <= j < nums.length
0 <= k < nums.length
nums[i] & nums[j] & nums[k] == 0 ，其中 & 表示按位与运算符。
```
 
示例 1：
```
输入：nums = [2,1,3]
输出：12
解释：可以选出如下 i, j, k 三元组：
(i=0, j=0, k=1) : 2 & 2 & 1
(i=0, j=1, k=0) : 2 & 1 & 2
(i=0, j=1, k=1) : 2 & 1 & 1
(i=0, j=1, k=2) : 2 & 1 & 3
(i=0, j=2, k=1) : 2 & 3 & 1
(i=1, j=0, k=0) : 1 & 2 & 2
(i=1, j=0, k=1) : 1 & 2 & 1
(i=1, j=0, k=2) : 1 & 2 & 3
(i=1, j=1, k=0) : 1 & 1 & 2
(i=1, j=2, k=0) : 1 & 3 & 2
(i=2, j=0, k=1) : 3 & 2 & 1
(i=2, j=1, k=0) : 3 & 1 & 2
```
示例 2：
```
输入：nums = [0,0,0]
输出：27
```

提示：
```
1 <= nums.length <= 1000
0 <= nums[i] < 2^16
```

### 解法 暴力遍历 + 一点小优化
这题标是hard，所以自己想也没想直接去看了答案，没想到其实用比较暴力的办法是可以过的…

按最朴素的思路，自然就是遍历所有可能的三元组，然后检查每个三元组对应的数字的按位与的和是不是零就行了。
显然这种做法的复杂度是`n^3`，实际也会超时。

但是由于数字给出了范围是小于`2^16`，即数字最多是16位的整数。
这样的话任意两个数字的按位与的结果也都是16位整数内的。

因此，我们可以将一个三重循环改造成两个两重循环。
具体的，我们首先通过遍历所有可能的二元组，然后将二元组的按位与结果的计数值记录下来。由于数字大小范围，这个计数哈希表最大长度也就是`2^16`

然后遍历第三个数，针对每个数，再遍历上一个循环中得到的所有可能的按位与结果。最终答案的计数中加上这个结果对应的计数值即可。

如此，一个`n^3`的复杂度就被简化成了`n^2 + n * 2^16`。
代入一算就知道，当n比较大，比如接近1000的时候，前者比后者大两个数量级，因此后者不会超时。

当然这只是最简单的一种优化思路，只不过可以AC而已。
要更高级的做法可以再去翻翻答案。