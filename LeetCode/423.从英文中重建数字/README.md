## 题目描述
给你一个字符串 s ，其中包含字母顺序打乱的用英文单词表示的若干数字（0-9）。按 升序 返回原始的数字。

示例 1：
```
输入：s = "owoztneoer"
输出："012"
```
示例 2：
```
输入：s = "fviefuro"
输出："45"
```

提示：
```
1 <= s.length <= 105
s[i] 为 ["e","g","f","i","h","o","n","s","r","u","t","w","v","x","z"] 这些字符之一
s 保证是一个符合题目要求的字符串
```

### 解法 哈希表 暴力模拟（优化）
这题真是挺奇怪的…
一开始看到题目，没多想，就直接DFS回溯，以剩余的字母计数数作为线索进行搜索。
然而超时。

于是细看，发现好像并没有那么复杂…
因为题目说了给出的字符串一定是符合要求的字符串，
换言之，字符串肯定刚好能够被解释成一些数字的英文表达，一个字母不多一个字母不少。

既然是这样，那么就很简单了。
我只要维护一个counter，然后依次扫描0-9的每个数字以及它们的英文表达，试图从counter中减去各自字母的英文表达。
每能成功减一轮，就在ans中加上一个相应的数字。
而不能成功的意思就是当前数字的英文表达的某个字母，在counter中的计数小于英文表达中的计数的情况。此时就可以继续遍历下一个数字。

基于上述办法，其实我的做法还稍微优化了一下。

注意到，其实每个数字的英文表达其中都可能有一些特征字母。比如0的zero，就是z。换言之，若counter中有n个z，
那么就意味着最终答案会有n个0。那么反过来推导最终答案的时候，只需要让counter中的z,e,r,o分别-=n即可。
依次类推。

但是有些数字的英文表达，其中字母都很常见，导致无法第一时间得到特征字母。
此时就需要对遍历数字顺序做出调整。优先过滤掉那些有特征字母的数字。在数字被过滤掉的过程中，剩余数字中的那些字母也会变得"有特征"起来。
比如排除了0，2，4之后，字母`o`就可以作为1的特征字母了。

在有安排的遍历顺序下，依次从counter中检查并减去特征字母相关的计数，自然就可以获得最终答案。
我想出来的遍历顺序以及各个数字的特征字母如下(顺序恰好是先偶数再奇数)：
```python
[('z', 0), ('w', 2), ('u', 4), ('x', 6), ('g', 8), 
('o', 1),  ('t', 3), ('f', 5), ('v', 7), ('i', 9)]
```