## 题目描述
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png)

以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png)

图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。

示例:
```
输入: [2,1,5,6,2,3]
输出: 10
```

### 解法 单调栈
直觉上来说，当我以一个柱子为中心并且将其高度作为基准，那么我能获得的最大矩形，应该是以此柱子为中心向两边扫描，
碰到高度小于本柱时停止，左右两边的宽度乘以本柱的高度即可。

注意可能被扫描的柱子全部高于我，那么扫描边界就是数组边界。

基于这样的想法其实可以很快想到暴力。但是显然，暴力法是O(n^2)的，不太好。
于是看了答案，用单调栈来通过O(n)的空间换出O(n)的时间。

具体来说，针对一个柱要确定其左右两个边界，分别是两边第一个比他小的柱子。
以左边为例，我可从左到右扫描，并且将柱子入栈。扫描过程中保持栈的单调递增性质。

即，如果新扫描到一个元素`i`比小于等于栈顶元素`stack[-1]`（注意等于也在里面，因为等于的话线还是可以划过去，矩形可以继续扩展），
那么就不断pop栈，直到`i`比栈顶大。

如此重复操作，从左到右扫描的过程中，自然而然就知道了每个位置左侧第一个比其小的元素位置了。

以上面示例为例：整个栈的变化情况如下：
```text
2
1   (2被pop)
1 5
1 5 6
1 2 (5,6被pop)
1 2 3
```

记得我们要找的不是元素具体值而是其位置，所以栈里可以保存下标而不是值。另外如果栈为空了，那么就找不到`stack[-1]`了，此时也表明对当前柱子来说
，其左侧不存在比其更小的柱子，因此可以置其边界为-1。

这样一通操作下来，可以得到数组`[-1, -1, 1, 2, 1, 4]`，这就是我们要求的，对于每个柱子来说其左边第一个小于他的柱子在什么位置的信息了。

同理，从右向左扫描可以得到`[1, 6, 4, 4, 6, 6]`，这表示每个柱子右边第一个小于他的柱子在哪。注意这里超出边界的值是6，即`len(heights)`。

>以上-1以及6这两个值被称为哨兵值

最后就简单了，依次扫描各个柱子，找到其右边界`r`和左边界`l`，宽度是`(r - 1) - (l + 1) + 1`，高度是`heights[i]`，
两者相乘然后找出所有乘积中最大值即可。

### 解法2 一次性扫描优化
上述方法从左到右和从右到左扫描了两次，其实可以一次扫描就解决。

单调栈的核心还是不变，只是，针对扫描到位置`i`，以及当时栈顶的元素`j = stack[-1]`来说，如果决定要将`j`pop掉，那只有一种可能，那就是`i`
是`j`右边碰到的第一个比`j`小的元素。

换句话说，其实确定右边界的工作，在扫描左边界的时候就可以一并完成。只需要关注pop出来的时候的情况即可。

基于这点，可以避免两次扫描。