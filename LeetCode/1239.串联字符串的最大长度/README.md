## 题目描述
给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。

请返回所有可行解 s 中最长长度。

示例 1：
```
输入：arr = ["un","iq","ue"]
输出：4
解释：所有可能的串联组合是 "","un","iq","ue","uniq" 和 "ique"，最大长度为 4。
```
示例 2：
```
输入：arr = ["cha","r","act","ers"]
输出：6
解释：可能的解答有 "chaers" 和 "acters"。
```
示例 3：
```
输入：arr = ["abcdefghijklmnopqrstuvwxyz"]
输出：26
```

提示：
```
1 <= arr.length <= 16
1 <= arr[i].length <= 26
arr[i] 中只含有小写英文字母
```

### 解法1 DFS + 哈希集
首先审题应该注意到，这题要求的是子序列而不是子数组，因此不能用滑动窗口之类的办法做。

最近DP做的有点多，先用DP尝试了一下，发现并不是很好推。于是转而用DFS。
用DFS时，显然，dfs函数的输入应当是扫描到的当前位置`start`以及当前已经串联得到的部分字符串`string`。

dfs函数内部，针对`for i in range(start, n)`，首先要看`arr[i]`和`string`之间有没有重复字符，如果有说明不能选用`arr[i]`。
若没有，说明两者可以串联起来，因此串联之并进行下一层的探索：`dfs(i+1, string+arr[i])`。

上面的难点在于如何确定`arr[i]`和`string`之间有没有重复的字符。
关于这一点其实有很多办法，这里采用最朴素的一种办法，判断两者的交集是否为空。即`set(arr[i]).intersection(set(string))`。

注意到`set(arr[i])`总是固定的，因此可以再dfs探索前就预处理出来。

最后还需要注意一点，当某个字符串本身已经带有重复字符了，他就永远不能被采用。
这也是可以在前处理中做出的判断。

### 解法2 回溯 + 位运算
写完解法1的代码之后，发现有不少地方可以优化。

因为答案并不要求给出具体的字符串，因此在dfs探索过程中，`string`这个参数并不是很有意义。他唯一的作用，就是作为一个条件，用来判断`arr[i]`能否选用。

而这个工作，完全可以由一个实时维护的counter来做。
即，维护一个counter，对应已经串联出的string的各个字母的计数。
这样，只要`for ch in arr[i]`中每个字符ch都未在counter中出现过，就表示`arr[i]`是可能的对象。

由于是不同层的dfs函数共用一个counter对象，所以这里就需要在dfs函数中有意识的进行回溯了。
大概的函数体如下：
```text
def dfs(start):
    nonlocal counter
    if start == n: return 从counter中计数长度
    ans = counter中计数长度
    for i in range(start, n):
        if i in invalid or arr[i]与counter冲突: continue
        counter.update(arr[i])
        ans = max(ans, dfs(i + 1))
        counter.remove(arr[i])
    return ans
```

在上述代码中我们继续发现，其实counter中的任意一个字母计数都不超过1。换言之只需要判断某个字母是否存在即可。
因为题目说所有字符都是小写字母，结合位运算，甚至都不用counter这种哈希结构，直接安排一个数字c作为标识即可。
用`( c >> (ord(ch) - ord('a')) ) & 1`作为标识。

优化到这里，空间已经优化的不错了。
但是时间上，对于每个`arr[i]`，我还是要挨个检查字符。
从位运算的角度来说，其实这挨个字符操作可以一并做。

具体的，在预处理阶段我们就把每个字符串的二进制形式表示成mask，组成一个masks数组。
之后再dfs函数中，已经串联出的字符串，各个字符存在情况的二进制形式如果是counter的话，那么只需要查看
`counter & masks[i]`是否等于0就知道有没有冲突了。

另一方面，将mask通过或运算就可以维护进counter，而异或运算又可以将mask从counter中去除，对应了上面伪代码中的update和remove操作。

至于answer，只需将counter中1的数量统计出来即可。可以用`bin(counter).count('1')`。

#### 关于dfs中有时不能使用cache
现在写dfs函数，都习惯性的带上cache了。

但是，现在才意识到，回溯法的一般框架是不能带cache的。
以这题这种线性扫描的模式为例。加入我们有`a b c`这个序列。在选用`a`之后，进入第一层dfs。
此时根据线性扫描，我们会进入选了b的第二层dfs:`dfs(b)`
以及
没选b但是选了c的第二层dfs: `dfs(c)`

而在进入后一种分支之前，在前一种分支中，必然会有进入第三层dfs即选了b的前提下又选了c。
虽然此时是第三层，但是表观上，依然是`dfs(c)`。

若定义函数带有cache，此时`dfs(c)`的答案会被保存下来使用。退出前一种分支后，试图运算后一种分支时，会发现cache中有答案于是就直接使用了。
但是那是选了b又选c的情况，与现在不选b选c的情况不同，因此不应该这么做。

另一方面，在解法1中，因为dfs函数的输入除了start还有string。而string本身其实就区别了上述两种情况。
因此加了cache也无伤大雅。

这其实也说明，回溯法如果想要加cache，除了向下一步探索的必要参数外，还需要提供 "已经做了选择的部分处于什么状态" 这个信息。
这部分信息，我总是下意识的使用外部的哈希集或者什么办法来实现，这样的话因为其不处于dfs函数参数列表中，因此不能被cache感知，从而导致错误。