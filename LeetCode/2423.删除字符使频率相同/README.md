## 题目描述
给你一个下标从 0 开始的字符串 word ，字符串只包含小写英文字母。你需要选择 一个 下标并 删除 下标处的字符，使得 word 中剩余每个字母出现 频率 相同。

如果删除一个字母后，word 中剩余所有字母的出现频率都相同，那么返回 true ，否则返回 false 。

注意：

字母 x 的 频率 是这个字母在字符串中出现的次数。
你 必须 恰好删除一个字母，不能一个字母都不删除。

示例 1：
```
输入：word = "abcc"
输出：true
解释：选择下标 3 并删除该字母，word 变成 "abc" 且每个字母出现频率都为 1 。
```
示例 2：
```
输入：word = "aazz"
输出：false
解释：我们必须删除一个字母，所以要么 "a" 的频率变为 1 且 "z" 的频率为 2 ，要么两个字母频率反过来。所以不可能让剩余所有字母出现频率相同。
```

提示：
```
2 <= word.length <= 100
word 只包含小写英文字母。
```

### 解法 模拟
说实话早上第一眼看到这道题，根本就懒得想，因为一眼就觉得是一行代码可以解决的那种。
然后开始做的时候，就很容易想到了先构造Counter，再构造counter的值的Counter，再做一些判断云云。

但是提交了四次，居然全失败了……。注意看除了题目中给出的两个用例，注意下面这些例子：
```text
cba
aca
ddaccb
```

总的来说就是，当尝试用一次性的counter聚合角度来做，会有很多意想不到的边界条件需要控制。

一番折腾之后，决定还是暴力了…
构造字符的counter，然后从左到右扫描word，尝试删除某个字符看删除后能否符合条件。。
注意counter中某个字符的计数即使归零也不会删除这个key，如果是使用values的数字种类作为判断标准的话，还得记得手工pop掉。

暴力模拟的思路简单的一批，就不多说了。