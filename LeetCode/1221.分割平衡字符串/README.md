## 题目描述
在一个 平衡字符串 中，'L' 和 'R' 字符的数量是相同的。

给你一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。

注意：分割得到的每个字符串都必须是平衡字符串。

返回可以通过分割得到的平衡字符串的 最大数量 。

示例 1：
```
输入：s = "RLRRLLRLRL"
输出：4
解释：s 可以分割为 "RL"、"RRLL"、"RL"、"RL" ，每个子字符串中都包含相同数量的 'L' 和 'R' 。
```
示例 2：
```
输入：s = "RLLLLRRRLR"
输出：3
解释：s 可以分割为 "RL"、"LLLRRR"、"LR" ，每个子字符串中都包含相同数量的 'L' 和 'R' 。
```
示例 3：
```
输入：s = "LLLLRRRR"
输出：1
解释：s 只能保持原样 "LLLLRRRR".
```
示例 4：
```
输入：s = "RLRRRLLRLL"
输出：2
解释：s 可以分割为 "RL"、"RRRLLRLL" ，每个子字符串中都包含相同数量的 'L' 和 'R' 。
```

提示：
```
1 <= s.length <= 1000
s[i] = 'L' 或 'R'
s 是一个 平衡 字符串
```

### 解法 贪心 计数
一开始看到这题还以为要用DFS或者DP之类稍微复杂一些的解法。
但是仔细一想其实很简单。

因为题目保证了s本身整体就是一个平衡字符串，所以答案至少是1，并且排除了很多难处理的因素。
另一方面，因为需要尽可能多地分割字符串，所以一个很明显的贪心思想就是，每扫描过相同数量的L和R，就立即分割一次。

换言之，最理想的情况应该是类似于`LRRLRLLR...`这样的情况。即L总和R相邻，这样每两个字符就可以分割一次，于是就可以得到尽可能多的分段。

再看一下几个示例，大概就能想到了，其实可以借鉴判断括号合法性`LC.32`的做法，扫描字符串，并且维护一个计数。
扫描到L时计数加1，扫描到R时计数减1，每当计数归零时就可以进行一次分割。最终返回分割总数即可。