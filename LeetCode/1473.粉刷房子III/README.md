## 题目描述
在一个小城市里，有 m 个房子排成一排，你需要给每个房子涂上 n 种颜色之一（颜色编号为 1 到 n ）。
有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。

我们将连续相同颜色尽可能多的房子称为一个街区。
（比方说 houses = [1,2,2,3,3,2,1,1] ，它包含 5 个街区  [{1}, {2,2}, {3,3}, {2}, {1,1}] 。）

给你一个数组 houses ，一个 m * n 的矩阵 cost 和一个整数 target ，其中：
```
houses[i]：是第 i 个房子的颜色，0 表示这个房子还没有被涂色。
cost[i][j]：是将第 i 个房子涂成颜色 j+1 的花费。
```
请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 target 个街区。如果没有可用的涂色方案，请返回 -1 。

示例 1：
```
输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
输出：9
解释：房子涂色方案为 [1,2,2,1,1]
此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。
涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。
```
示例 2：
```
输入：houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
输出：11
解释：有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2]
此方案包含 target = 3 个街区，分别是 [{2,2}, {1}, {2,2}]。
给第一个和最后一个房子涂色的花费为 (10 + 1) = 11。
```
示例 3：
```
输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5
输出：5
```
示例 4：
```
输入：houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3
输出：-1
解释：房子已经被涂色并组成了 4 个街区，分别是 [{3},{1},{2},{3}] ，无法形成 target = 3 个街区。
```

提示：
```
m == houses.length == cost.length
n == cost[i].length
1 <= m <= 100
1 <= n <= 20
1 <= target <= m
0 <= houses[i] <= n
1 <= cost[i][j] <= 10^4
```

### 审题
此题是`LC.265`的进阶。
题目信息比较多，先来捋一捋。

首先，主体数据结构是一个数组`houses`，每个数字都是0-n中的一个。非零数字代表一个颜色，而0代表空白的房子。

题目要求是让你选择这个数组中一定数量的空白房子进行粉刷，换言之，将0换成1-n中的某个数字。
注意这个过程中具有cost，cost以`m * n`矩阵的形式给出，表明第m个房子将其粉刷成n色需要的成本。

需要注意的是，题目中提到，已经有颜色的房子不用再粉刷。其实我觉得这里应该改成"不能"更加合理。
换言之，cost矩阵中有一些行(which初始颜色非零)是无用的信息。

粉刷完成后，要求数组按"街区"分片后数量是要求的target值。

### 解法1 DP（三维DP数组）
这题一看就知道肯定用DP，关键在于DP数组的定义和状态方程了。

最开始，我构思的DP数组是以房子为行，以粉刷后房子的颜色为列，做一个`m * n`的DP状态。
同时为了考虑街区数，我将街区数也作为DP状态的一个值维护进去。

以示例2的例子为例，初始状态下，DP数组的第一行是`[[1,1], [10,1]]`，表明第一个房子分别粉刷成1色和2色后，最小总cost分别是1和10，同时两种情况
下街区数目前都还是1。
接着看第二行，由于本身房子为2色，所以第一列可以不考虑，而第二列就出现问题了。
对于`dp[1][1]`这个位置来说，我可以选择从`dp[0][0]`走过来，此时总cost不变而街区变成两个。
或者可以从`dp[0][1]`走过来，总cost不变，街区数也不变（因为两个房子都是2色）。
这时就傻眼了。因为没有一个统一的标准（时刻保持总cost最小还是街区数最小），所以同样的数据，在不同条件下要走不同的路径才能得到正确答案。
说明DP状态还不够完善。

此时看了提示，顿时感觉要记住这个套路。
既然你的街区总数在上述DP构想中还是会动，引入了不确定因素，那么干脆吧街区数也编入DP状态的一个维度，
这样，我们就得到了`m * n * target`的DP数组。`dp[i][j][k]`代表，前`i`个房子当把`i`号房刷成`j`色时，恰好形成`k`个街区时需要的最小cost。

接下来推导状态转移方程。
为了叙述方便，我们还是以行、列来称呼`i`和`j`的维度，用"小格"来称呼`k`的维度。
另外，为了代码更好懂，我们将`j`和`k`的维度+1，从而可以直接将颜色、街区数不经过减一处理直接作为下标使用。

显然，第一行每列的第一个小格都是`cost[0][j-1]`。其余小格全是INF。
接着，对于`i`行的`j`列来说，其`k`小格的值，代表形成了`k`个街区的最小cost。
此时就该查`i-1`行时，即`i-1`号房的颜色是否是`j`，如果不是`j`那么就从所有不是`j`的`j0`中选取`k-1`小格最小的那个。如果是`j`那么`i`号房和`i-1`
号房同色，相当于延长了街区，可以直接沿用`i-1`号房是`j`色时`k`小格的值。
最后别忘了如果`i`房最开始是白房子，那么需要加上相应的cost

用代码来说就是：
```python
for i in range(m):
    for j in range(1, n+1):
    if houses[i] != 0 and j != houses[i]: continue    # 一个显然的优化，因为不允许重新刷房
    this_cost = cost[i][j-1] if houses[i] == 0 else 0
        for k in range(1, target+1):        
            dp_value = min(dp[i-1][x][k-1] for x in range(1, n+1) if x != j)   # 增加了一个街区的情况
            dp_value = min(dp_value, dp[i-1][j][k])    # 延长已有街区的情况
            dp[i][j][k] = dp_value + this_cost      
```

按照以上思路写代码即可。
上述思路可以继续优化，因此不单独把整套代码写出来了。没有优化的这部分核心代码写在main的注释里了。

### 解法2 DP + 外部记忆优化
分析上述解法1可以看出，整体的复杂度是`O(m * n * target * n)`，总共四重循环。
外面三重循环很难避免，但是最里面一重却可以通过以空间换时间的办法换出来。

来看最里面一层循环主要处理什么问题。
针对`dp[i][j][k]`，其实最里面一层循环是要去找上一行中所有非`j`列的`k-1`位置的最小值。
于是我们想，能不能在外部保存这个值从而避免一次次循环。

显然，这个保存的值压缩了`j`这个方向的维度，所以是一个`m * target`的矩阵。我们称为`mem`。
`mem[i][k]`中保存的是dp数组中`dp[i][x][k] for x in range(n+1)`的最小值，这个值在更新dp数组过程中我们实时维护进去，避免重复的一次次循环。
这样，当我们试图计算`dp[i][j][k]`时，只要找出`mem[i-1][k-1]`，就可以直接得到`dp[i-1][x][k-1]`的值，从而避免解法1的状态转移方程中的那个循环。

同时，最重要的一点在于，解法1的那个方程中还有条件`x != j`。所以如果不巧`mem[i-1][k-1]`中保存的那个最小值，其本身的`j`恰好和当前的`j`相同
时，是不能使用的。为了避免这个风险，最终我们决定，`mem[i-1][k-1]`要保存的值是`(min_val, min_i, sec_min_val)`。
三个值分别是所有列中相关位置的最小值、取最小值时的下标值、以及第二小的值。后两个量都是为了避免刚才提到的风险而新加进来的。

具体的 ，我选择实现一个外部数据结构：
```python
F = float('inf')
class Item:
    def __init__(self):
        self.min_val = F
        self.min_i = -1
        self.sec_min_val = F

    def update(self, j_ind, val):
        if val < self.min_val:
            self.sec_min_val = self.min_val
            self.min_val = val
            self.min_i = j_ind
        elif val < self.sec_min_val:    # !!!
            self.sec_min_val = val
    
    def get(self, j_ind):
        return self.min_val if j_ind != self.min_i else self.sec_min_val
```
update方法用于实时更新DP数组过程中更新相应位置的信息。注意打了！！！的地方，一开始这个逻辑给忘了导致代码出错。
get方法用于查找上一行相应`k`位置的所有值中的最小值，而如果最小值下标是当前下标，那就用第二小值。

接下来只要初始化`mem`这个外部记忆，借助它就可以做到O(1)时间内找到我们想要的值了。
```python
mem = [[Item() for _ in range(target + 1)] for _ in range(m)]
for j in range(1, n + 1):
    for k in range(1, target + 1):
        mem[0][k].update(j, dp[0][j][k])
```

最后，返回的时候，可以选择返回`min(dp[m-1][x][target] for x in range(1, n+1))`。
也可以返回与其等价的`mem[m-1][target].min_val`。