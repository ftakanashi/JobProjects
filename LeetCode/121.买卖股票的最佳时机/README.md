## 题目描述
给定一个数组，它的第 `i` 个元素是一支给定股票第 `i` 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

示例 1:
>输入: [7,1,5,3,6,4]
>
>输出: 5
>
>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
     
示例 2:
>输入: [7,6,4,3,1]
>
>输出: 0
>
>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。


### 解法 可以叫他贪心，也是状态压缩DP
股票买卖系列的最简单模型。

抛开题设，可以看到，这题的本质是从一个数组中找出一个上升子序列，使得子序列的头尾差最大。

看似很简单但是实际上还是需要一些思考。

最简单的思路，当然就是两轮遍历暴力找最大差。但稍微细想，可以想到，其实当我知道某一天的股票价格时，
当天能获得到的最大利润就是当天左边的所有价格中最小价格（当天以前的历史最低价）买进，当天卖出。

再一想，当天以前的历史最低价需要每天都向左扫描吗？不用。这些历史最低价只要从左到右扫描一次就可以全部知道。

于是第一个DP思路就出现了。整一个`min_prices`数组首先保存每天的历史最低价。

然后再整一个`profits`数组用于保存每天如果卖出能够得到的最大利润，即当天价格 - 当天之前的历史最低价。
最后输出`profits`中最大的利润值即可。

继续考虑，由于只要求全局最大值，似乎不用特地准备`profits`数组，只要扫描过程中时刻保持最大的利润`max_profit`即可。

同时，历史最低价的信息也是可以在扫描过程中同步得到更新的。

这么一来，其实这两个数组都可以被状态压缩。如此代码就很简洁了。只需要注意初始化状态要合理设置。
