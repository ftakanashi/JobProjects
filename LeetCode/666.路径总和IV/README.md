## 题目描述
对于一棵深度小于 5 的树，可以用一组三位十进制整数来表示。对于每个整数：
```
百位上的数字表示这个节点的深度 d，1 <= d <= 4。
十位上的数字表示这个节点在当前层所在的位置 P， 1 <= p <= 8。位置编号与一棵满二叉树的位置编号相同。
个位上的数字表示这个节点的权值 v，0 <= v <= 9。
给定一个包含三位整数的 升序 数组 nums ，表示一棵深度小于 5 的二叉树，请你返回 从根到所有叶子结点的路径之和 。
```

保证 给定的数组表示一个有效的连接二叉树。
 

示例 1：

![](https://assets.leetcode.com/uploads/2021/04/30/pathsum4-1-tree.jpg)
```
输入: nums = [113, 215, 221]
输出: 12
解释: 列表所表示的树如上所示。
路径和 = (3 + 5) + (3 + 1) = 12.
```
示例 2：
```
输入: nums = [113, 221]
输出: 4
解释: 列表所表示的树如上所示。
路径和 = (3 + 1) = 4.
```

提示:
```
1 <= nums.length <= 15
110 <= nums[i] <= 489
nums 表示深度小于 5 的有效二叉树
```

### 解法 构造树 DFS
这道题还挺有意思的。
按照最符合直觉的做法，先将数组`nums`中各个数字进行解析，并且自己定义一个TreeNode类来构建一颗二叉树。
再用一次DFS，求出所有路径和即可。

后半部分很简单，主要是前半部分的逻辑怎么搭。

从直觉来说，nums中的各个数字，其实百位数是有比较大区分度的，毕竟是直接指出了不同的层级。
因此我们可以借鉴层序遍历那种思路，一层一层来做。这只需要控制当前处理数字的百位数即可。

在处理一层内部的某数字时，再看十位数。设这个数字为`b`，显然`(b-1)//2`是上一层父节点的下标。
而这个下标，应该是带null的完整列表的下标。

换言之，在用一个`curr`列表从左到右收集本层节点时，若发生十位数的跳跃，即某个十位数大于`curr`的长度时，
应当用`None`来补齐`curr`，这样才能在处理下一层时可以正确地找到本层的坐标。

更多细节，在代码注释中。