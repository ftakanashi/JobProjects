## 题目描述
给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。

返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。
 

示例 1：
```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2
输出：[7,4,1]
解释：
所求结点为与目标结点（值为 5）距离为 2 的结点，
值分别为 7，4，以及 1

注意，输入的 "root" 和 "target" 实际上是树上的结点。
上面的输入仅仅是对这些对象进行了序列化描述。
```

提示：
```
给定的树是非空的。
树上的每个结点都具有唯一的值 0 <= node.val <= 500 。
目标结点 target 是树上的结点。
0 <= K <= 1000.
```

### 解法 父节点哈希表 + 两次DFS
好久每遇到有意思一点的二叉树的题目了。
另外我感觉这题还是一种反向回溯树的新套路。之前没遇到过。

首先，符合要求的节点可能是起始节点的子树内，也可能是其子树外的某前辈节点或者表亲节点等。
前一种情况非常简单，一个dfs函数带上dist参数就可以做了。
麻烦的就在于后一种情况。

因为最开始我们连起始节点的位置具体在哪也不知道，所以没办法在从根节点开始的遍历中找到符合要求的那些表亲节点。

于是这里祭出一个新套路：使用哈希表保存节点与父节点的关系，从而可以使得遍历可以反向进行。

默认的二叉树，其实是一个单向的解构，只有父节点指向根节点的指针，没有反过来的。我们这里就是手动维护一个哈希表将反过来的关系也记录下来。

于是自然，我们需要先用一次DFS来讲这关系完整提取出来。具体实现不难。

接着，有了这个哈希表之后，我们可以再找到起始节点（由于树中无重复元素，可以在第一次遍历中找到起始节点位置并记录下来，这里直接使用）开始遍历。
遍历的dfs过程和寻找起始节点子树内符合要求的点代码很类似。
只是除了搜索`node.left`和`node.right`外，还需要从`node.parent`开始搜。

另外，因为有了反向搜索，所以要注意避免循环搜索。
这可以通过为dfs函数添加一个说明"开启本次搜索的来源"的参数`prev`搞定。

具体来说，`prev`如果是`node.left`，说明本次搜索的来源是本节点的左子树，因此在本次搜索中无需基于`node.left`展开搜索了（否则就是循环搜索）
同理`node.right`和`node.parent`也类似。
