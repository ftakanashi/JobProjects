## 题目描述
给你一个数组 `nums`，对于其中每个元素 `nums[i]`，请你统计数组中比它小的所有数字的数目。

换而言之，对于每个 `nums[i]` 你必须计算出有效的 `j` 的数量，其中 `j` 满足 `j != i` 且 `nums[j] < nums[i]` 。

以数组形式返回答案。

示例 1：

>输入：nums = [8,1,2,2,3]
>
>输出：[4,0,1,1,3]
>
>解释： 
>
>对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 
>
>对于 nums[1]=1 不存在比它小的数字。
>
>对于 nums[2]=2 存在一个比它小的数字：（1）。 
>
>对于 nums[3]=2 存在一个比它小的数字：（1）。 
>
>对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。

示例 2：

>输入：nums = [6,5,4,8]
>
>输出：[2,1,0,3]

示例 3：

>输入：nums = [7,7,7,7]
>
>输出：[0,0,0,0]
 

提示：

- 2 <= nums.length <= 500
- 0 <= nums[i] <= 100


### 解法1 暴力
不解释。

值得说一说的是，最开始我觉得暴力太费时间了，肯定不行。
结果一看答案，发现暴力也是一种可以接受的解法…所以当实在想不出办法的时候，暴力试一下说不定也行。

显然，暴力的时间是O(n^2)的。

### 解法2 排序后统计
这也是很容易想到的一个思路。
把原数组排序，排序后得到的从左到右扫描，（在没有相同数字的情况下）只要看某个数字左边有多少个元素就可以知道他的这个值是多少了。

当然这个办法的一个难点在于如何知道排序后各个元素与原元素的位置对应关系。

一开始在快排的算法里捣鼓了一会儿，没整出来，后来一看答案，原来发现这类问题的套路是，
把 `nums` 给变成 `[(n, i) for i, n in enumerate(nums)]`来排序。。基准值是`nums[i][0]`而交换的时候
交换整个tuple即可。