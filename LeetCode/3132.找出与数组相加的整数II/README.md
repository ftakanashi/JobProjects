## 题目描述
给你两个整数数组 nums1 和 nums2。

从 nums1 中移除两个元素，并且所有其他元素都与变量 x 所表示的整数相加。如果 x 为负数，则表现为元素值的减少。

执行上述操作后，nums1 和 nums2 相等 。当两个数组中包含相同的整数，并且这些整数出现的频次相同时，两个数组 相等 。

返回能够实现数组相等的 最小 整数 x 。

示例 1:
```
输入：nums1 = [4,20,16,12,8], nums2 = [14,18,10]
输出：-2
解释：
移除 nums1 中下标为 [0,4] 的两个元素，并且每个元素与 -2 相加后，nums1 变为 [18,14,10] ，与 nums2 相等。
```
示例 2:
```
输入：nums1 = [3,5,5,3], nums2 = [7,7]
输出：2

解释：
移除 nums1 中下标为 [0,3] 的两个元素，并且每个元素与 2 相加后，nums1 变为 [7,7] ，与 nums2 相等。
```
 

提示：
```
3 <= nums1.length <= 200
nums2.length == nums1.length - 2
0 <= nums1[i], nums2[i] <= 1000
测试用例以这样的方式生成：存在一个整数 x，nums1 中的每个元素都与 x 相加后，再移除两个元素，nums1 可以与 nums2 相等。
```

### 解法 排序 双指针
首先给出这个的一个前序题目，LC.3131。
前序题目中，没有去除两个数字的限制，所以直接排序后依次比较两个数组中同下标位置的数字之差即可。

多了两个数字之后，稍微变复杂了一点。
由于本质上仍然是寻找nums1中的某个序列，使其排序后可以和排序后的nums2一一对应。
考虑这个nums1中的序列的首项，只可能是下标为 `0, 1, 2` 中的一个。（因为不能同时去除三个数字

在确定首项后，其实也就确定了最终去除掉两个数字后，两个数组一一对应后每组元素的差值了。我们称之为标准差值吧。
此时就可以使用双指针分别从`pivot + 1`（`pivot`是指选择的 `0, 1, 2`中的那个值），以及`0`开始分别遍历两个数组。

遍历过程中，只要对应的两个数字差值是等于标准差值的，两个指针分别右移，否则只移动`nums1`的指针。

遍历完成后，若`nums2`中的指针可以走到头，说明`nums2`中的每个数字都可以通过标准差值找到对应的数字，因此可以返回此时的标准差值作为答案。

最后还有一个小点，当存在多种可能的标准差值（比如示例1中去除20和16也是可以的）时，根据题目要求，要让`nums1[i]-nums2[i]`差值最小，
因此我们应该尽量取用`nums1`中较大的值。

因此最开始选择 `pivot` 的时候，我们倒着遍历 `2, 1, 0`。这样只要碰到第一个答案，就是最终答案。

