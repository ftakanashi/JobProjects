## 题目描述
给你一个整数数组 arr 和一个整数 difference，请你找出并返回 arr 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 difference 。

子序列 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 arr 派生出来的序列。

示例 1：
```
输入：arr = [1,2,3,4], difference = 1
输出：4
解释：最长的等差子序列是 [1,2,3,4]。
```
示例 2：
```
输入：arr = [1,3,5,7], difference = 1
输出：1
解释：最长的等差子序列是任意单个元素。
```
示例 3：
```
输入：arr = [1,5,7,8,5,3,4,2,1], difference = -2
输出：4
解释：最长的等差子序列是 [7,5,3,1]。
```

提示：
```
1 <= arr.length <= 105
-104 <= arr[i], difference <= 104
```

### 解法 DP + 哈希表
一眼就看出可以用DP做。类比`LC.300`的DP做法。（顺便一提，单调栈做法似乎不行

然后稍微深入一点思考，怎么DP呢？
显然，对于扫描到某个数字num后，只需要看`num - difference`是否在之前出现过，
将其出现过位置中最大的DP值拿过来，+1就是当前位置的DP值了。

于是第一版代码自然而然形成了。使用一个`num2i`的defaultdict针对每个数字出现的每个位置进行记录。
之后扫描到`num`时只需要取DP值`max(dp[j] for j in num2i[num - difference])`即可。

初版虽然AC了，但是耗时挺长的，然后看怎么优化。
再仔细想想，其实如果某一个数字在数组中出现两次或以上，其dp值必然是越来越大的。
比如`arr[i] == arr[j]`，那么若`dp[i]`是`n`，显然说明`i`位置前有`n-1`个满足等差的前序数。
又因为`i < j`，说明`dp[j]`至少也是`n`。

换言之，上面不用`max`，只需要取最后一个值，即
`dp[num2i[num - difference][-1]]`就是我们要求的前序DP值。
提交后仍然不是很理想。

继续思考发现，既然只需要取最近的一个`num - difference`，那么似乎没必要用defaultdict，
直接一个简单的哈希表，如果出现重复就直接把值更新即可。
最后形成最终版本代码。