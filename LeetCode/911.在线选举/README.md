## 题目描述
给你两个整数数组 persons 和 times 。在选举中，第 i 张票是在时刻为 times[i] 时投给候选人 persons[i] 的。

对于发生在时刻 t 的每个查询，需要找出在 t 时刻在选举中领先的候选人的编号。

在 t 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。

实现 TopVotedCandidate 类：
```
TopVotedCandidate(int[] persons, int[] times) 使用 persons 和 times 数组初始化对象。
int q(int t) 根据前面描述的规则，返回在时刻 t 在选举中领先的候选人的编号。
```
示例：
```
输入：
["TopVotedCandidate", "q", "q", "q", "q", "q", "q"]
[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]
输出：
[null, 0, 1, 1, 0, 0, 1]

解释：
TopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);
topVotedCandidate.q(3); // 返回 0 ，在时刻 3 ，票数分布为 [0] ，编号为 0 的候选人领先。
topVotedCandidate.q(12); // 返回 1 ，在时刻 12 ，票数分布为 [0,1,1] ，编号为 1 的候选人领先。
topVotedCandidate.q(25); // 返回 1 ，在时刻 25 ，票数分布为 [0,1,1,0,0,1] ，编号为 1 的候选人领先。（在平局的情况下，1 是最近获得投票的候选人）。
topVotedCandidate.q(15); // 返回 0
topVotedCandidate.q(24); // 返回 0
topVotedCandidate.q(8); // 返回 1
```

提示：
```
1 <= persons.length <= 5000
times.length == persons.length
0 <= persons[i] < persons.length
0 <= times[i] <= 109
times 是一个严格递增的有序数组
times[0] <= t <= 109
每个测试用例最多调用 104 次 q
```

### 解法 单词扫描预处理 + 二分查找
这题题意稍微有点绕。
解释一下，就是给出了两个等长的数组persons和times。
`persons[i]`表示这是投给候选人`persons[i]`的一票。
而`times[i]`表示这票是在`times[i]`这个时间点上投出的。

在时间这个轴上，最开始投出票总数是0，随着时间的推移票也会越来越多。
而投出的票也会有一个根据候选人的分布。
而题目要求实现的`q`方法，就是给出某个时间点，让求该时间点上，按照当前的投票分布，得票数最高的是哪个候选人。

注意，示例中的候选人只有0和1两个，但是题目并没给出候选人人数的限制。
比如我完全可以投票如:
```python
person = [0,1,2,3,4]
times=[0,5,10,15,20]
```

这题第一眼可以看出来的，是`q`方法中，给出时间点后，我可以在`times`数组中进行一次二分查找，从而确定当前时间点位置总共投出了哪些票。

接着朴素的思路是，遍历`persons`中那些处于该时间点之前的票，计数分布情况，给出最终答案。
当然，这么做的话每调用一次`q`都有可能要做`O(n)`的扫描工作，显然会比较费时间。

当输入的两个数组给定后，其实在每个times中给出的时间点上，当前票数最高的候选人是固定的。
因此可以在开始`q`调用之前，就先进行一次预处理。这样每次调用`q`，只要查询一下预处理数组就行了。

而预处理过程还需要进一步思考。
最简单的思路，就是维护一个counter然后在每个遍历点都对counter的计数进行排序，从而获得答案。
但是这样还是复杂度较高。

实际上稍微仔细思考一下，或许不需要不断地排序，而只要设置一个始终指向当前得票数最多的候选人的指针即可。
具体逻辑类似下面的代码：
```python
for person in persons:
    counter[person] += 1
    if counter[person] >= counter[cand]:
        cand = person
    res.append(cand)
```

如此，只需要一次扫描，在预处理阶段，就可以确定`times`中每个时间节点时，票数最高候选人。
接着，每次调用`q(time)`时，只需要二分查找`time`这个时间点在`times`中的位置，若刚好`time`存在于`times`中就直接返回对应的候选人；
否则向前取整，返回前一个时间点的候选人即可。
为了实现上述逻辑，可以选用`bisect.bisect`进行搜索，然后将返回的答案-1，就是所求位置。
