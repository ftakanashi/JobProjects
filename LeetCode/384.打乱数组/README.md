## 题目描述
给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。

实现 Solution class:
- Solution(int[] nums) 使用整数数组 nums 初始化对象
- int[] reset() 重设数组到它的初始状态并返回
- int[] shuffle() 返回数组随机打乱后的结果

示例：
```
输入
["Solution", "shuffle", "reset", "shuffle"]
[[[1, 2, 3]], [], [], []]
输出
[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]

解释
Solution solution = new Solution([1, 2, 3]);
solution.shuffle();    // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]
solution.reset();      // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]
solution.shuffle();    // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]
```

提示：
```
1 <= nums.length <= 200
-106 <= nums[i] <= 106
nums 中的所有元素都是 唯一的
最多可以调用 5 * 104 次 reset 和 shuffle
```

### 解法 Fisher-Yates洗牌算法
首先应当明确，这题考察的是洗牌算法，即打乱一个数组的算法的具体实现。
如果直接使用`random.shuffle`之类的库方法，当然也可以AC…

从解题的大方向上来说，因为要实现reset，所以可在初始化的时候设置一个原数组的副本`original`。当需要reset的时候就把original给覆盖到nums上返回。
另一方面shuffle的时候，就需要设置一套洗牌算法，将原数组打乱。
由于在打乱的基础上再等概率打乱，结果上来说还是等概率的打乱，所以shuffle方法内不用考虑将original覆盖到nums上，直接在nums上打乱即可。

现在问题变成了如何设计一个shuffle算法来打乱一个数组，即`random.shuffle`本身的实现到底是怎么样的。

我们如此考虑这个算法的大框架：
针对长度为n的原数组nums，我们对其循环n次，第下标`i`次循环时，执行如下操作
```text
从[i, n)中随机选取一个下标j    # 这个当然可以借用一些封装级别没那么高的库函数比如random.randrange
将i, j位置元素互换
i += 1
```
在如上过程中，我们始终保持数组的`[0, i)`之间是已经完成乱序的数组，而剩余右边是仍未被安排进乱序结果的部分元素（虽然他们也不保持原顺序了）。
这么做的科学性在于，对原数组nums中的每个数而言，其被安排到乱序后数组第`i`个位置的概率都是等同的`1/n`。具体证明可见官方答案。

以上就是基本的洗牌算法的思想，也称为Fisher-Yates洗牌算法。