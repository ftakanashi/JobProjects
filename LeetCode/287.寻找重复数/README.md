## 题目描述
给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。

你设计的解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。

示例 1：
```
输入：nums = [1,3,4,2,2]
输出：2
```
示例 2：
```
输入：nums = [3,1,3,4,2]
输出：3
```
示例 3：
```
输入：nums = [1,1]
输出：1
```
示例 4：
```
输入：nums = [1,1,2]
输出：1
```

提示：
```
1 <= n <= 10^5
nums.length == n + 1
1 <= nums[i] <= n
nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次
```

进阶：
```
如何证明 nums 中至少存在一个重复的数字?
你可以设计一个线性级时间复杂度 O(n) 的解决方案吗？
```
### 审题
这题的难点在于题目要求不修改数组并且只能用O(1)的额外空间。
否则，原地哈希，排序之类的，解法有很多种。

### 解法1 二分查找
说实话这题能用二分是没想到的…

二分，必然需要有一个有序的数组。但是不能修改原数组，于是就只能想办法自己构建一个有序的数组了。
然而这个有序数组应该是什么呢？

我们注意到原数组的这样一个性质：
对于数字`k (1 <= k <= n)`，若统计原数组中小于等于`k`的值`cnt`，会有几种可能。
第一，`cnt == k`，这也是如果没有任何重复数字的情况下`1~n`这个序列的情况。
第二，`cnt < k`，说明`k`这个数字不存在于原数组中。
第三，`cnt > k`，说明小于等于`k`的某个数字是重复数字。

比如例子`1 3 2 4 5 3`。1~5的各个数字对应的cnt是：
```text
数字：1 2 3 4 5
cnt：1 2 4 5 6
```
可以多尝试写几个例子，来感受这个性质。
我们发现，以`1 ~ n`为探索范围，我们只需要找到其中第一个`cnt > k`的数字，其就是我们要找的重复数字。
而cnt又是一个递增序列，所以可以用二分查找。

由于O(1)额外空间的要求，我们无法实现将所有数字的cnt通过哈希表提前存储。
不过好在这个计算cnt的过程也不过是O(n)，结合外部二分查找O(logn)，整体复杂度也不过是O(nlogn)，还可以接受。
所以定义一个`get_cnt`函数，每次需要确定某个数字的Cnt值时调用一下即可。

### 解法2 模拟链表法
这种方法更是奇思妙想…

首先来看，若没有任何重复数字的一个序列如`2 1 4 5 3`，其实若将游标初始化为`x=0`且以`x = nums[x]`的规则进行探索的话，可以得到：
`0 -> 2 -> 4 -> 3 -> 5`这样一个序列。而1因为本身就在自己的下标位置上，所以没有进入这个序列。

现在，引入一个重复数字，
直接说结论，就是这会导致上面这个序列出现一条回头路。换言之，如果将序列视作一个链表，那么这个链表会出现一个环，而环的入口，就是那个重复数字！
（说实话这个结论想了一会儿没想出什么好的证明，甚至说明的办法…）

于是这题就变成了一个判断链表环入口的问题了，就可以用快慢指针来做了。

当然，这里没必要真的构建链表，只需要进行`x = nums[x]`的递推操作即可。所以空间还是O(1)。
另一方面，因为始终是指针的线性扫描，整体时间复杂度也不过O(n)，优于解法1。