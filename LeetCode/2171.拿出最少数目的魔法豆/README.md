## 题目描述
给定一个 正整数 数组 beans ，其中每个整数表示一个袋子里装的魔法豆的数目。

请你从每个袋子中 拿出 一些豆子（也可以 不拿出），使得剩下的 非空 袋子中（即 至少还有一颗 魔法豆的袋子）魔法豆的数目 相等。一旦把魔法豆从袋子中取出，你不能再将它放到任何袋子中。

请返回你需要拿出魔法豆的 最少数目。

示例 1：
```
输入：beans = [4,1,6,5]
输出：4
解释：
- 我们从有 1 个魔法豆的袋子中拿出 1 颗魔法豆。
  剩下袋子中魔法豆的数目为：[4,0,6,5]
- 然后我们从有 6 个魔法豆的袋子中拿出 2 个魔法豆。
  剩下袋子中魔法豆的数目为：[4,0,4,5]
- 然后我们从有 5 个魔法豆的袋子中拿出 1 个魔法豆。
  剩下袋子中魔法豆的数目为：[4,0,4,4]
总共拿出了 1 + 2 + 1 = 4 个魔法豆，剩下非空袋子中魔法豆的数目相等。
没有比取出 4 个魔法豆更少的方案。
```
示例 2：
```
输入：beans = [2,10,3,2]
输出：7
解释：
- 我们从有 2 个魔法豆的其中一个袋子中拿出 2 个魔法豆。
  剩下袋子中魔法豆的数目为：[0,10,3,2]
- 然后我们从另一个有 2 个魔法豆的袋子中拿出 2 个魔法豆。
  剩下袋子中魔法豆的数目为：[0,10,3,0]
- 然后我们从有 3 个魔法豆的袋子中拿出 3 个魔法豆。
  剩下袋子中魔法豆的数目为：[0,10,0,0]
总共拿出了 2 + 2 + 3 = 7 个魔法豆，剩下非空袋子中魔法豆的数目相等。
没有比取出 7 个魔法豆更少的方案。
```

提示：
```
1 <= beans.length <= 105
1 <= beans[i] <= 105
```

### 解法 前缀和
这道题目还算比较有意思的。
显然，某个口袋可以选择全部拿光或者拿一定数量让其最终豆子数量为某个基准值。

于是，很自然就能想到，最终的某个基准值肯定是某个袋子中最开始有的豆子数量。
确定基准值后，所有数量比它小的袋子都将拿空，所有数量比它大的袋子都将拿走一定量使得最终豆子量降低到基准值。

一个最笨的办法就是遍历所有袋子，挨个作为基准值然后计算要拿走的总豆子数。
当然这样是O(n^2)的，会超时。

上面说过，一旦基准值确定之后，实际上所有袋子会被分成，豆子数量比它更多的和比它更少的两类，两类分类讨论便可以计算出最终答案。
比它更少的袋子，简单求和即可。
比它更多的袋子，则是求和后再减去袋子数量 乘以 基准值数量的最终保留豆子数。

于是稍微思考下就可以发现可以用前缀和。
我们先对所有袋子排序并求前缀和。
然后从前到后我们依次遍历所有袋子，将其初始值作为基准值。
假设遍历到了前缀和下标为`i`（即袋子原下标为`i-1`）的袋子。
此时，`presum[i-1]` 就是上面提到的豆子数更少的袋子中豆子的总和。
`presum[n] - presum[i] - (n-i) * beans[i-1]` 则是豆子数更多的袋子中需要拿走的总的豆子数。

按上述算法，整体复杂度是 O(nlogn) 的排序加上 O(n) 的遍历即可。