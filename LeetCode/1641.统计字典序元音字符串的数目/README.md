## 题目描述
给你一个整数 n，请返回长度为 n 、仅由元音 (a, e, i, o, u) 组成且按 字典序排列 的字符串数量。

字符串 s 按 字典序排列 需要满足：对于所有有效的 i，s[i] 在字母表中的位置总是与 s[i+1] 相同或在 s[i+1] 之前。

示例 1：
```
输入：n = 1
输出：5
解释：仅由元音组成的 5 个字典序字符串为 ["a","e","i","o","u"]
```
示例 2：
```
输入：n = 2
输出：15
解释：仅由元音组成的 15 个字典序字符串为
["aa","ae","ai","ao","au","ee","ei","eo","eu","ii","io","iu","oo","ou","uu"]
注意，"ea" 不是符合题意的字符串，因为 'e' 在字母表中的位置比 'a' 靠后
```
示例 3：
```
输入：n = 33
输出：66045
```

提示：
```
1 <= n <= 50 
```

### 解法 DP
一道比较简单的DP题目。
第一眼似乎用DFS做，用DFS应该也能做。

DP的话，显然就是构建一个长度为`n`的DP数组，用于表示到位置`n`为止总共有多少种字符串。
不过由于严格需要字典序，所以相当于每个DP状态还需要进一步分化。
因此，这里需要再次将每个DP状态分割成5个。
相当于构建`5 * n`的DP数组，`dp[i][j]`表示第`j`个位置为止且末尾恰好是第`i`个元音字母时的种类数量。

仔细一想，发现其实每个`dp[i][j]`都只和`dp[i-1]`中的各个值（更准确的说，其实就是`dp[i-1][:j+1]`的总和）有关，
所以可以状态压缩。

看代码。