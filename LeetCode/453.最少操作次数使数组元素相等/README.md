## 题目描述
给你一个长度为 n 的整数数组，每次操作将会使 n - 1 个元素增加 1 。返回让数组所有元素相等的最小操作次数。

示例 1：
```
输入：nums = [1,2,3]
输出：3
解释：
只需要3次操作（注意每次操作会增加两个元素的值）：
[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
```
示例 2：
```
输入：nums = [1,1,1]
输出：0
```

提示：
```
n == nums.length
1 <= nums.length <= 105
-109 <= nums[i] <= 109
答案保证符合 32-bit 整数
```

### 解法 数学 反向思考
好久没被一道简单题卡住了笑

这题是这样的，如果你按照题意，去从初始状态然后一步一步分别找`n-1`个数去加1，企图使得所有数字相等，这个过程相当难找。

但是，如果反过来看呢？
首先应该认识到这样一个事实，数组中的数字的绝对值和答案并没有关系。只要相对关系是`1 2 3`，那么无论输入是`1 2 3`还是`101 102 103`，其操作次数是相等的。
在这个基础上，将`n-1`个数字+1，就可以看做是将某一个数字-1，这样一来，操作就简单的多得多了。

具体来说，只要找出数组中的最小数，然后计算每个数字与之差值。某数字`nums[i]`若差`k`
就代表正向操作过程中，会有k次除了`nums[i]`以外其他`n-1`个数字+1的操作。
最终答案就是这些差值的总和。

说实话，看完答案，虽然做法确实非常简单，代码闭着眼睛都能写。但是为什么能这么写还是有点无法释怀的地方。。