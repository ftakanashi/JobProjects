## 题目描述
给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。

如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。

示例 1：
```
输入：1
输出：true
```
示例 2：
```
输入：10
输出：false
```
示例 3：
```
输入：16
输出：true
```
示例 4：
```
输入：24
输出：false
```
示例 5：
```
输入：46
输出：true
```

提示：
```
1 <= N <= 10^9
```

### 解法1 DFS回溯 + 位运算
一个最直观的思路，就是按照题意去求这个数字的全排列，然后检查这些排列中是否有2的幂。
而求是否是2的幂这个判断，可以通过位运算简单地得出：`n & (n-1) == 0`。

至于全排列怎么求，可以参考`LC.47`这里就不多说了。

和`LC.47`相比，这道题对dfs函数的递归终止情况要进行比较细致的讨论。
若定义`dfs(pos)`，显然，当`pos == n-1`的时候要返回False，表示此时递归已经扫描到头。而另一方面，
如果当前数组组合起来是一个2的幂，那么就可以直接返回True。后者的判断一定要放在前者之前，否则会漏掉很多情况。

因为题目要求是只要有一种能够是2的幂的排列就返回，因此在上层递归发现下层返回True后可以立即停止所有作业，直接返回True给更上层。

更多的就不说了，直接看代码。

### 解法2 预处理 哈希集
这种解法更取巧一点。
注意到因为是对原数进行任意的重新排列，因此，只要是任意一个数位计数与某个2次幂数的数位计数完全相同的数，就可以做到返回True，反之返回False。

另一方面，题目给出的数字范围是10^9以下。而这其中2的次幂数的个数有限。

因此很简单，只需要事先将所有范围内的2的次幂数的数位计数全部在预处理阶段算出并保存下来。
接着只要将输入的数字`n`做相同的处理，然后看其计数是否存在于预处理阶段得到的这些结果中了。

为了方便，我这里采用了长度为10的元组进行计数表示。这样预处理阶段就可以组成一个哈希集方便后面的判断了。