## 题目描述
设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。

如果指定节点没有对应的“下一个”节点，则返回null。

示例 1:
```
输入: root = [2,1,3], p = 1

  2
 / \
1   3

输出: 2
```
示例 2:
```
输入: root = [5,3,6,2,4,null,null,1], p = 6

      5
     / \
    3   6
   / \
  2   4
 /   
1

输出: null
```

### 解法1 DFS + 二分
因为是二叉搜索树，所以第一时间能够想到的最朴素的解法，就是通过一次中序DFS得到整个序列。
此时序列是有序的。

然后再在这个序列中进行一次二分查找，就可以找到指定节点的后继节点了。

这个做法实在是没什么可说的。

### 解法2 利用二叉搜索树特性遍历
不看找后继节点这个任务，这道题一般来说，第一步是在二叉树中定位节点p的位置。
这可以利用二叉搜索树的特性轻松做到。（过程O(logn)）

当定位到p之后，显然，若p有右子树，那么其右子树的最左下节点是我们要求的答案。
那个节点也可以通过简单的一个while循环定位到。

如此看来，唯一麻烦的是定位到p后，p的右子树为空的情况。
但是仔细一想，当其为空的时候，其实答案就在于根节点到p这一段路径上第一个节点值大于p的节点。
换言之，要找到从根节点遍历下来时第一次左转的那个节点。

于是，考虑在最初的定位p的过程中，用一个哈希表对所有节点与其父节点的关系进行一个保存，从而保存从根节点下来的遍历链条。
有了这个链条，就可以追根溯源，一切就简单了。