## 题目描述
一条包含字母 A-Z 的消息通过以下的方式进行了编码：
```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```
要 解码 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，"11106" 可以映射为：
```
"AAJF" 对应分组 (1 1 10 6)
"KJF" 对应分组 (11 10 6)
```
注意，像 (1 11 06) 这样的分组是无效的，因为 "06" 不可以映射为 'F' ，因为 "6" 与 "06" 不同。

除了 上面描述的数字字母映射方案，编码消息中可能包含 '*' 字符，可以表示从 '1' 到 '9' 的任一数字（不包括 '0'）。例如，编码字符串 "1*" 可以表示 "11"、"12"、"13"、"14"、"15"、"16"、"17"、"18" 或 "19" 中的任意一条消息。对 "1*" 进行解码，相当于解码该字符串可以表示的任何编码消息。

给你一个字符串 s ，由数字和 '*' 字符组成，返回 解码 该字符串的方法 数目 。

由于答案数目可能非常大，返回对 109 + 7 取余 的结果。

### 解法 DP
在`LC.91`的基础上添加了通配符`*`。所以基本思路和`LC.91`一样，还是用DP的方法。

增加了通配符无非就是需要在状态转移过程中进行一些比较细致的分类讨论而已。
我是这样讨论的：

针对扫描到位置`i`时，看`s[i]`是数字还是通配符。
如果是通配符，则进入通配符分支讨论；否则进入数字分支讨论。

在每个分支里，又要分`s[i]`独立分片以及`s[i-1]+s[i]`联合分片的两种情况。
这两种情况的DP值的增量分别又是`dp[i-1](可能需要乘以系数)`和`dp[i-2](可能需要乘以系数)`。

上面提到的系数就是和`LC.91`不同之处。比如当`s[i] == '*'`时，此时将`s[i]`单独分片，其实作为`dp[i]`来说，
增加的可能数是`dp[i-1] * 9`，这个9就代表了`*`的可能数。
同理，其他带有通配符的情况也要分析相关的系数是多少并且乘一下。具体的写在代码的注释里了。

回过头来再看整体的DP，根据`LC.91`的经验，我们知道可以将DP数组声明成`n+1`长度，并且设置`dp[0] = 1`，方便后续的递推。
另外，由于头一个字符可能是通配符，0或者其他数字。
根据这三种情况需要声明的`dp[1]`初始值分别是9,0,1。其中头一个字符是0的情况其实说明了无法解码，所以直接返回0即可。

好了，初始化情况说明完毕，递推方程也有了（虽然这里没写出来，写在代码里了），DP就有了。  