## 题目描述
给定一个字符串 s，统计并返回具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是成组连续的。

重复出现（不同位置）的子串也要统计它们出现的次数。

示例 1：
```
输入：s = "00110011"
输出：6
解释：6 个子串满足具有相同数量的连续 1 和 0 ："0011"、"01"、"1100"、"10"、"0011" 和 "01" 。
注意，一些重复出现的子串（不同位置）要统计它们出现的次数。
另外，"00110011" 不是有效的子串，因为所有的 0（还有 1 ）没有组合在一起。
```
示例 2：
```
输入：s = "10101"
输出：4
解释：有 4 个子串："10"、"01"、"10"、"01" ，具有相同数量的连续 1 和 0 。
```

提示：
```
1 <= s.length <= 105
s[i] 为 '0' 或 '1'
```

### 解法 一次遍历 记录下标
这题题意稍微有点复杂，需要琢磨一下。

简单来说，s是一个只有0和1的字符串。
题目想让你找出s中的一些子串，这些子串形如`00...0011...11`或者`11...1100...00`，
其中前后两种数字数量相等。

由于子串必然是k个0后加k个1，或者k个1后加k个0，因此找出s中那些01交界处很重要。
而对于一个比如由k个0后加k个1这样一个串，其实其内部就蕴含了k个符合要求的子串。
如`000111`，其实其中还有`01`和`0011`。

于是思路就有了。
首先一遍扫描，找出所有01或者10交界处的下标。可以将其放进一个列表中。
然后针对这个列表中的任意一个下标`x`，其前一个元素`p`后后一个元素`n`，这三者可以计算出以这个交界为中心的一个符合要求的子串。
`x - p`是前半部分的连续0或1的长度，而`n - x`是后半部分。

由于这两者不一定相等，所以只能取其中较小者。答案则可以直接加上这个较小者，表明其实其包含了多个子串。
最后别忘了统计最后一片0或者1，所以上述下标列表最后还得append一个s的长度。

举个具体的例子。
比如`000110110`这样一个s，通过一遍扫描可以得到一个下标列表：
```python
[0, 3, 5, 6, 8, 9]
```
注意最后一个9是额外append上去的s的长度。

接着，扫描这个列表，第一例，`min(3-0, 5-3)`，答案加上2。
第二例，`min(5-3, 6-5)`，答案加上1。
以此类推，可得答案是`2 + 1 + 1 + 1 = 5`。

以上思路应该是可以不走下标列表这个中间体，直接一次扫描搞定的，不过我也懒得优化了…