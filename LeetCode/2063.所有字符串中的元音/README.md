## 题目描述
给你一个字符串 word ，返回 word 的所有子字符串中 元音的总数 ，元音是指 'a'、'e'、'i'、'o' 和 'u' 。

子字符串 是字符串中一个连续（非空）的字符序列。

注意：由于对 word 长度的限制比较宽松，答案可能超过有符号 32 位整数的范围。计算时需当心。

示例 1：
```
输入：word = "aba"
输出：6
解释：
所有子字符串是："a"、"ab"、"aba"、"b"、"ba" 和 "a" 。
- "b" 中有 0 个元音
- "a"、"ab"、"ba" 和 "a" 每个都有 1 个元音
- "aba" 中有 2 个元音
因此，元音总数 = 0 + 1 + 1 + 1 + 1 + 2 = 6 。
```
示例 2：
```
输入：word = "abc"
输出：3
解释：
所有子字符串是："a"、"ab"、"abc"、"b"、"bc" 和 "c" 。
- "a"、"ab" 和 "abc" 每个都有 1 个元音
- "b"、"bc" 和 "c" 每个都有 0 个元音
因此，元音总数 = 1 + 1 + 1 + 0 + 0 + 0 = 3 。
```
示例 3：
```
输入：word = "ltcd"
输出：0
解释："ltcd" 的子字符串均不含元音。
```
示例 4：
```
输入：word = "noosabasboosa"
输出：237
解释：所有子字符串中共有 237 个元音。
```

提示：
```
1 <= word.length <= 105
word 由小写英文字母组成
```

### 解法1 模拟
这题最大的一个需要注意的点就是所有元音需要被重复计算。

如果单纯从字符串的角度出发，一个个构造出所有子字符串并且统计元音，那么必然会有大量的计算。
此时可以反过来，从元音字母的角度出发。

因为一个元音被统计一次就只有两个条件。
第一，这个是一个元音字母。第二，处于一个子字符串中。
所以我们可以抓住一个元音字母然后看其处于多少个子字符串中即可。

而这个问题就简单很多了，设这个字母下标为`i`，那么下标`0`到`i`之间的所有字母都可以作为子字符串的开头位置。`i`到`n`之间的所有字母都可以作为末尾位置。

所以对于下标为`i`的元音字母来说，包含其的子字符串总数一共是`(i + 1) * (n - i)`种。
把所有元音字母的对应值计算出来然后加和起来就可以得到结果了。

另外提醒一下，题目中只说需要注意32位整数的限制，并没有明确说要对某个MOD值取余，所以无需额外处理。

### 解法2 DP
这题用DP还真有点绕…

首先在于DP值的定义。一开始我将其定义为"以`i`位置为结尾的所有子字符串的元音总数"。这样最终的答案应该是`sum(dp)`。
但是这样的话状态转移方程非常难想……

如果将DP值定义为"前`i`个位置的所有子字符串的元音总数"，最终答案返回`dp[-1]`就行了。
此时`dp[i]`应该怎么求呢？

首先，`dp[i-1]`中包含的所有子字符串，都是`dp[i]`中的子字符串，所以可以直接有一个基础值就是`dp[i-1]`。
其次，那些以`i-1`位置为结尾的子字符串，随着`i`位置字母的加入，又可以多一批新的子字符串出来，这批新的子字符串中的元音个数还需要额外统计。

这部分新子字符串的元音总数，其实就是`dp[i-1] - dp[i-2]`。相当于是将所有结尾不是`i-1`位置字母的子字符串都剔除了。

除了上述部分，新加入的字母`word[i]`本身是否是元音字母还有影响。若是，则所有以`i`位置为结尾的子字符串还要额外加1个计数，总的需要额外加上`i+1`。

综上，状态转移方程如下：
```python
if word[i] in vowels:
    dp[i] = dp[i-1] * 2 - dp[i-2] + i + 1
else:
    dp[i] = dp[i-1] * 2 - dp[i-2]
```

有了这个，剩下的就好写了。