## 题目描述
给定一个数组 books ，其中 books[i] = [thicknessi, heighti] 表示第 i 本书的厚度和高度。你也会得到一个整数 shelfWidth 。

按顺序 将这些书摆放到总宽度为 shelfWidth 的书架上。

先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 shelfWidth ），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。

需要注意的是，在上述过程的每个步骤中，摆放书的顺序与你整理好的顺序相同。

例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。
每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。

以这种方式布置书架，返回书架整体可能的最小高度。

示例 1：

![](https://assets.leetcode.com/uploads/2019/06/24/shelves.png)
```
输入：books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelfWidth = 4
输出：6
解释：
3 层书架的高度和为 1 + 3 + 2 = 6 。
第 2 本书不必放在第一层书架上。
```
示例 2:
```
输入: books = [[1,3],[2,4],[3,2]], shelfWidth = 6
输出: 4
```

提示：
```
1 <= books.length <= 1000
1 <= thicknessi <= shelfWidth <= 1000
1 <= heighti <= 1000
```

### 解法 DP
首先注意审题，题目中书本的最大数量是1000，且最高高度也是1000，范围不是很大。
另外题目明确说了所有书都必须放入书架，且必须按顺序放入。这也大大降低了题目难度。

总的来说，很容易想到用DP或者DFS之类的方法，并且扫描到一本书`books[i]`的时候，重点需要关注的，是是否将其放置到新开的一层中，还是和前面若干本
书挤在同一层（当然前提是这些书的总宽度不超过`shelfWidth`）

于是我们设计这样一个DP算法。
定义长度为`n`的DP数组，`dp[i]`表示下标`i`为止的所有书本中，能排列出的最小高度。显然`dp[0] = books[0][1]`。

为了确定`dp[i]`的值，我们倒序从`i`开始向前遍历，以下标`j`作为标记。即`for j in range(i, -1, -1)`。
这个遍历过程中，遍历过的书本被视为被一起放在最后一层。遍历过程中维护一个`tmp_width`值表示这层书架上已经拜访的书的总宽度。
显然，当`tmp_width`大于`shelfWidth`时，遍历无法继续进行下去，应当break掉。

遍历过程中，还应当实时维护一个`maxHeight`值，这个值表示当前这层书架上书的最高高度，后续用于统计最终答案。
扫描到特定`i`值和特定`j`值时，有`dp[i] = min(dp[i], dp[j-1] + h)`。
表示当把下表`j`到下标`i`的所有书放到同一层后，总高度等于`dp[j-1] + h`。

这里还有一个小坑，就是当`j`等于0的时候，此时`dp[j-1]`变成dp数组最后一项了，其实这个时候应该是0，做一个特殊判断即可。
按照以上思路写代码即可。