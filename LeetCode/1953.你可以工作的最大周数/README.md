## 题目描述
给你 n 个项目，编号从 0 到 n - 1 。同时给你一个整数数组 milestones ，其中每个 milestones[i] 表示第 i 个项目中的阶段任务数量。

你可以按下面两个规则参与项目中的工作：

每周，你将会完成 某一个 项目中的 恰好一个 阶段任务。你每周都 必须 工作。
在 连续的 两周中，你 不能 参与并完成同一个项目中的两个阶段任务。
一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将 停止工作 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。

返回在不违反上面规则的情况下你 最多 能工作多少周。

示例 1：
```
输入：milestones = [1,2,3]
输出：6
解释：一种可能的情形是：
​​​​- 第 1 周，你参与并完成项目 0 中的一个阶段任务。
- 第 2 周，你参与并完成项目 2 中的一个阶段任务。
- 第 3 周，你参与并完成项目 1 中的一个阶段任务。
- 第 4 周，你参与并完成项目 2 中的一个阶段任务。
- 第 5 周，你参与并完成项目 1 中的一个阶段任务。
- 第 6 周，你参与并完成项目 2 中的一个阶段任务。
总周数是 6 。
```
示例 2：
```
输入：milestones = [5,2,1]
输出：7
解释：一种可能的情形是：
- 第 1 周，你参与并完成项目 0 中的一个阶段任务。
- 第 2 周，你参与并完成项目 1 中的一个阶段任务。
- 第 3 周，你参与并完成项目 0 中的一个阶段任务。
- 第 4 周，你参与并完成项目 1 中的一个阶段任务。
- 第 5 周，你参与并完成项目 0 中的一个阶段任务。
- 第 6 周，你参与并完成项目 2 中的一个阶段任务。
- 第 7 周，你参与并完成项目 0 中的一个阶段任务。
总周数是 7 。
注意，你不能在第 8 周参与完成项目 0 中的最后一个阶段任务，因为这会违反规则。
因此，项目 0 中会有一个阶段任务维持未完成状态。
```

提示：
```
n == milestones.length
1 <= n <= 105
1 <= milestones[i] <= 109
```

### 解法 贪心

题目不难理解。也比较容易想到用贪心，并且大概脑补出一个贪心的准则。

比如比较容易发现的，我们可以把阶段最多的工作先单独拿出来排好。然后往其中的空隙插入其他类型的工作的阶段即可。
我们不妨将最多阶段的工作称为 `A`， 总共有 `max_job` 个阶段。
称除了最长的工作外其余工作的阶段总数为 `rest` 。显然 `rest = sum(milestones) - max_job`。

先考虑一种比较坏的情况。当 `max_job > rest + 1` 时，非最长工作不论怎么插入都不够插满所有空隙，从而导致必然会有一部分`A`相邻。
此时能够工作最长周数是 `rest * 2 + 1`，将非最长工作统称为 `X` 的话，大概是：
```
A X A X A ... X A
```
满足间隙中的 `rest` 个 `X` 后算上额外的1个 `A`，所以总共是 `rest * 2 + 1`。

另一种比较理想的情况，`max_job <= rest + 1` 时，此时显然可以保证类似于下面这样一段：
```
X A X A ... A X
```
这段的长度是 `max_job * 2 + 1`，并且此时还有不少非最长工作盈余。

这里就有这道题比较绕的一个点。由于 `X` 是个统称，实际上可能是 `B/C/D...`，所以在构建完上述序列之后，实际上还有继续延长序列的空间。
但是需要注意 `B/C/D...` 这些之间也不能有相邻。

实际上，即便编排出现了相邻，只要将其与前面已经构建的部分中的某个X互换即可。

那么会不会把之前的`X`全部互换掉后还是不够呢？这是不可能的，因为如果那样，那么 `A` 就不会是所有工作中阶段最多的了。

换言之，当 `max_job <= rest + 1` 时，我们必然可以编排完所有工作，最终工作的总周数就是 `sum(milestones)`。

以上说法的严格证明可见官答。