## 题目描述
给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1：
```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```
示例 2：
```
输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```

提示：
```
0 <= k <= 100
0 <= prices.length <= 1000
0 <= prices[i] <= 1000
```

### 解法 DP
和`LC.122`，`LC.123`一脉相承的题目。
这里其实是`LC.123`的一般化。

在`LC.123`中，我们说至多进行两次交易，其实对应的是五个状态，而五个状态中每个状态都和有限的其他几个状态相关，这就使得状态转移没那么复杂。

至多两次交易，即`k=2`时，我们发现状态数是5，那么`k=3`状态数会变成7（加上了第三次买入持有和第三次卖出清仓）。

至于状态转移，根据`LC.123`的经验就可以看到，其实对于dp数组的一行中，如果`dp[j]`的j是奇数，则其表示的是某次买入持有的状态，其状态转移方程是
```python
dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] - p)
```
相反，如果是偶数，其表示的是某次卖出后清仓的状态，状态转移方程为
```python
dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + p)
```

按照以上思路写即可。

由于k一大的话，整个dp矩阵会很大，因此这里直接写状态压缩版的了。
