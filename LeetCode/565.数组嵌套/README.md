## 题目描述
索引从0开始长度为N的数组A，包含0到N - 1的所有整数。找到最大的集合S并返回其大小，其中 S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }且遵守以下的规则。

假设选择索引为i的元素A[i]为S的第一个元素，S的下一个元素应该是A[A[i]]，之后是A[A[A[i]]]... 以此类推，不断添加直到S出现重复的元素。

示例1:
```
输入: A = [5,4,0,3,1,6,2]
输出: 4
解释: 
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.

其中一种最长的 S[K]:
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}
```

提示：
```
N是[1, 20,000]之间的整数。
A中不含有重复的元素。
A中的元素大小在[0, N-1]之间。
```

### 解法 DFS
这个数组本身其实类似简化版并查集里面用来标记每个节点所属联通分量的那个数组。
显然，从任意一个节点出发，遵循`cursor = nums[cursor]`的迭代方式，必然可以遍历一整个联通分量的环。

有点巧的是前两天刚在B站上看过一个讲类似问题的[视频](https://www.bilibili.com/video/BV17W4y1S7WR)。

所以，我们可以从任意一个节点出发进行遍历，遍历出一个环的长度然后将其更新到ans上即可。
具体的，我们设置dfs函数`dfs(pos: int, link: set) -> int`。
这个函数接收一个遍历起始节点与一个哈希集用于保存已经遍历过的当前环上的所有节点。
当我们进入某次dfs时发现`nums[pos] in link`时，显然就已经形成了一个环，此时就可以直接返回`len(link)`。
否则就`link.add(nums[pos])`然后返回`dfs(nums[pos], link)`。

当然如果直接这么做，会有大量重复的遍历。所以可以额外设置一个外部哈希集seen，用于保存已经遍历过的所有节点。
外层`for i in range(n)`进行遍历的时候，若`i in seen`，则直接跳过即可。