## 题目描述
一条基因序列由一个带有8个字符的字符串表示，其中每个字符都属于 "A", "C", "G", "T"中的任意一个。

假设我们要调查一个基因序列的变化。一次基因变化意味着这个基因序列中的一个字符发生了变化。

例如，基因序列由"AACCGGTT" 变化至 "AACCGGTA" 即发生了一次基因变化。

与此同时，每一次基因变化的结果，都需要是一个合法的基因串，即该结果属于一个基因库。

现在给定3个参数 — start, end, bank，分别代表起始基因序列，目标基因序列及基因库，请找出能够使起始基因序列变化为目标基因序列所需的最少变化次数。如果无法实现目标变化，请返回 -1。

注意：

起始基因序列默认是合法的，但是它并不一定会出现在基因库中。

如果一个起始基因序列需要多次变化，那么它每一次变化之后的基因序列都必须是合法的。

假定起始基因序列与目标基因序列是不一样的。

示例 1：
```
start: "AACCGGTT"
end:   "AACCGGTA"
bank: ["AACCGGTA"]

返回值: 1
```
示例 2：
```
start: "AACCGGTT"
end:   "AAACGGTA"
bank: ["AACCGGTA", "AACCGCTA", "AAACGGTA"]

返回值: 2
```
示例 3：
```
start: "AAAAACCC"
end:   "AACCCCCC"
bank: ["AAAACCCC", "AAACCCCC", "AACCCCCC"]

返回值: 3
```

### 解法 BFS
和`LC.127`很像的一道题目。（甚至是简化版的

一看就想到了用BFS。
甚至都不用`LC.127`那样的虚拟节点的套路，直接基于一个序列替换一个基因向下一个序列探索。

由于题目规定了序列长度一定是8，所以还尝试了用固定长度哈希的办法，但是发现实际上并不是很提升效率，所以直接暴力了。

具体的，维护一个BFS队列，队列内容为一个序列以及到达这个序列需要的操作数。
然后每个可以继续向下探索的序列必须要求在bank内。
就这么简单…