## 题目描述
给你一个整数数组 arr ，请你删除一个子数组（可以为空），使得 arr 中剩下的元素是 非递减 的。

一个子数组指的是原数组中连续的一个子序列。

请你返回满足题目要求的最短子数组的长度。

示例 1：
```
输入：arr = [1,2,3,10,4,2,3,5]
输出：3
解释：我们需要删除的最短子数组是 [10,4,2] ，长度为 3 。剩余元素形成非递减数组 [1,2,3,3,5] 。
另一个正确的解为删除子数组 [3,10,4] 。
```
示例 2：
```
输入：arr = [5,4,3,2,1]
输出：4
解释：由于数组是严格递减的，我们只能保留一个元素。所以我们需要删除长度为 4 的子数组，要么删除 [5,4,3,2]，要么删除 [4,3,2,1]。
```
示例 3：
```
输入：arr = [1,2,3]
输出：0
解释：数组已经是非递减的了，我们不需要删除任何元素。
```
示例 4：
```
输入：arr = [1]
输出：0
```

提示：
```
1 <= arr.length <= 10^5
0 <= arr[i] <= 10^9
```

### 解法 双指针
这道题还真没看上去那么简单。。

题目意思很好理解，但是读完题之后很难意识到，所谓的删除某个子数组，其实分成了三种可能。
即掐头、去尾、掏中间。

也就是说，要删除的子数组可能是`arr[0:i]`或者`arr[j:n]`或者`arr[i:j]`。

三种可能中，前两种是比较好处理的，大不了我就分别从头尾进行一次非递减性的扫描。比较麻烦的是第三种可能性。

注意到，一般来说，第三种可能性中，整个`arr`可以被表示为`xxx yyy zzz`三个片段。
其中，`yyy`是要被去掉的那部分子数组。

此时，要使得去掉`yyy`后剩余数组拼接起来仍然非递减，其实可以转化为3个条件。
1. `xxx`本身必须非递减
2. `zzz`本身必须非递减
3. `xxx`的最后一个数必须小于等于`zzz`的第一个数。

我们设`xxx`的最后一个数下标为`i`，`zzz`第一个数的下标为`j`。
要同时确定`i`和`j`是比较困难的，这里，我们采用标定一个然后动另一个的思路，这也是这道题的核心算法思想。

具体的，先从右到左遍历`j`，保持`j`扫描过的区域非递减。这是一个很简单的逻辑，就不多说了。
确定`j`后，此时题目的保底答案值就是`j`（相当于把`j`前面的整个头都去掉的情况，而剩下的`arr[j:]`是排序的）。
另外此时其实还有一个特殊情况就是如果`j == 0`，也就意味着其实整个`arr`是已经排好序的，此时可以直接返回0。

然后我们从0开始遍历`i`。确定一个`i`之后，我们看此时`j`是否满足`arr[i] <= arr[j]`。
若否，则`j += 1`向右移动直到满足`arr[i] <= arr[j]`。
这么做是为了保证去除`i`和`j`中间部分后仍然有序。

这里还有一个比较绕的点，`j`有可能会突破边界到达`j == n`的情况。
此时我们不能break结束`i`的遍历，因为有可能是去尾的情况。
所以在注意`j == n`了之后不应该继续`j += 1`，另外也不能访问`arr[j]`。

针对`i`，确认符合条件的`j`位置之后，可以收割一次可能的答案为`j - i - 1`。
然后`i += 1`。
注意，此时有一个不得不判断的条件，就是为了保证`xxx`的有序，必须要有`arr[i] <= arr[i+1]`。如果不满足这个条件，其实可以直接break。
因为从这一刻开始包括后面所有的可能的`i`，都无法满足`xxx`的有序性了。
在满足了`arr[i] <= arr[i+1]`时，显然`j`只可能往右移，因为`zzz`也是有序的。此时就可以重复上述循环逻辑了。

综上，遍历`i`的过程中，我们要一方面针对`i`找到一个最小的满足条件（`arr[i] <= arr[j]`或者`j == n`）的`j`，
一方面保证`xxx`有序的情况下收割答案，最终取全局最小值即可。

说实话这题逻辑确实挺麻烦的…，具体看代码注释吧。