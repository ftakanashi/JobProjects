## 题目描述
和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。

现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。

数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。

示例 1：
```
输入：nums = [1,3,2,2,5,2,3,7]
输出：5
解释：最长的和谐子序列是 [3,2,2,2,3]
```
示例 2：
```
输入：nums = [1,2,3,4]
输出：2
```
示例 3：
```
输入：nums = [1,1,1,1]
输出：0
```

提示：
```
1 <= nums.length <= 2 * 104
-109 <= nums[i] <= 109
```

### 解法 哈希表
这题乍一看，求最长子序列，还以为要用单调栈或者DP做。
但是想了一会儿感觉没法做，或者避免不了O(n^2)。

于是转换了一下思路，发现其实根本没那么复杂…

由于题目要求的子序列内部没有排序要求，这就意味着选定一对数比如`2,3`，接下来要做的就是去原数组中找出2的个数和3的个数，
两者相加就是最终得到的子序列的总长度了。

因此做法就转移到了哈希表上。
具体的，先扫描一遍数组得到counter。
接着在扫描counter中的key，将`key-1`或者`key+1`分别与key本身组合成一对数，然后获取所有这些组合能够组成的子序列的最长值就行了。