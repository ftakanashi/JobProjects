## 题目描述
给出二叉树的根节点 root，树上每个节点都有一个不同的值。

如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。

返回森林中的每棵树。你可以按任意顺序组织答案。

示例 1：
```
输入：root = [1,2,3,4,5,6,7], to_delete = [3,5]
输出：[[1,2,null,4],[6],[7]]
```
示例 2：
```
输入：root = [1,2,4,null,3], to_delete = [3]
输出：[[1,2,4]]
```

提示：
```
树中的节点数最大为 1000。
每个节点都有一个介于 1 到 1000 之间的值，且各不相同。
to_delete.length <= 1000
to_delete 包含一些从 1 到 1000、各不相同的值。
```

### 解法 DFS
一开始尝试用了BFS，不过没一发入魂想出来，于是改用DFS，就很快做出来了

这道题的关键在于，删除一个点后，即要切断上层连接到它的线，还要切断它和两个子树的连线。
另外在什么时候把森林中各个树的根节点加入结果也很重要。

于是在一个基本的二叉树DFS函数的基础上，我们做如下改造。
首先我们判断，当当前节点`node`在`to_delete`中时，此时我们将`node.left`和`node.right`先加入答案集合中。
注意，由于`node.left`或者`node.right`本身也可能在`to_delete`中，所以后面很可能还要再删除。
由于是递归的，所以这个删除操作也可以直接在这里做。

接着看两个子树。
若左子树在`to_delete`中，那么我们要切断`node`和`node.left`之间的连接。但是不论如何为了维持DFS，我们肯定还要`dfs(node.left)`，
所以记得在切断连接前保存`node.left`节点，要不然后面就找不到了…
对右子树的处理也是类似的。

最后在外面，将`root`先加入结果集合，然后开始DFS即可。