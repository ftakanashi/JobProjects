## 题目描述
给出二叉树的根节点 root，树上每个节点都有一个不同的值。

如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。

返回森林中的每棵树。你可以按任意顺序组织答案。

示例 1：
```
输入：root = [1,2,3,4,5,6,7], to_delete = [3,5]
输出：[[1,2,null,4],[6],[7]]
```
示例 2：
```
输入：root = [1,2,4,null,3], to_delete = [3]
输出：[[1,2,4]]
```

提示：
```
树中的节点数最大为 1000。
每个节点都有一个介于 1 到 1000 之间的值，且各不相同。
to_delete.length <= 1000
to_delete 包含一些从 1 到 1000、各不相同的值。
```

### 解法 DFS
一开始尝试用了BFS，不过没一发入魂想出来，于是改用DFS，就很快做出来了

这道题的关键在于，删除一个点后，即要切断上层连接到它的线，还要切断它和两个子树的连线。
另外在什么时候把森林中各个树的根节点加入结果也很重要。

于是在一个基本的二叉树DFS函数的基础上，我们做如下改造。
首先我们判断，当当前节点`node`在`to_delete`中时，此时我们将`node.left`和`node.right`先加入答案集合中。
注意，由于`node.left`或者`node.right`本身也可能在`to_delete`中，所以后面很可能还要再删除。
由于是递归的，所以这个删除操作也可以直接在这里做。

接着看两个子树。
若左子树在`to_delete`中，那么我们要切断`node`和`node.left`之间的连接。但是不论如何为了维持DFS，我们肯定还要`dfs(node.left)`，
所以记得在切断连接前保存`node.left`节点，要不然后面就找不到了…
对右子树的处理也是类似的。

最后在外面，将`root`先加入结果集合，然后开始DFS即可。

### 解法2 BFS
没想到不到一年又出到这道每日一题了。
今天尝试用BFS撸出来了。

题目意思的分析和上面是类似的，识别要删除的节点一点不难，关键还是在于如何将这个节和周围的节点的链接砍断，以及将其子节点（如果存在的话）加入结果。

在BFS中，除了节点本身，我们额外维护两个变量，`del_flag`和`is_root`。
`del_flag`表示这个节点是否应当被删除。
`is_root`表示这个节点是否应该被加入答案。
这里需要特别强调的是，`del_flag`的优先级高于`is_root`。也就是说，某个节点的`is_root`可能被设置为True，但是如果`del_flag`也是True，那么
最终答案中不应该有他。

最开始的时候，入队的应该是`root, root.val in to_delete, True`这样一个元组。

遍历到每个节点时，我们考虑其两个子节点（如果存在的话）。
以左子节点为例，若左子节点是要删除的，则首先将`node.left, True, False`入队。
否则入队`node.left, False, del_flag`。这里`del_flag`是node自身的`del_flag`。
因为如果`node`是要被删除的，那么其子节点就有可能是要作为新的根节点入队的。

最后收割时别忘了上面说过的两个变量的优先级，
即只有 `del_flag is False and is_root is True` 的时候才能收割答案。