## 题目描述
给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

示例 1：
```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```
示例 2：
```
输入：nums = [9], target = 3
输出：0
```

提示：
```
1 <= nums.length <= 200
1 <= nums[i] <= 1000
nums 中的所有元素 互不相同
1 <= target <= 1000
```

- 进阶：如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？

### 解法1 DFS
一看就可以用DFS做。

探索的时候注意几点。
首先，因为答案要求不同排列算不同的组合，可以重复计入。因此DFS探索的时候，每次可以从头遍历取数。
然后，dfs函数显然应该用"剩余多少值"作为传入的参数，那么遍历过程中一旦某个数字大于剩余值，就可以直接break。当然为了做到这点要先排序。

### 解法2 DP
如果要求输出的答案中不同排列只能算一个答案，那么这道题就是一个 完全背包 + 恰好装满容量 的背包问题。

不过题设不同，因此就不能这么做了。
换个思路，其实如果target是`n-1`时有`k`种做法的话，假如`1`在nums中，那么target为`n`时显然可以直接加上k。表示将一个1插入到`n-1`时k中做法的末尾。

于是，DP的思路出来了。DP数组`dp[i]`定义为target是`i`时有多少种方案。
从左到右扫描，需要确定`dp[i]`时，遍历`for j in range(i)`，状态转移方程：
```python
if (i - j) in nums:
    dp[i] += dp[j]
```
以上。

#### 一个小优化
上次给出的代码其实性能表现是比较差的，一个重要的点就在于，内层循环我采用了 `for j in range(i)` 的形式，
这就导致从1开始的所有数字都会被遍历，而且每次都要计算差值是否存在于 nums 中。

实际上可以立足于 nums 出发遍历，计算 `for num in nums` 中的 `i - num` 是否大于0即可。只要其大于等于0，就说明
`i - num` 这个值是一个合法的 `j` 值，可以 `dp[i] += dp[i - num]`。