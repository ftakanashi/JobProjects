## 题目描述
把字符串 s 看作是 “abcdefghijklmnopqrstuvwxyz” 的无限环绕字符串，所以 s 看起来是这样的：

"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd...." . 

现在给定另一个字符串 p 。返回 s 中 唯一 的 p 的 非空子串 的数量 。 

示例1:
```
输入: p = "a"
输出: 1
解释: 字符串 s 中只有一个"a"子字符。
```
示例 2:
```
输入: p = "cac"
输出: 2
解释: 字符串 s 中的字符串“cac”只有两个子串“a”、“c”。.
```
示例 3:
```
输入: p = "zab"
输出: 6
解释: 在字符串 s 中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。
```

提示:
```
1 <= p.length <= 105
p 由小写英文字母构成
```

### 解法 DP
看了这题思考了一会儿，我也想是不是得用DP。
但是我想到的思路是进行双字符串start - end形式的DP，然后对角线方向遍历来着…

不过很可惜，看了数据限制是10^5，如果DP起来那就要10^10的复杂度了，gg。
于是看答案，然后大呼巧妙。

根据题意，其实对于p中的某个是环绕字符串的子字符串的片段而言，其可以贡献多少数字给答案，只要知道其长度就行了。
所以一次遍历应该也能做。

而如果套用DP的思路，我可以认定这个片段的末尾。
即如果片段的末尾固定是某个字母的话，只要其满足其和前一个字母是连续关系，那么就有`dp[i] = dp[i-1] + 1`的递推公式了。

然而这道题更加麻烦一点的地方在于，他还要求唯一的子字符串，即比如示例2中的`c`，是只能算一次的。
于是，我们从根据p的长度开辟DP数组改成用26个字母开辟DP数组。(实际实现中我们采用了哈希表而不是数组，这样可以通过字符更快找到DP值)
然后遍历p，同时维护一个当前位置为末尾时的最长连续子字符串的长度`length`。
当当前字符和前一个字符有连续关系时，让`length += 1`然后将递推公式改成如下形式：
`dp[p[i]] = max(length, dp[p[i]])`

相反若没有连续关系，则需要将`length`重置为1。

最后我们只需要再不重复地遍历一次p中所有字符，然后求出所有`dp[ch]`的和，即为答案。

具体见代码吧，写的很清楚了。