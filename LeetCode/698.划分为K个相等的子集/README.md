## 题目描述
给定一个整数数组  nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。

示例 1：
```
输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4
输出： True
说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。
```
示例 2:
```
输入: nums = [1,2,3,4], k = 3
输出: false
```

提示：
```
1 <= k <= len(nums) <= 16
0 < nums[i] < 10000
每个元素的频率在 [1,4] 范围内
```

### 解法 记忆化DFS
题目的意思很好理解，思路也很好想到，暴力搜索就完了。
另外，使用位图来保存数字的使用情况还可以轻松接入记忆化，会让整体代码运行效率更高。

具体的，首先我们可以做一些前置计算。比如假设可以划分，那么划分出来的每个子集的和是多少，也就是`mean = sum(nums) / k`的值。
若这个值是小数则肯定gg。
另外如果数组中有数字大于这个值，那么也是gg。

排除以上两种情况后，进行dfs。
构建dfs函数`dfs(curr, used)`。
`curr`表示当前正在收集的子集的总和。而`used`使用位图表示的每个数字的使用情况（因为题目限制了数字最多也就16个）

当进入dfs后，如果`used == 2**n - 1`即每个数字都被使用，且`curr == mean`，那么可以跳出递归并返回True，否则返回False。
之后，我们遍历并尝试将每个`num`加入当前子集。

显然，若`curr`已经等于`mean`，相当于当前自己已经符合条件，所以可以直接进行`dfs(num, used | (1 << i))`。
另外，还有若`curr + num <= mean`时，则可以继续给子集加码，即`dfs(curr + num, used | (1 << i))`。

以上两条分支，只要有一条能走通，那么就可以向上返回True。
否则就返回False。

按照以上逻辑写代码即可。