## 题目描述
给你一棵以 root 为根的 二叉树 ，请你返回 任意 二叉搜索子树的最大键值和。

二叉搜索树的定义如下：

任意节点的左子树中的键值都 小于 此节点的键值。
任意节点的右子树中的键值都 大于 此节点的键值。
任意节点的左子树和右子树都是二叉搜索树。

示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_1_1709.png)
```
输入：root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]
输出：20
解释：键值为 3 的子树是和最大的二叉搜索树。
```
示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_2_1709.png)
```
输入：root = [4,3,null,1,2]
输出：2
解释：键值为 2 的单节点子树是和最大的二叉搜索树。
```
示例 3：
```
输入：root = [-4,-2,-5]
输出：0
解释：所有节点键值都为负数，和最大的二叉搜索树为空。
```
示例 4：
```
输入：root = [2,1,3]
输出：6
```
示例 5：
```
输入：root = [5,4,8,3,null,6,3]
输出：7
```

提示：
```
每棵树有 1 到 40000 个节点。
每个节点的键值在 [-4 * 10^4 , 4 * 10^4] 之间。
```

### 解法 DFS
一个比较简单的hard。
树的题，一眼DFS。关键在于设计的dfs函数该返回什么。

具体到这题，对于一个根节点来说，首先是得知道题目要求的内容，也就是这个树的所有节点的和。
其次，只有当这个子树是一个BST的时候才行，而结合左右子树的BST性，易得，
当左子树是BST，且右子树是BST，且左子树的最大值小于当前节点值，且右子树的最小值大于当前节点值时，当前子树是一个搜索树。

上面就是dfs函数中最核心的判断部分了。
由于用到了子树中的最大/最小值，所以最终我设计的dfs函数会有四个返回值，`bst, min, max, sum`。
分别表示当前子树是否是BST，当前子树的最小值，当前子树的最大值，当前子树的值总和。

dfs的边界可以设置成空节点，返回`True, INF, -INF, 0`，这样可以适配整个递归流程。

具体也没啥可说的，看代码吧。