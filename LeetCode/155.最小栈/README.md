## 题目描述
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。

pop() —— 删除栈顶的元素。

top() —— 获取栈顶元素。

getMin() —— 检索栈中的最小元素。

示例:
```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

提示：
- pop、top 和 getMin 操作总是在 非空栈 上调用。

### 解法1 基于堆
这题有点意思。首先思路非常明确，数据体中应该有一个stack作为主要数据结构。
这样就可以应付push,pop,top三个方法了。问题在于如何实现getMin了。显然需要
以空间换时间，即采用辅助数据结构来实现。

看到要求常数时间内获取最小值，最先想到的是用堆。
但是用堆的问题就在于，如果某次stack pop出的恰好是最小值，那么相应堆里也需要pop出最小值。
剩余部分则需要为了维持堆序进行重排，这么一来时间就O(logn)了。

同理，本来栈的push操作是O(1)的，但是为了同时维护堆，所以也会变成O(logn)。

虽然不符合题意…但是姑且写了一下。

### 解法2 辅助栈
示例中，-2入栈此时min是-2；0入栈此时min还是-2；-3入栈此时min变成了-3。

因此一个自然的想法是维护一个min变量，当有更小的数入栈时修改其为最小的数即可。

但是这样做法的问题在于，一个min变量是没有记忆的，比如上述示例操作，当把-3pop掉之后，此时min应该是-2，但是我无从得知。
如果不使用其他空间，那么只能从头扫描一遍stack了，这就没有意义了。

正确的姿势是，通过一个辅助栈实现"记忆"。

辅助栈中保存的，是每个数字入主栈后，主栈中的最小值。
即，如果示例中主栈是`-2 0 -3`的话，那么辅助栈里就是`-2 -2 -3`。

辅助栈的栈顶永远是getMin的结果，并且当-3被pop掉，辅助栈同步变化，剩下栈顶变成-2，还是符合要求。

### 解法3 保存差
如果要求不能使用额外的空间，该怎么办。

这种方法更加巧妙，他在栈中并不保存原数，而是保存数字减去当前最小值的差值。

还是上面示例，在这个方法中，栈内应该是`0, 2, -1`。

另外，当栈入一个负值的时候，说明这个数比当前最小值更小，因此还要更新当前最小值。

这样的一个栈，
如果要push，那么push差值并查看是否有更新最小值的可能性。
如果要top，那么看栈顶是否小于等于0，如果是则返回当前最小值，否则返回栈顶加上当前最小值的和。
如果要pop，那么和top一样先确定栈顶本来的数字，然后别忘了更新最小值的可能性，即当栈顶小于0时，把他pop掉之后剩余的最小值应该是栈顶减去当前最小值。
如果要getMin，那么就直接返回维护的当前最小值即可。

上述方法，做到了只用了一个变量`min_value`实现了功能。