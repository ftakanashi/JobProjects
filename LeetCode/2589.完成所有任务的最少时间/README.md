## 题目描述
你有一台电脑，它可以 同时 运行无数个任务。给你一个二维整数数组 tasks ，其中 tasks[i] = [starti, endi, durationi] 表示第 i 个任务需要在 闭区间 时间段 [starti, endi] 内运行 durationi 个整数时间点（但不需要连续）。

当电脑需要运行任务时，你可以打开电脑，如果空闲时，你可以将电脑关闭。

请你返回完成所有任务的情况下，电脑最少需要运行多少秒。

示例 1：
```
输入：tasks = [[2,3,1],[4,5,1],[1,5,2]]
输出：2
解释：
- 第一个任务在闭区间 [2, 2] 运行。
- 第二个任务在闭区间 [5, 5] 运行。
- 第三个任务在闭区间 [2, 2] 和 [5, 5] 运行。
电脑总共运行 2 个整数时间点。
```
示例 2：
```
输入：tasks = [[1,3,2],[2,5,3],[5,6,2]]
输出：4
解释：
- 第一个任务在闭区间 [2, 3] 运行
- 第二个任务在闭区间 [2, 3] 和 [5, 5] 运行。
- 第三个任务在闭区间 [5, 6] 运行。
电脑总共运行 4 个整数时间点。
```

提示：
```
1 <= tasks.length <= 2000
tasks[i].length == 3
1 <= starti, endi <= 2000
1 <= durationi <= endi - starti + 1 
```

### 解法 贪心 二分查找
这算是一道相对比较简单的hard题。（虽然我没有自己想，直接看的答案…

这题的数据范围较小，直接暴力也可以做。

首先肯定要对 `tasks` 进行一次排序。按照惯例套路，此处选择基于区间的`end`由小到大排序。
这么做的好处是，可以确保从左到右遍历的过程中右边界是有序递增的。

遍历时我们维护一个run数组，用于表示某个时间点上是否开机执行任务。总长度为tasks排序后最后一个task的end+1（即可能出现的最大时间点）
当我们遍历到一个task（`start, end, duration`）时，只要 `start, end`闭区间内开机的时间点数量大于等于`duration`，这个task就符合要求了。
相反，如果是后者更大，就说明需要开机更多的时间点，具体的差值就是 `duration - sum(run[start: end+1])`。

至于具体开哪些时间点，可以考虑从后往前开，从而保证后面还没有被遍历到的task尽可能地可以利用这部分开机的时间点。

基于以上思路的算法大概是这样：
```python
from typing import List
class Solution:
    def findMinimumTime(self, tasks: List[List[int]]) -> int:
        tasks.sort(key = lambda task: task[1])
        run = [0 for _ in range(tasks[-1][1] + 1)]
        ans = 0

        for start, end, duration in tasks:
            duration -= sum(run[start : end+1])    # 扣除已经开机的时间点数量
            ans += max(duration, 0)
            if duration <= 0: continue    # 若duration<=0，说明已经满足了要求
            
            # 否则尽量找靠后的时间点开机
            for j in range(end, -1, -1):
                if not run[j]:
                    run[j] = True
                    duration -= 1
                if duration == 0: break
        
        return ans
```

以上代码能过，但是显然一个很大的缺点是对run区间求和耗费太多计算力了。

下面是一种基于二分查找的优化方案：

我们使用一个栈 `st` 替代run数组。`st`中的每一项我们表示为 `i, j, t`。其中，`i, j` 表示某个时间区间内所有时间点都开机执行任务。
而`t`表示时间走到`j`为止，已经开机的时间点总数。
这个栈，我们始终保持其基于 `i` 从小到大排序。

`st`的初始值为 `-1, -1, 0`。我们暂且不管如何给这个栈充入数据。
考虑遍历到 `tasks[i] = [start, end, duration]`时，
我们在`st`栈中二分查找时间区间比`start`小的最大的数据项 `st[k-1]`。（`k`是二分查找确定的下标

接着我们来确认 `start, end` 区间内已经确定的开了机的时间点数量。
首先是，`st[-1][2] - st[k-1][2]` 是其中的一部分。
另外一个比较难想到的点： 当 `start` 小于 `st[k-1][1]` 时，此两个数区间内开机的时间点也可以被当前任务用到，也需要算上。
（注意 `start > st[k-1][0]` 这是始终成立的，因为`st`是按照首项排序的。

如果以上两部分加起来后已经满足了 `duration`，那么就不用再增加额外的开机的时间点。

否则，需要额外增加开机时间点。
而这个增加时间点的操作整体思想上和上面的暴力解法类似，只不过现在需要依托 `st` 这个数据结构去做。
具体的，我们以当前task的end，即 `tasks[i][1]` 为end，把栈从后往前扫描，将扫描到的区间start即 `st[i][0]` 为start。
这两个 start 和 end 区间内的所有点去除已经开机的点，剩余的点逐个开机。

最终可以形成一个新的数据项，充入栈中即可。

以上优化后的思路见代码。
