## 题目描述
有一组 n 个人作为实验对象，从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 x 的人简称为 "person x "。

给你一个数组 richer ，其中 richer[i] = [ai, bi] 表示 person ai 比 person bi 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。richer 中所给出的数据 逻辑自恰（也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更有钱的情况 ）。

现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是，在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。

示例 1：
```
输入：richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]
输出：[5,5,2,5,4,5,6,7]
解释： 
answer[0] = 5，
person 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。
唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，
但是目前还不清楚他是否比 person 0 更有钱。
answer[7] = 7，
在所有拥有的钱肯定不少于 person 7 的人中（这可能包括 person 3，4，5，6 以及 7），
最安静（有较低安静值 quiet[x]）的人是 person 7。
其他的答案也可以用类似的推理来解释。
```
示例 2：
```
输入：richer = [], quiet = [0]
输出：[0]
```
提示：
```
n == quiet.length
1 <= n <= 500
0 <= quiet[i] < n
quiet 的所有值 互不相同
0 <= richer.length <= n * (n - 1) / 2
0 <= ai, bi < n
ai != bi
richer 中的所有数对 互不相同
对 richer 的观察在逻辑上是一致的
```

### 解法 DFS
题目着实有点拗口…
简单来说，你有n个节点，称之为`node_i`吧。
而每个节点又有一个安静值，称之为`q_i`。

节点之间互相组成了一个无环有向图。（若有环则无法满足题目说的逻辑自洽的要求
并且`q_i`是`range(n)`的一个排列，即互相之间互不相同。

现在要求的，是对于任意一个节点`node_i`，必然有一些节点可以沿着图的边到达它。在这些节点中，有一个节点`node_x`有最小的`q_i`。
而返回的答案数组`ans`中的`ans[i]`就是写`node_x`。
对于一些末端节点，`ans[i]`就是他自己。

其实上述解释已经开始了一部分解题的思路了。原生题目可能会有更多方向的解法。
这里，沿着这个思路继续往下走。

很自然的，我们想到从一个节点`node_i`开始，沿着图的边dfs搜索，其搜索到的所有后续节点的`x`都有可能是`node_i`。
至于可不可能，取决于当前后续节点保存的安静值是否小于`node_i`的节点值。
如果小于则不变，如果大于，则更新。

于是，思路自然出现了。
定义一个dfs函数，让其从某个特定节点开始扫描，并且带上这个节点的安静值。
扫描过程中，碰到所有能够到达的后序节点，如果后序节点当前保有的最小安静值没有这轮扫描带来的安静值更小，就更新之。

反之，当扫描到某个节点的当前保有安静值已经更小，说明从这个后序节点开始以及其之后的所有节点，都无需继续扫描了。因为已经有了更小的候选项。
此时可以直接跳过。

描述起来有点难懂，建议直接看代码注释。

顺便一提，这题天然给出了有向无环图，似乎在疯狂暗示用拓扑排序做。
看了眼官方答案确实也有用拓扑排序的做法，粗看一眼好像和我的也差不多，就没深究了。