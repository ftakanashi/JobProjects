## 题目描述
你和朋友玩一个叫做「翻转游戏」的游戏。游戏规则如下：

给你一个字符串 currentState ，其中只含 '+' 和 '-' 。你和朋友轮流将 连续 的两个 "++" 反转成 "--" 。当一方无法进行有效的翻转时便意味着游戏结束，则另一方获胜。默认每个人都会采取最优策略。

请你写出一个函数来判定起始玩家 是否存在必胜的方案 ：如果存在，返回 true ；否则，返回 false 。
 
示例 1：
```
输入：currentState = "++++"
输出：true
解释：起始玩家可将中间的 "++" 翻转变为 "+--+" 从而得胜。
```
示例 2：
```
输入：currentState = "+"
输出：false
```

提示：
```
1 <= currentState.length <= 60
currentState[i] 不是 '+' 就是 '-'
```

### 解法 DFS
这题通过一些博弈论的理论似乎可以有很简洁的做法。

不过我不懂这么高端的，所以就暴力DFS做吧。
DFS做的话很简单，在dfs函数内，扫描当前的state，碰到两个连续的++，就尝试将其变成--，然后开启下一步dfs。

每个dfs函数开始时是谁在先手这点还是蛮搞的。
为了理清楚这个逻辑，我们需要紧紧抓住，dfs函数返回的，就是当前state下当前操作的玩家是否有必胜方法。若有就返回True，否则False。

在最上层的dfs，显然我们直接`return dfs(currentState)`就是最终需要的答案。
而在dfs函数体中，大概会有这么一个调用：`dfs(newState)`。
这是玩家切换。不论当前玩家是谁，又切换成了谁，这个调用返回的意义就是，在`newState`的前提下，
切换后的玩家是否有必胜方案。

若有，那么对于当前玩家来说，就是输。但是`newState`只是我们在`currentState`操作的一种可能，不着急直接下结论，可以继续扫描。
若无，则说明在`newState`下，另一位玩家无论如何也无法取胜，我们可以直接返回True了。
以上逻辑全程没有触及到底谁是我，谁是朋友，因此无需考虑这方面因素。

考虑到dfs函数参数是一个不可变的字符串且未使用外部的信息，所以直接无脑加上cache。