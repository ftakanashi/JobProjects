## 题目描述
给你一个整数数组 nums ，你可以对它进行一些操作。

每次操作中，选择任意一个 `nums[i]` ，删除它并获得 `nums[i]` 的点数。
之后，你必须删除每个等于 `nums[i] - 1` 和 `nums[i] + 1` 的元素。

开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

示例 1：
```
输入：nums = [3,4,2]
输出：6
解释：
删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。
```
示例 2：
```
输入：nums = [2,2,3,3,3,4]
输出：9
解释：
删除 3 获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数。
```

提示：
```
1 <= nums.length <= 2 * 104
1 <= nums[i] <= 104
```

>注：原题描述中写的是删除`nums[i]-1`"或"`nums[i]+1`。但是实际看了示例之后就知道，其实是"和"。
>这里我已经修改了。

### 解法 DP
这题一看就觉得可以用DFS做，但是最近DP有点上头，就决定用DP试试。

这题的DP数组定义没有那么明显。但是经过写写画画之后，发现了取某个数的过程中的一些规律。
比如，当有复数个`n`存在时，其实这些数可以当做一个整体来处理。

比如示例2中有3个3，当我决定取其中任何一个的时候，由于其他几个3也都还在，不影响，因此根据贪心法则，为了获得最大的点数，可以直接在结果上加上9。
这样，数字的个数相对来说就是一个没有那么要紧的属性了。
于是我们就可以集中注意力于数字本身。

另外，只要是不互相互斥的数字，在决定两者都取的情况下，先取谁后取谁对于最终得分来说是一样的。
因此，不妨从小到大取。

在半确信半猜的状态下，尝试写了一下DP数组和状态方程。
以示例2为例。首先我们获取到这个数组的counter:`{2:2, 3:3, 4:1}`。
接着按key排序可以得到所有数字的种类即`num_keys = [2, 3, 4]`。以数字种类的长度为依据初始化DP数组。然后从2开始从小到大扫描。
DP数组`dp[i]`保存的是，在从小到大扫描的过程中，扫描到数字种类`dp[i]`时，我能够得到的最大分数。

首先`dp[0]`肯定是`2*2=4`。接着，之后的每个`dp[i]`，其实可以先查看`nums_keys[i-1]`是否是`nums_keys[i] - 1`。
如果不是，则可以沿用`dp[i-1]`作为基准值。如果是，则只能使用`dp[i-2]`作为基准值。（当然还得要求`i > 1`）。
有了基准值之后，可以加上`num_keys[i] * counter[num_keys[i]]`计算得到如果取当前数字种类`nums_key[i]`，可得到的最大分数。
同时别忘了说不定沿用`dp[i-1]`可以得到更大的值（比如示例2的扫描到4的时候，此时`dp[3]`是9，但是`4 * 1 + 4`只是8。

根据上述状态转移方程填完整个dp表，最后寻找dp表中的最大值即可。

当然，按惯例，整个DP还可以优化空间。
因为推导过程中`dp[i]`只取决于`dp[i-1]`和`dp[i-2]`，自然安排两个变量保存前两个dp值，同时随时记录整个过程中的最大值即可。

按惯例，代码注释中给出了非压缩的版本。