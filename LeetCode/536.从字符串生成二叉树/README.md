## 题目描述
你需要用一个包括括号和整数的字符串构建一棵二叉树。

输入的字符串代表一棵二叉树。它包括整数和随后的 0 、1 或 2 对括号。整数代表根的值，一对括号内表示同样结构的子树。

若存在子结点，则从左子结点开始构建。


示例 1:

![](https://assets.leetcode.com/uploads/2020/09/02/butree.jpg)
```
输入： s = "4(2(3)(1))(6(5))"
输出： [4,2,6,3,1,5]
```
示例 2:
```
输入： s = "4(2(3)(1))(6(5)(7))"
输出： [4,2,6,3,1,5,7]
```
示例 3:
```
输入： s = "-4(2(3)(1))(6(5)(7))"
输出： [-4,2,6,3,1,5,7]
```

提示：
```
0 <= s.length <= 3 * 104
输入字符串中只包含 '(', ')', '-' 和 '0' ~ '9' 
空树由 "" 而非"()"表示。
```

### 解法 栈
这题一看就知道用栈或者递归的方法来做。
递归的话需要知道某个表示树的字符串，其中的两个子树的分界点，除了扫描一遍，暂时没想到立马就能实现出来的办法，所以用了栈。

另外这题题意有点模糊不清，补充一些信息。
这题保证输入的树其中每个子树若只有一个子节点，那么优先将其视作左子节点。
换言之，如某个树形如`x(y)`，那么y一定是x的左子节点。
再换言之，不存在形如`x()(y)`这样的输入。

这就好办很多了。

建立一个栈后，挨个扫描字符。
当碰到数字时，自然是无脑累计数字即可。

碰到左括号时，此时有两种情况。
第一，该左括号后面跟着的内容是左括号前面的数字作为根节点的左子树。此时一定有累计过的数字非空，此时将其作为根节点创建起来，
并且加入栈即可。
第二，该左括号和面的内容是一个右子树，换言之该左括号前面一个字符是右括号。此时可以直接略过。

碰到右括号时，也有两种情况。
第一，累计数字非空，说明此时该右括号为边界的节点还未创建，我们就创建一个新节点出来。
第二，累计数字为空，这种情况说明了该右括号是一连串右括号中非首个的一个。此时无需创建新节点。
针对右括号，由于其表示某个子树已经扫描完毕，需要考虑将这个子树如何和已经创建出来的树结构整合起来。
具体的，对于第一种情况，我们可以将新创建出来的节点尝试拼接到当前栈顶的根节点的左或者右子树上。具体是作为左还是右子树，就看那个根节点左子树是否为空了。
针对第二种情况，并没有新节点，而是当前栈顶的节点可以作为左或者右子树拼接到更高层级（栈更深处）的根节点上去。同理，是左还是右看根节点的左子树情况。

按照以上逻辑，挨个写出if else，一步步往前走就是了。

最后别忘了两种特殊情况，输入字符串为空，或者没有任何括号，表示单节点。