## 题目描述
给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

示例:
>输入: [2,3,1,1,4]
>
>输出: 2
>
>解释: 跳到最后一个位置的最小跳跃数是 2。
>    
>从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

说明:
- 假设你总是可以到达数组的最后一个位置。


### 解法1 DP
这题一看就可以用DP做。
于是构建dp数组，保存到达每个位置时最小跳跃次数。显然`dp[0]=0`，其他值初始化为无穷大。

接着，最开始我想的是从左向右扫描，依次更新每个位置可以达到的位置的dp值。
比如，`2 3 1 1 4`中，先扫描到2，其下标为0。则对下标1，下标2的dp值进行`dp[i] = min(dp[i], dp[0]+1)`。以此类推。

不过显然，这个做法是O(n^2)，超时了。

然后想到，其实对于扫描完2，扫到3的时候来说，虽然3也可以到达下标2的1，但是跳跃次数为2，肯定大于1。更一般的，
对于下标i处数组值为j的位置来说，`i~i+j`部分的dp值一旦确定，从`i+1`开始跳跃到`i+2~i+j`这部分的路径是没必要考虑的。

而且因为dp是从左到右依次扫描，左边的dp值总是小于等于右边的，因此上述讨论中也没必要考虑`dp[i] > dp[i+1]`的情况。因此是严格成立的。

于是就有了第一个算法。
从左到右扫描时，位置`i`的如果值是`j`，那么`dp[i+1:j+1]`的值可以确定，并且将已经确定值的边界更新为`j+1`。

接着扫描位置`i+1`，如果其数组值是`k`，此时确定dp值时直接考虑`dp[j+1:k+1]`，开头是`j+1`而不是`i+2`。

当某一天，`dp[n-1]`即最后一个位置的dp值确定后，可直接返回，因为不可能会有比这更小的值在此之后出现了。

### 解法2 纯贪心
暂时没看太明白，有时间再补