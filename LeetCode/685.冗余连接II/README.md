## 题目描述
在本问题中，有根树指满足以下条件的 有向 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。

输入一个有向图，该图由一个有着 n 个节点（节点值不重复，从 1 到 n）的树及一条附加的有向边构成。附加的边包含在 1 到 n 中的两个不同顶点间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组 edges 。 每个元素是一对 [ui, vi]，用以表示 有向 图中连接顶点 ui 和顶点 vi 的边，其中 ui 是 vi 的一个父节点。

返回一条能删除的边，使得剩下的图是有 n 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。

示例 1：

![](https://assets.leetcode.com/uploads/2020/12/20/graph1.jpg)
```
输入：edges = [[1,2],[1,3],[2,3]]
输出：[2,3]
```
示例 2：

![](https://assets.leetcode.com/uploads/2020/12/20/graph2.jpg)
```
输入：edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]
输出：[4,1]
```

提示：
```
n == edges.length
3 <= n <= 1000
edges[i].length == 2
1 <= ui, vi <= n
```

### 解法 并查集 + 细致的细节分析
这题是`LC.684`的变体，难度提升了不少…
因为看了十分钟感觉自己是做不出来了 一点思路都没有…所以就直接抄答案了。

首先提一点，因为题目说了这个数据结构是一个树+一条额外的边，而一个n个节点的树有n-1条边，是树的性质，所以输入的边数等于n。
这样n就知道了。

接着，我们沿用`LC.684`的思路，从左到右扫描各个边，试图构建起这个树。

构建过程中，由于额外边的存在，可能会扫描到某个边后，发现数据结构不再是树了。这无非是两点可能性：
1. 扫描到`(u, v)`边时，`v`节点有了两个父节点，这是不符合树定义的。
2. 扫描到`(u, v)`边时，在加入这条边之前，`u`和`v`就已经处于同一个连通分量，换言之加入边后成环，也不符合树的定义。

我们将上述两种引起错误的边分别称为"冲突边"和"成环边"。
至于如何检测两者，其实很好解决。
构建树过程中维护一个parent数组实时记录每个节点的父节点，就可以检测到冲突边；
而模仿684，用并查集就可检测成环边。

问题是，当检测到冲突或者成环边时，就行了吗？没那么简单。
因为有些例子既有冲突边又有成环边。到底如何取舍，是个复杂的问题。

而细节的分析，具体来说可以按下面这样来做（这也是打死我都想不出来的部分……

根据冲突边和成环边是否存在，总共有三种可能的情况
1. 有冲突边，无成环边，如示例`[[1,2], [1,3], [2,3]]`
2. 无冲突边，有成环边，如示例`[[1,2], [2,3], [3,1]]`
3. 有冲突边，有成环边，如示例`[[1,2], [2,3], [3,1], [4,2]]`

讨论如下：

第二种情况，当无冲突边时，环路边因为也肯定是访问到的形成环路的最后一条边，所以他就是多余的边，可以直接返回。

第一种情况，无成环边时，理论上两个冲突的边去掉哪个都行，因为我们从左到右遍历读取的各个边，所以冲突边是符合题意要求的尽量靠右的那个，直接返回。

麻烦的第三种情况，冲突边和成环边都有时，如果考虑去掉冲突边，那么环解不开。如果考虑去掉成环边，那么冲突无法消解。
事实上，只能考虑去拆除了成环边外，环中的另一条边。因为还要估计冲突消解，所以应该要拆另一条指向了冲突边指向节点的边。
换言之，若此时冲突边是`(u, v)`。那么应该拆去的边是`(parents[v], v)`。
结合示例看一下就明白了。

思路到这里就梳理清楚了。接下来编码就不复杂了。