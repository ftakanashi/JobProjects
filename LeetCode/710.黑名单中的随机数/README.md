## 题目描述
给定一个整数 n 和一个 无重复 黑名单整数数组 blacklist 。设计一种算法，从 [0, n - 1] 范围内的任意整数中选取一个 未加入 黑名单 blacklist 的整数。任何在上述范围内且不在黑名单 blacklist 中的整数都应该有 同等的可能性 被返回。

优化你的算法，使它最小化调用语言 内置 随机函数的次数。

实现 Solution 类:
```
Solution(int n, int[] blacklist) 初始化整数 n 和被加入黑名单 blacklist 的整数
int pick() 返回一个范围为 [0, n - 1] 且不在黑名单 blacklist 中的随机整数
```

示例 1：
```
输入
["Solution", "pick", "pick", "pick", "pick", "pick", "pick", "pick"]
[[7, [2, 3, 5]], [], [], [], [], [], [], []]
输出
[null, 0, 4, 1, 6, 1, 0, 4]

解释
Solution solution = new Solution(7, [2, 3, 5]);
solution.pick(); // 返回0，任何[0,1,4,6]的整数都可以。注意，对于每一个pick的调用，
                 // 0、1、4和6的返回概率必须相等(即概率为1/4)。
solution.pick(); // 返回 4
solution.pick(); // 返回 1
solution.pick(); // 返回 6
solution.pick(); // 返回 1
solution.pick(); // 返回 0
solution.pick(); // 返回 4
```

提示:
```
1 <= n <= 109
0 <= blacklist.length <= min(105, n - 1)
0 <= blacklist[i] < n
blacklist 中所有值都 不同
 pick 最多被调用 2 * 104 次
```

### 解法 随机数映射
一般看到这类带类黑名单机制的随机数问题时，第一个能想到的简单有效的办法是拒绝采样。
然而这题的数据范围很大，blacklist的限制最大又能到`n-1`，如果某个例子的黑名单长度是`n-1`的话那么拒绝采样的概率会很高。

这题用了另一种别出心裁的做法。

面对一个数据范围`range(0, n)`，如果恰好所有黑名单都处于`n-m, n`之间，那么只需要在`range(0, n-m)`中随机取值就可以得到结果。
而由于黑名单数据可能是散落在数据范围的各处，因此可以通过一个手工的映射将非上述范围中的数字都映射到范围中去。

具体的，先确定黑名单范围`range(n-m, n)`，由于黑名单长度和`n`都是固定的，因此这个范围也是固定的。
然后遍历所有黑名单数，若其大于等于`n-m`，说明其本身就位于上述黑名单范围内，不管即可。
若其小于`n-m`，那么将其映射到`range(n-m, n)`中某个白名单数上。如何找到一个合适的白名单数，可以简单地通过一个指针搞定。
映射具体可以是一个哈希表。

最终，我们必然可以将所有黑名单数恰好映射到`range(n-m, n)`范围中。

接下来pick就简单了。
在`range(0, n-m)`间随机取数。若这个数是哈希表中的某个key，说明其是一个小于`n-m`的黑名单数，
而返回映射后的白名单数，否则就直接返回这个数即可。