## 题目描述

给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

示例 1：
![](https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg)
```
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：6
解释：最大矩形如上图所示。
```
示例 2：
```
输入：matrix = []
输出：0
```
示例 3：
```
输入：matrix = [["0"]]
输出：0
```
示例 4：
```
输入：matrix = [["1"]]
输出：1
```
示例 5：
```
输入：matrix = [["0","0"]]
输出：0
```

提示：
```
rows == matrix.length
cols == matrix[0].length
0 <= row, cols <= 200
matrix[i][j] 为 '0' 或 '1'
```

### 解法 最小栈+每列作为底边的最大矩形扫描
这题乍一看以为比较简单，是普通的DFS或者DP。
但是仔细一品发现还是有点难度的。

简单来说，以上面的例子为例，如果以最右列作为底边，求这个一定包括这个底边的最大矩形的话，这个问题其实就退化成了
`LC84.柱状图中的最大矩形`问题。

这个问题的解法我们知道了，是用最小栈分别求出某个柱子其左边和右边第一个比其更矮的柱子的位置，然后长宽乘一下。

可是这还不够，如果最大矩形不和最右列沾边呢？
说明我们要从右到左一列一列扫描，把每一列作为底边。

那么把一列作为底边的时候，输入给处理`LC84`问题的函数的数组应该是什么，应该是当前这列每个单元格，其本身+左边连续1的个数（即柱子高度）。
这个还是很好求的，比如上面例子转变后应该变成：
```text
1 0 1 1 0
1 0 1 2 3
1 2 3 4 5
1 0 0 1 0
```

得到这个矩阵后按照刚才说的，从右到左扫描各列，即可。