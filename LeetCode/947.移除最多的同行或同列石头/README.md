## 题目描述
n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。

如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。

给你一个长度为 n 的数组 stones ，其中 stones[i] = [xi, yi] 表示第 i 块石头的位置，返回 可以移除的石子 的最大数量。

 

示例 1：
>```
>输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
>输出：5
>解释：一种移除 5 块石头的方法如下所示：
>1. 移除石头 [2,2] ，因为它和 [2,1] 同行。
>2. 移除石头 [2,1] ，因为它和 [0,1] 同列。
>3. 移除石头 [1,2] ，因为它和 [1,0] 同行。
>4. 移除石头 [1,0] ，因为它和 [0,0] 同列。
>5. 移除石头 [0,1] ，因为它和 [0,0] 同行。
>石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。
>```

示例 2：
>```
>输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
>输出：3
>解释：一种移除 3 块石头的方法如下所示：
>1. 移除石头 [2,2] ，因为它和 [2,0] 同行。
>2. 移除石头 [2,0] ，因为它和 [0,0] 同列。
>3. 移除石头 [0,2] ，因为它和 [0,0] 同行。
>石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行/列。
>```

示例 3：
>```
>输入：stones = [[0,0]]
>输出：0
>解释：[0,0] 是平面上唯一一块石头，所以不可以移除它。
>```

提示：
- 1 <= stones.length <= 1000
- 0 <= xi, yi <= 104
- 不会有两块石头放在同一个坐标点上

### 解法 并查集
乍一看还以为这道题是要用贪心，来实际模拟去除石头的过程。

但是注意到，其实题目并没有要求给出具体移除石头的步骤，而是只要求出最多移除，换句话说最后能留下几个石头而已。

那么显然，在图中，所有同行同列以及可以通过同行同列跳转的两块石头不能共存。

也就是说求的是，最终能留下"几组"石头，显然用并查集就完了。组，就是图中的连通分量。

第一版代码，采用比较朴素的思想，两轮循环遍历了所有石头，如果石头互相之间有同行或者同列，那么直接合并联通分量。

虽然能通过，但是耗时整体较长。

看了答案之后，发现了一轮循环就能解决的办法。

由于实质上我们并不需要给出剩余点是哪些这种具体信息，所以可以基于坐标的角度来构建联通分量。

比如一个点`0,0`，那么将其横坐标和纵坐标（为了区别两者，分别写作x0和y0）构成连通分量`x0 - y0`。

当出现一个新点`0,1`，显然连通分量扩展成`y1 - x0 - y0`。

此时再来一个新点`2,2`，连通分量扩展成两个：
```text
y1 - x0 - y0
x2 - y2
```

换言之，基于坐标构建的连通分量个数，其实和以基于各个石头构建的联通分量个数是一致的。
对这道题要求的东西而言，前者可以给出正确答案，同时只需要O(n)的遍历，因此更好。

最后，为了实现基于坐标的连通分量构建，还有一个问题，就是如何区别横纵坐标的数字。毕竟这里的x0y0只是表示上的不同，具体代码里如何区分是个问题。
一个简单的办法，结合题目条件坐标最大只到9999，那就让每个纵坐标+10000，这样横纵坐标就区分开了。

因为绝对值变挺大了，所以建议用哈希表实现并查集。