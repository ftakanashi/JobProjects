## 题目描述
给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。

整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x

示例 1：
>输入：n = 16
>
>输出：true

示例 2：
>输入：n = 5
>
>输出：false

示例 3：
>输入：n = 1
>
>输出：true
 

提示：
- -2^31 <= n <= 2^31 - 1

### 解法1 位运算
负数不用考虑，没有什么特别的限制。
所以简单解法很简单，比如从0开始递增i，计算pow(4,i)，然后比较和n的大小即可。

对于pow函数，可以参考`LC50.pow(x,y)`。

这里说一个稍微有意思一点的解法。位运算。

注意到每个4的幂的二进制形式，其特点就是，整个数里只有一个1，并且这个1处于从右到左的奇数位置上，如
```
1   1
4   100
16  10000
```
按照这个思路写代码。

### 解法2 掩码
以上解法1比较沙比，写的时候还是太年轻…

其实很简单，既然n是一个4的幂，那么其二进制表达中肯定只有一个1其余全是0，即`n & (n-1) == 0`。

另一方面，正如解法1中提到的，这个1还得出现在奇数位置上；换言之，其后面的0的个数是偶数。为了判断这个，上面做法一个一个位置扫描，
显然这略嫌麻烦。

由于规定输入数是标准的32位int数，所以在保证二进制有且仅有1个1时，判断其位置只要将其与
`010101...0101`进行与运算，看结果是否大于0即可。这个数是个mask，也可以写成`0x55555555`。

### 解法3 取余
基本思路同解法2。
只是在判断1的位置是否符合要求时，注意到，任意一个4的幂都可以写成：
```text
4^x = (3 + 1)^x = 3^x + C(x,x-1) * 3^(x-1) + ... + C(x,1) * 3 + 1
```
上式用了多项式公式展开。展开后发现，4的幂对3取余总是余1。
另一方面，那些不是4的幂却是2的幂的数，即在确保二进制表达只有一个1后扔需过滤掉的那些数，可以写成`4^x * 2`，
套用上式可得最终肯定是余2，因此对3取余是否等于1也可以用作一个判断条件

以上解法2和解法3都一步直接判断是否符合要求，避免了一个一个位扫描。