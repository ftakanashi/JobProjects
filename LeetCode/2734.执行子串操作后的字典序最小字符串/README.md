## 题目描述
给你一个仅由小写英文字母组成的字符串 s 。在一步操作中，你可以完成以下行为：

选择 s 的任一非空子字符串，可能是整个字符串，接着将字符串中的每一个字符替换为英文字母表中的前一个字符。例如，'b' 用 'a' 替换，'a' 用 'z' 替换。
返回执行上述操作 恰好一次 后可以获得的 字典序最小 的字符串。

子字符串 是字符串中的一个连续字符序列。

现有长度相同的两个字符串 x 和 字符串 y ，在满足 x[i] != y[i] 的第一个位置 i 上，如果  x[i] 在字母表中先于 y[i] 出现，则认为字符串 x 比字符串 y 字典序更小 。

示例 1：
```
输入：s = "cbabc"
输出："baabc"
解释：我们选择从下标 0 开始、到下标 1 结束的子字符串执行操作。 
可以证明最终得到的字符串是字典序最小的。
```
示例 2：
```
输入：s = "acbbc"
输出："abaab"
解释：我们选择从下标 1 开始、到下标 4 结束的子字符串执行操作。
可以证明最终得到的字符串是字典序最小的。
```
示例 3：
```
输入：s = "leetcode"
输出："kddsbncd"
解释：我们选择整个字符串执行操作。
可以证明最终得到的字符串是字典序最小的。
```

提示：
```
1 <= s.length <= 3 * 105
s 仅由小写英文字母组成
```

### 解法 贪心
其实稍微想一下就可以想到一个贪心规律：
不难发现，对于大多数字母，将其往字母表前面移一位总是有益的。除了`a`。

所以我们可以将整个字符串中，最靠左的一部分（这部分子串中不能有`a`），全部做上述操作。

具体的，字符串可能是下面几种形式：
```text
xxxx...ayyy    开头没有连续的a，直接将x部分做操作即可
a..axxxa...    开头有连续的a，跳过这部分a之后将后面的连续没有a的xxx部分做操作
aaaaaa..a      整个字符串都是a，由于强制要求至少做一次操作，所以只能将最后一个a替换为z
```

只要覆盖上面三种情况，就是一个完备的答案了。
具体的则是在代码中通过双指针扫描即可，注意一些边界细节即可。
