## 题目描述

假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。

注意：
总人数少于1100人。

示例
>输入:
>
>[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
>
>输出:
>
>[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]


### 解法 模拟插值
如果只是单纯的身高排序，就没有难度。

问题就在于，如何控制好第二个数字，即前面有几个大于等于自己身高的人。

一时半会儿没有头绪的话，就直接在草稿纸上写写画画，看看有没有规律和思路。因为是人脑可以做出来的事情，所以最不济也可以用代码模拟人脑思考过程。

首先，这个题，在本地进行元素swap从而重建队列有点困难。况且也没说不能用额外空间，于是考虑一下如何在一个新的列表上重建。

如果单纯的从前往后扫描输入，然后依次把元素加入到新队列中合适的位置可以吗？
比如第一个7,0。显然可以放在任何位置。

第二个4,4，由于7比4大，相当于会变成7xxx4的样子，且每个空位x，都是大于等于4的。同时，如果x还小于7，
那么x7xx4之类的pattern也可以。这么一来就很复杂了。下一个7加入放在哪里好，完全不知道。

另一方面，如果不放入4,4，而直接跳到7,1。显然，他在7,0后面，这是可以确认的事情了。

再往后，5,0似乎也是可以确定位置的，放在第一位，此时身高序列是5,7,7。

再往后，6,1也可以确定位置，放在两个7中间即可。

再往后，5,2也可以确定位置，最终形成序列5,7,5,6,7。这时候如果再放4,4，就可以确定了。**反过来说，因为4是最小的身高，所以当所有大于4的都正确排序
了的话，那么4,4也就只要插入到第5个即可。**

最终重建了队列5,7,5,6,4,7。

上述过程，最重要的一句话就是，当插入`[n,k]`时，只要队列中已有的元素全部都大于`n`，那么这个元素只要插入到第`k+1`，或者说下标为`k`的位置即可。

于是算法就出来了，因为时刻保持队列中已有元素比未插入元素要大（最不济也是等于），所以插值应该按照从大到小的身高顺序来。

而身高一样时，由于等于的情况也被计入`k`，因此要按照从小到大的顺序来。

总的来说，就是将输入先排序，排序的key是降序`n`和升序`k`。

而后按序扫描，逐个入队即可。

>一个小技巧：
>如何用Python库函数实现上述排序要求？
>
>如果都是升序可以不加key参数，如果都是降序则加上reverse参数
>
>问题是这里一个升序一个降序，可以这样：
>```python
>sorted(people, key=lambda x:(-x[0], x[1]))
>```