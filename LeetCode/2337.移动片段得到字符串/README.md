## 题目描述
给你两个字符串 start 和 target ，长度均为 n 。每个字符串 仅 由字符 'L'、'R' 和 '_' 组成，其中：

字符 'L' 和 'R' 表示片段，其中片段 'L' 只有在其左侧直接存在一个 空位 时才能向 左 移动，而片段 'R' 只有在其右侧直接存在一个 空位 时才能向 右 移动。
字符 '_' 表示可以被 任意 'L' 或 'R' 片段占据的空位。
如果在移动字符串 start 中的片段任意次之后可以得到字符串 target ，返回 true ；否则，返回 false 。

示例 1：
```
输入：start = "_L__R__R_", target = "L______RR"
输出：true
解释：可以从字符串 start 获得 target ，需要进行下面的移动：
- 将第一个片段向左移动一步，字符串现在变为 "L___R__R_" 。
- 将最后一个片段向右移动一步，字符串现在变为 "L___R___R" 。
- 将第二个片段向右移动散步，字符串现在变为 "L______RR" 。
可以从字符串 start 得到 target ，所以返回 true 。
```
示例 2：
```
输入：start = "R_L_", target = "__LR"
输出：false
解释：字符串 start 中的 'R' 片段可以向右移动一步得到 "_RL_" 。
但是，在这一步之后，不存在可以移动的片段，所以无法从字符串 start 得到 target 。
```
示例 3：
```
输入：start = "_R", target = "R_"
输出：false
解释：字符串 start 中的片段只能向右移动，所以无法从字符串 start 得到 target 。
```

提示：
```
n == start.length == target.length
1 <= n <= 105
start 和 target 由字符 'L'、'R' 和 '_' 组成
```

### 解法 双指针
先简单总结一下题意，start字符串中的L只能往左移动，R只能向右移动，且所有移动都不能跨越非空位。
看能不能通过移动，获得target字符串。

容易想到，既然是通过移动得到的，那么如果可行，则start和target中的所有L和R一定是一一对应的。

于是可以安排两个指针分别扫描start和target，碰到非空位时记录一下。
若两者相同，则说明可能是成功移动完成之后互相对应的L或者R。

此时还含有一些必要条件，如果两者字母是L的话，那么start中的L一定要在target的右边，即下标要大于等于target中的下标。
同理，如果字母是R，则start中的R的下标一定要小于等于target中的。
如此才能满足L只向左移，R只向右移。

总结一下，即从左到右双指针分别扫描start和target。
当碰到非空格的时候停下来并记录下标以及检查字母具体是什么。根据上面的要求进行判断，如果不符合要求直接返回False。

当某一个指针已经扫描到头后，此时还不能直接返回True。
因为需要考虑这样一种可能：另一个没扫描完的字符串还有非空格字符。这样实际上就是不符合start和target中非空格字符一一对应的原则。
因此对可能的未扫描完成的部分再额外进行一次扫描，此时只需要关注是否有非空格字符即可。

最后才能返回True。