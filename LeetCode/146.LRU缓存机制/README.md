## 题目描述
运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。
实现 LRUCache 类：

- `LRUCache(int capacity)` 以正整数作为容量 capacity 初始化 LRU 缓存

- `int get(int key)` 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。

- `void put(int key, int value)` 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。
 

进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？

示例：
```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

提示：
- 1 <= capacity <= 3000
- 0 <= key <= 3000
- 0 <= value <= 104
- 最多调用 3 * 104 次 get 和 put

### 解法1 OrderDict（无代码）
如果没有"最近被使用的较晚被剔除"这个规则，那么一个简单的哈希表就能实现功能。

而这个规则之所以难实现就是因为哈希表是无序的。

假如是一个连续表，那么在get或者put某个元素之后，我可以直接将其放到序列最后端。这样达到饱和后剔除元素从序列最前端开始执行即可。

既然想要让哈希表有序，自然就想到了`collections.OrderDict`。

事实上做了一下，也可以AC。
当然面试的时候能不这么干就尽量别这么干，毕竟人家考得其实是OrderDict的具体实现

### 解法2 哈希表+双向链表
这实际上也是OrderDict内部的实现机制。实现细节上有很多不同，我这里就提一种可行的办法。

为了在get的时候能够O(1)找到元素，哈希表显然还是要的。这个缓存的核心数据结构也是这个哈希表。

另一方面，当某个哈希表的键值对被get了之后就将其"放到队列末尾"，看起来似乎还需要引入一个队列。
但如果被get的这个数据处于队列中央，显然将其放到末尾的操作需要将其后面所有元素挨个往前挪一位，做不到O(1)。

在O(1)内使序列中间的某个元素直接放到序列末尾，可以用双向链表。（当然这里双向链表的节点类需要自己实现）。

更具体的，哈希表中的每个key都指向对应的双向链表节点，一个节点里保存的是key对应的value，key本身（因为在put过程中要通过节点找key），prev和next
两个指针。

此外为了方便，我还实现了一个将某个节点移动到末尾的方法`move_to_end`。
这个方法会在一些地方用到。

此外，为了能方便地找到链表的第一个和末尾元素，我额外安排了一个head和一个tail节点，他们在更外围包裹住整个链表。