## 题目描述
给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意:
- 每个数组中的元素不会超过 100
- 数组的大小不会超过 200

示例 1:
```
输入: [1, 5, 11, 5]

输出: true

解释: 数组可以分割成 [1, 5, 5] 和 [11].
```

示例 2:
```
输入: [1, 2, 3, 5]

输出: false

解释: 数组不能分割成两个元素和相等的子集.
```

### 解法 DP （恰好装到容量的背包问题）
首先对题目要有一个最初步的分析，恰好分成两个子集并且和相同，换句话说，
其实是要求从数组中取出任意多个数字使得其和恰好是原数组总和的一半。

在排除一些特殊情况比如数组长度小于2，或者数组总和为奇数之后，这其实就是一个01背包问题。
并且根据题意，这里必须将背包恰好装满。好在并不需要求最大价值什么的，只要知道能否恰好装满即可。

因此，根据01背包问题的定义，进行dp数组的设计：
`dp[i][j]`表示数组的前`i`个数字的取值能否恰好填满容量为`j`的背包。
同时为了避免分类讨论，在dp中额外加上什么数字都不取的一个dummy行以及要求容量为0的dummy列。
因此dp数组的size是`dp[n+1][target+1]`。其中n是nums长度，target是所求的最终容量。

由于最终只要返回一个bool量，所以dp数组中的值也只要bool即可。将第一列初始化为True，其余保持False。

转移方程：
```python
if dp[i-1][j] or \   # 不取下标i数的情况
   j - nums[i - 1] >= 0 and dp[i-1][j - nums[i - 1]]:    # 取的情况

    dp[i][j] = True
```
最后返回`dp[-1][-1]`即可。