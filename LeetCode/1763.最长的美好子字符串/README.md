## 题目描述
当一个字符串 s 包含的每一种字母的大写和小写形式 同时 出现在 s 中，就称这个字符串 s 是 美好 字符串。比方说，"abABB" 是美好字符串，因为 'A' 和 'a' 同时出现了，且 'B' 和 'b' 也同时出现了。然而，"abA" 不是美好字符串因为 'b' 出现了，而 'B' 没有出现。

给你一个字符串 s ，请你返回 s 最长的 美好子字符串 。如果有多个答案，请你返回 最早 出现的一个。如果不存在美好子字符串，请你返回一个空字符串。

示例 1：
```
输入：s = "YazaAay"
输出："aAa"
解释："aAa" 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 'a' 和大写形式 'A' 也同时出现了。
"aAa" 是最长的美好子字符串。
```
示例 2：
```
输入：s = "Bb"
输出："Bb"
解释："Bb" 是美好字符串，因为 'B' 和 'b' 都出现了。整个字符串也是原字符串的子字符串。
```
示例 3：
```
输入：s = "c"
输出：""
解释：没有美好子字符串。
```
示例 4：
```
输入：s = "dDzeE"
输出："dD"
解释："dD" 和 "eE" 都是最长美好子字符串。
由于有多个美好子字符串，返回 "dD" ，因为它出现得最早。
```
 
提示：
```
1 <= s.length <= 100
s 只包含大写和小写英文字母。
```

### 解法 分治
这题标easy就离谱…
这题被标成easy的唯一原因是，题目给出的限制条件是输入字符串长度最长也就100，所以可以暴力。

当然暴力做法没什么意思，这里直接讲更好的做法。

第一时间想到的，是滑窗。
虽然后来知道了这题确实可以用滑窗做，但是控制窗口滑动的条件很复杂，需要很多变量进行控制。

后来看了答案，发现参考`LC.395`，用分治的方法来做。

简单来说，对于一个字符串，其本身是不是美好字符串的判断条件，就是看其中是否含有无法配对的字母。
若有，假设该字母位于位置pos，那么这个字符串内的美好子字符串最多也就只能是`s[:pos]`和`s[pos+1:]`了。只要进一步搜索检查这两者即可。

于是具体细节很快就实现出来了。
定义一个`def dfs(start, end)`，用于检查`s[start:end+1]`这个片段是否是一个美好字符串。显然`start >= end`时不是，这可作为dfs的终止条件。
由于题目要求给出具体的最长美好子字符串，因此在dfs过程中可以维护最大长度以及起始位置。
当发现`s[start:end+1]`是一个美好字符串且其长度`end - start + 1`大于目前已知的最大长度，就更新相关变量。

至于如何检查某个片段是否是美好字符串，没有很优化的办法。
最简单的做法，是先进行一次扫描，将各个字符按大小写分别写入到维护大小写字母出现与否的变量中。
因为总共就26个字母，所以可以用位运算来搞定。

当扫描完一遍后，大小写字母的两个flag`upper`和`lower`相等，说明所有出现在片段中的字母都有配对，那么说明该片段是美好字符串。
否则，就需要再扫描一遍，找到其中的那些未配对的字母，以其作为边界，分别扫描前半段和后半段。

按照上述做法，配合cache进行dfs记忆化的话，可以AC了。
但是耗时很长。
检查一番后，发现扫描过程还有优化空间。

比如例子`aAaAxbBbycCc`。
显然`x`和`y`是两个"害群之马"。当扫描到`x`之后，进一步的dfs是扫描左边的`aAaA`和右边的`bBbycCc`。这似乎没什么问题。
而当扫描到`y`时，会进一步扫描`aAaAxbBb`和`cCc`，显然，此时左半段中有`x`，而这是已知的不需要扫描的片段了。

因此，虽然说是分治，但是没必要严格地左右分开递归。而是可以线性的扫描，当扫完`x`后，我们知道`x`是害群之马，所以直接将扫描的左边界提到`x`后面一位。
而当扫到`y`时，左半段就会变成`bBb`而不是`aAaAxbBb`，这样可以避免重复扫描`aAaA`这一段了。

事实上，优化以上算法后，即使在递归探索过程中，所有的位置都只会被扫描一次，所以即便不加cache也不会怎么样。
