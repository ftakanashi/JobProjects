## 题目描述
你有一个 n x 3 的网格图 grid ，你需要用 红，黄，绿 三种颜色之一给每一个格子上色，且确保相邻格子颜色不同（也就是有相同水平边或者垂直边的格子颜色不同）。

给你网格图的行数 n 。

请你返回给 grid 涂色的方案数。由于答案可能会非常大，请你返回答案对 10^9 + 7 取余的结果。

 

示例 1：

```
输入：n = 1
输出：12
解释：总共有 12 种可行的方法：
```
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/12/e1.png)
示例 2：
```
输入：n = 2
输出：54
```
示例 3：
```
输入：n = 3
输出：246
```
示例 4：
```
输入：n = 7
输出：106494
```
示例 5：
```
输入：n = 5000
输出：30228214
```

提示：
```
n == grid.length
grid[i].length == 3
1 <= n <= 5000
```

### 解法 DP
乍一看好像是用DFS，但是最近遇到越来越多DFS会超时…
DFS超时的情况基本上就是考虑要么在DFS基础上优化，比如记忆化搜索之类的。

如果不太方便，可能就该考虑DP了。

这题的DP比较刁钻。
第一次看到可能下意识地设置一个n*3的dp二维数组，然后依次数每一个网格可能的填充数。
但是尝试了下发现比较困难。

于是看了一眼答案、
原来这题的DP并不是基于网格的，而是基于pattern的。
因为每一行都是三个格子而三个格子的涂色方案就是示例1中给出的12种可能。

而对于某一行来说，其涂色的可能性只和其上一行有关（在从上到下遍历的过程中）。

换言之，对于下标为`row`的行来说，其可能的涂色种类数首先取决于`row - 1`是什么。
而`row - 1`的pattern确定后，候选的12种pattern中会有一些因为纵向相邻格子撞色而不能选取。

综上，`row`的每一种可能的pattern，是`row - 1`时，那些不与这个pattern纵向撞色的pattern数的总和。

因此dp数组应该是一个n * 12的矩阵。
`dp[i][j]`表示下标`i`行取下标为`j`的pattern的种类数。

具体实现上，为了在整个代码中有统一的pattern管理，可以先行预处理出所有pattern。

同时，为了知道从某个pattern出发能不能取另一个pattern作为下一行，还应该有一个`12 * 12`的related 01矩阵。
显然这个矩阵的对角线全是0。
这个矩阵也可以在预处理阶段得到。

