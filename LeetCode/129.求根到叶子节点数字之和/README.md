## 题目描述

给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。

例如，从根到叶子节点路径 1->2->3 代表数字 123。

计算从根到叶子节点生成的所有数字之和。

说明: 叶子节点是指没有子节点的节点。

示例 1:

>输入: [1,2,3]
>
>```
>    1
>   / \
>  2   3
>```
>输出: 25
>
>解释:
>
>从根到叶子节点路径 1->2 代表数字 12.
>
>从根到叶子节点路径 1->3 代表数字 13.
>
>因此，数字总和 = 12 + 13 = 25.

示例 2:

>输入: [4,9,0,5,1]
>```
>    4
>   / \
>  9   0
> / \
>5   1
>```
>输出: 1026
>
>解释:
>
>从根到叶子节点路径 4->9->5 代表数字 495.
>
>从根到叶子节点路径 4->9->1 代表数字 491.
>
>从根到叶子节点路径 4->0 代表数字 40.
>
>因此，数字总和 = 495 + 491 + 40 = 1026.


### 解法1 DFS
显然，这是一个二叉树搜索的问题。

既然是树搜索，那么就是DFS和BFS了。

DFS用的递归思路简单一些，先写DFS。

虽说简单，但是实际上需要关注，如何将每个节点中保存的一个个零散的
数字给按照顺序组合成十进制数。

注意到，从root开始到每个节点，当前节点都会有一个整合了遍历到当前位置形成的"基准值"。比如上述示例2，
节点9的基准值是49，而节点5的基准值是495。

而这个基准值是怎么来的，显然，是父节点基准值乘以10之后加上当前节点的value。

再次提醒，"基准值"不是node.val，而是累计到当前位置的值。

显然，叶子节点的基准值就是整个树某条路径对应下来的一个数。把所有路径对应的所有树依次加起来，
就得到最终返回的值了。

这个整合加和的操作，显然是"我的和等于我的左子树和右子树加起来"的操作，因此可以递归了。


