## 题目描述
给你一个数组 pairs ，其中 pairs[i] = [xi, yi] ，并且满足：
```
pairs 中没有重复元素
xi < yi
```
令 ways 为满足下面条件的有根树的方案数：

树所包含的所有节点值都在 pairs 中。
一个数对 [xi, yi] 出现在 pairs 中 当且仅当 xi 是 yi 的祖先或者 yi 是 xi 的祖先。
注意：构造出来的树不一定是二叉树。
两棵树被视为不同的方案当存在至少一个节点在两棵树中有不同的父节点。

请你返回：
```
如果 ways == 0 ，返回 0 。
如果 ways == 1 ，返回 1 。
如果 ways > 1 ，返回 2 。
```
一棵 有根树 指的是只有一个根节点的树，所有边都是从根往外的方向。

我们称从根到一个节点路径上的任意一个节点（除去节点本身）都是该节点的 祖先 。根节点没有祖先。

示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/09/trees2.png)
```
输入：pairs = [[1,2],[2,3]]
输出：1
解释：如上图所示，有且只有一个符合规定的有根树。
```
示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/09/tree.png)
```
输入：pairs = [[1,2],[2,3],[1,3]]
输出：2
解释：有多个符合规定的有根树，其中三个如上图所示。
```
示例 3：
```
输入：pairs = [[1,2],[2,3],[2,4],[1,5]]
输出：0
解释：没有符合规定的有根树。
```

提示：
```
1 <= pairs.length <= 105
1 <= xi < yi <= 500
pairs 中的元素互不相同。
```

### 解法 DFS
这道题很难。
而且题意有点难懂，这里先来审题解释一下。

#### 审题
题意有点模糊不清，其实题目想让你判断的是，给出的pairs数组是否恰好是某一棵多叉树的所有"祖先-后辈"关系的集合。
若否则返回0，若是，则判断这样的一棵树是否唯一，若唯一返回1，若不唯一返回2（还好不是返回可能数…

由于pairs数组和树结构需要完全等价，所以针对示例3，如下这样一棵树
```text
    1
  2   5
 3 4
```
是不符合要求的。因为"祖先-后辈"关系`[1, 4]`并没有出现在pairs中。
事实上，不论你怎么构造这棵树，示例3都没法做到pairs和树结构的完全等价，因此输出的答案会是0。

#### 解法说明
> 参(chao)考(xi)自[这个答案](https://leetcode-cn.com/problems/number-of-ways-to-reconstruct-a-tree/solution/python3-di-gui-tu-jie-by-yuan-zhi-b-qo4g/)。
>
> 目前还没完全理解…只能做个不严谨的解释了。

看到pairs这么一个数组，很容易想到将其转化为图结构的临接表。
但是仔细一想，发现得到的东西并不是一个图，因为pairs中的`[a, b]`两个节点在实际的树结构中并不一定直接相邻，而是一个处于一条path上的前后辈关系。

那么，基于这样一个数据结构，我们能做一些什么事情？

首先，我们定义这个结构为`adj = defaultdict(set)`。（将值的类型定义为set的原因是方便后面的判断in操作）
然后将pairs中的所有`[a,b]`都填充进去：
```python
adj[a].add(b)
adj[b].add(a)
```

由于`[a, b]`两个节点不一定直接相连，也不知道具体谁是前辈谁是后辈，所以姑且称`adj[node]`中的节点为`node`的"邻居"。
另外，定义总结点个数，即`len(adj)`为`n`。

分析这个数据结构与树结构之间的关系，可以得到下面一些结论。

第一，若某个节点node的邻居们`adj[node]`的数量，恰好是`n - 1`，那么说明这个节点是树结构的根节点。
> 这点一开始觉得没啥毛病，但是后来仔细想想，感觉无力证明它的充分性…

第二，我们定义子树的根节点root的邻居们的邻居为"二级邻居"，针对root的所有二级邻居（当然要去除其自己的情况），若有某二级邻居`e`不存在与`adj[root]`中，
显然树结构非法。因为所有的节点应当都是root的邻居。

第三，任意两个节点，若其邻居集合在除去彼此后一模一样，说明这两个节点可以在构造起来的树结构中互换位置。
换言之，一旦发生这种情况，只要存在合法树结构，就一定是多于1种的，因此必须返回2。

基于以上几个结论，可以写代码。

首先，根据第一个结论，可以写最外层的代码。即判断是否有且有几个可能的根节点。
若有两个及以上，则直接返回2；若一个都没有，则直接返回0。
问题在于恰好有一个的情况。

恰好有一个根节点时，那么可以确定其是根节点的同时，剩下的工作就是确定如何从剩余节点中构建一个合法的树结构了，于是这又变成了一个规模更小的问题，
因此整体的方法论来说，可以用DFS递归来做。

具体的，定义dfs函数`dfs(node)`，返回当`node`作为根节点时该返回0还是1还是2。

进入dfs后，首先为了保证之前说明中提到的"去除自己"的情况，所以先在adj中remove掉所有和node相关的连接。
接着扫描node的邻居（为了有东西可扫描，需要在remove操作前将`adj[node]`先做一个备份`neighbors`拿来用）。
针对邻居`neb`，根据上面的第二以及第三个结论进行判断。

即，若`adj[neb]`中有二级邻居且二级邻居不存在于原`neighbors`，那么说明此时无法基于`node`作为根节点构造合法树结构，返回0。
接着，判断`neb`是否可以和`node`互换。若可以，则可以设置一个flag表示这个结果，但是不能直接返回2，因为还需要进一步扫描更下层的子结构是否合法。
只要更下层的子结构能够凑出哪怕只有一个合法的树结构，那么由于`neb`和`node`可互换，所以一定可以返回2。

接着就是对更下层子结构的扫描，即`dfs(neb)`了。
注意这个调用的返回，如果是0，那么说明更下层子结构无合法可能，自然本层也只能返回0。
相反，若更下层子结构返回是1或者2，则至少说明在`neb`这个邻居的分支上有合法可能性，但是还需扫描剩余其他neb，必须全部都有才行。
不过若是2，还可以确定的是最终返回的也是2而不是1，所以这里也可以再设置flag。

扫描完node的全部邻居后，若仍没有由于无法发现合法可能性而返回0，那么就可以大胆地返回有合法可能性的结论，这还细分成两种。
若flag是True，则返回2，否则返回1。

按照以上逻辑写出代码。
（要是看不懂也不用勉强…我也看不懂。此题据说是leetcode周赛历史上最难的题目之一，全网做出来的人也不过十来个。