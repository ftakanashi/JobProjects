## 题目描述
给你一个整数数组 nums，和一个整数 k 。

对于每个下标 i（0 <= i < nums.length），将 nums[i] 变成 nums[i] + k 或 nums[i] - k 。

nums 的 分数 是 nums 中最大元素和最小元素的差值。

在更改每个下标对应的值之后，返回 nums 的最小 分数 。

示例 1：
```
输入：nums = [1], k = 0
输出：0
解释：分数 = max(nums) - min(nums) = 1 - 1 = 0 。
```
示例 2：
```
输入：nums = [0,10], k = 2
输出：6
解释：将数组变为 [2, 8] 。分数 = max(nums) - min(nums) = 8 - 2 = 6 。
```
示例 3：
```
输入：nums = [1,3,6], k = 3
输出：3
解释：将数组变为 [4, 6, 3] 。分数 = max(nums) - min(nums) = 6 - 3 = 3 。
```

提示：
```
1 <= nums.length <= 104
0 <= nums[i] <= 104
0 <= k <= 104
```

### 解法 贪心 排序
题目的一些细节需要注意一下，比如每个数字都要操作，而不能选择不操作。

比较容易想到的是可以先排个序。
排完序之后，小的数尽量+k，大的数尽量-k，直觉上可以让最终答案尽量小。

但问题是，如何界定"小数"和"大数"。

我们不妨把全部 +k 的小数连成的区域称为小数区，大数的称为大数区。 
由于排完序后，小数区域内，某个数`nums[i]`，其`nums[i] + k`的值必然大于 `nums[i-1] + k`，
同理，大数区域内，`nums[j] - k`必然始终大于 `nums[j-1] - k`。

因此，实际上整个数组处理后，最大的值的可能性只有可能是 `nums[-1] - k` 或者 `nums[i] + k`（此处`i`是小数区最靠右的位置。

同理，最小值的可能性只可能是 `nums[0] + k` 或者 `nums[j] - k`（此处`j`是大数区最靠左的位置

问题是找到`i`和`j`的具体位置。这时我们可以一次遍历，将所有位置都扫描一遍，寻找全局最合理的值即可。

最后这题还有一个小问题，就是遍历前ans的初值该设置为什么。

一开始我以为设置为 `nums[-1] - nums[0] - k * 2`，但当`k`比较大时这个值是负数，不太好处理。
考虑到两者共同 +k 或者 -k 也是合法的操作情况，初值可以直接设置为 `nums[-1] - nums[0]`