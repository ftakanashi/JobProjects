## 题目描述
给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。

示例：
```
输入：3
输出：
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释：
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
 
```
提示：
- 0 <= n <= 8

### 解法 DFS（回溯）
其实解法本身从思想上来说和`LC.96`是一样的，无非就是把返回的东西从计数变成了树对象而已。

但是这道题的回溯意味更浓。
思路的大体框架很好想，我的第一版代码大概是这样的：
```text
def dfs(s, e):
    if s >= e: 返回相应值，这里大于和等于要分开讨论了
    res = []
    for i in s...e:
        root = Tree(i)
        for l in dfs(s, i-1):
            for r in dfs(i+1, e):
                root.left = l
                root.right = r
                res.append(root)

    return res
```
显然，上述代码存在的一个问题就是root是一个对象，简单append之后，如果后续发生变化，那么已经被收割的结果也会改变，导致最终输出不对。

一个简单的解决办法是套一个`copy.deepcopy(root)`。

但是用了之后发现代码很慢。
然后意识到，虽然上面树的初始化`root = Tree(i)`放在接子树的双重循环的外面，确实根节点的初始化只要做一次，
但是相应的，却要做好多次deepcopy操作。这个是划不来的，还不如干脆将树的初始化放在双重循环里面呢。

除此之外，没有什么特别的了。
这也是提醒了我，回溯法虽然是"保持一部分不变，动另一部分并收割"的做法。但是实际上可以灵活地调配逻辑。
