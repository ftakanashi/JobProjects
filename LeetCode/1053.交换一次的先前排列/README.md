## 题目描述
给你一个正整数数组 arr（可能存在重复的元素），请你返回可在 一次交换（交换两数字 arr[i] 和 arr[j] 的位置）后得到的、按字典序排列小于 arr 的最大排列。

如果无法这么操作，就请返回原数组。

示例 1：
```
输入：arr = [3,2,1]
输出：[3,1,2]
解释：交换 2 和 1
```
示例 2：
```
输入：arr = [1,1,5]
输出：[1,1,5]
解释：已经是最小排列
```
示例 3：
```
输入：arr = [1,9,4,6,7]
输出：[1,7,4,6,9]
解释：交换 9 和 7
```

提示：
```
1 <= arr.length <= 104
1 <= arr[i] <= 104
```

### 解法 贪心
这题的最终要求，应该分成两个方面来看待。

不妨设`i < j`。
首先，交换一次后要求字典序更小，等价于`arr[i] > arr[j]`。这是很显然的。

其次，交换后的排列应当尽可能大，因此从感觉上来说，arr应当尽可能靠右。
于是可以先从右到左扫描arr，找到第一个`arr[i] > arr[i+1]`的位置。
此时，`arr[i+1:]`是一个不递减的序列，同时也是我们可以找`j`的范围。

由于arr是完全没有限制的，因此在`arr[i+1:]`这个排列中有可能有大于`arr[i]`的数，这部分不能作为`arr[j]`。
然后，找到最大的`j`使`arr[j] < arr[i]`是否就可以了呢？答案是否定的。

此时还需要考虑重复数字的情况。
比如`xxx 5 1 2 3 3 8 9`。此时有两个3是符合要求的，但是我们应当取用左边的3作为交换的对象，因为`xxx 3 1 2 5 3 8 9`是一个字典序更大的排列。
也就是说当`arr[i+1:]`中有一片连续的相同数字符合要求时，应当选择最左边那个。

综上，我们从右到左遍历`i`，找到第一个`arr[i] > arr[i+1]`的位置。
然后从右到左在`[i+1:]`的范围内遍历`j`，找到第一个`arr[i] > arr[j]`的位置（由于`arr[i+1:]`不递减，所以这个过程很简单），
并且如果有连续一片相同的数字符合要求时，选用最左侧的那个，即最小的`j`。

然后交换`arr[i]`和`arr[j]`即可。

更多细节看代码。