## 题目描述
在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。

如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x != y）发送好友请求：
```
age[y] <= 0.5 * age[x] + 7
age[y] > age[x]
age[y] > 100 && age[x] < 100
```
否则，x 将会向 y 发送一条好友请求。

注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。

返回在该社交媒体网站上产生的好友请求总数。

示例 1：
```
输入：ages = [16,16]
输出：2
解释：2 人互发好友请求。
```
示例 2：
```
输入：ages = [16,17,18]
输出：2
解释：产生的好友请求为 17 -> 16 ，18 -> 17 。
```
示例 3：
```
输入：ages = [20,30,100,110,120]
输出：3
解释：产生的好友请求为 110 -> 100 ，120 -> 110 ，120 -> 100 。
```

提示：
```
n == ages.length
1 <= n <= 2 * 10^4
1 <= ages[i] <= 120
```

### 解法 二分
说实话这题还真有点怪…

首先理清楚题意，题意最重要的，是上面提到的三个条件。
当三个条件任意满足其一时，x都不会向y发起好友请求。

分析三个条件发现，一般而言，只需要满足`ages[x] // 2 + 7 < ages[y] <= ages[x]`
就可以让x对y发起好友请求了。

第三个条件纯粹白给。因为以100为分界线，若满足第三个条件，
那么第二个条件即`ages[y] > ages[x]`肯定成立。
因此第三个条件可以忽略。

有了上述粗略的条件后，还需要进一步思考。
显然的一个bug是，当`ages[x] // 2 + 7 > ages[x]`怎么办。
通过化简，可以发现上述式子等价于`ages[x] <= 14`。
而此时无论y取值如何，第一个和第二个条件必然有一个要成立。
既然如此，也就是说所有小于等于14的情况不考虑即可。

到此时，其实大体的思路已经有了。
我们对ages先进行一个排序，然后扫描，针对每个扫描到的位置`x`，
符合其要求能让他发出好友请求的其他人，其年龄值`ages[y]`必须在`ages[x] // 2 + 7`到`ages[x]`之间。
那么也就是说在`x`之前的位置中找到`ages[x] // 2 + 7`的位置即可。
由于前面这段是有序的，因此可以用二分查找来做。
找到之后`x-y`就是x可以发起的好友请求次数。

但是这题稍微复杂一点的地方在于，没有规定数据的唯一性。
当有相同年龄出现时就会比较麻烦。

在思考了一些方案之后，我还是采用了最简单粗暴的一种…
我们先用一个counter统计所有年龄的出现次数。对于有重复出现的年龄，我们先将该年龄内部的好友请求次数单独统计出来并计入结果。
（因为`ages[y] == ages[x]`时x可以向y发起好友请求）

对于某个年龄如果出现了n次，那么人之间两两的对有`n * (n-1) / 2`对，又因为好友请求是双向的，因此直接去掉除以2的部分，
即`n * (n-1)`。

除了这些"年龄内"的计数，还需要计数年龄间的情况。
此时就需要用到上述扫描+二分的算法。
由于要考虑年龄重复的情况，因此碰到和上一个位置年龄相同的情况时，可以直接计入上一轮的结果，避免重复的二分查找。
比如例子`30 100 110 110 120`。当扫描到第一个`110`后，可以找到`y`是1，`x-y`是2-1=1。
接着扫描第二个`110`时，如果直接套用相同思路，那么此时会有`y`仍然是1，但是`x`变成了3，`x-y=2`，显然不对。
（你可能会想，不要当时统计年龄内，直接套用这个思路一次扫描不行么？不行。因为那样的话扫描到第一个110时还需要考虑其后面的110，会变复杂）

根据上面描述，当扫到第二个110，我们直接计入上一轮的扫描结果1即可，而不是再做第二次二分。
如此便可以一次扫描，整完全部。