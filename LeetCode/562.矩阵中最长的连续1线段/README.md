## 题目描述
给定一个01矩阵 M，找到矩阵中最长的连续1线段。这条线段可以是水平的、垂直的、对角线的或者反对角线的。

示例:
```
输入:
[[0,1,1,0],
 [0,1,1,0],
 [0,0,0,1]]
输出: 3
```
提示: 给定矩阵中的元素数量不会超过 10,000。


### 解法 DP
其实这题明确说了总元素数量不超过1万。
所以直接暴力似乎也未尝不可。
当然，直接暴力的话会需要扫描四遍矩阵（行线段，列线段以及正反对角线线段）。

更高明的办法，是通过DP来一次遍历。

具体的，为每个元素设置一个四元组作为DP值。
分别标识这个位置为结尾的行、列、对角、反对角线段的长度。
扫描过程中，若扫描到位置的矩阵原值是0，自然是不存在这样的线段，因此DP值是`(0,0,0,0)`，
若原值是1，则状态递推如下：
```python
dp[i][j][0] = dp[i][j-1][0] + 1
dp[i][j][1] = dp[i-1][j][1] + 1
dp[i][j][2] = dp[i-1][j-1][2] + 1
dp[i][j][3] = dp[i-1][j+1][3] + 1
```
注意以上没有考虑下标越界的情况。
当然，为了保证不越界，可以使用DP数组都开一行+一列的办法，即DP数组的size是`(m+2)*(n+2)`。
然后扫描`for i in range(1, m+1)`和`for j in range(1, n+1)`即可。