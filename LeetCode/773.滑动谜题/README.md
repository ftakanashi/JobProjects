## 题目描述

在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用 0 来表示.

一次移动定义为选择 0 与一个相邻的数字（上下左右）进行交换.

最终当板 board 的结果是 [[1,2,3],[4,5,0]] 谜板被解开。

给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。

示例：
```
输入：board = [[1,2,3],[4,0,5]]
输出：1
解释：交换 0 和 5 ，1 步完成
```
```
输入：board = [[1,2,3],[5,4,0]]
输出：-1
解释：没有办法完成谜板
```
```
输入：board = [[4,1,2],[5,0,3]]
输出：5
解释：
最少完成谜板的最少移动次数是 5 ，
一种移动路径:
尚未移动: [[4,1,2],[5,0,3]]
移动 1 次: [[4,1,2],[0,5,3]]
移动 2 次: [[0,1,2],[4,5,3]]
移动 3 次: [[1,0,2],[4,5,3]]
移动 4 次: [[1,2,0],[4,5,3]]
移动 5 次: [[1,2,3],[4,5,0]]
输入：board = [[3,2,4],[1,5,0]]
输出：14
```
提示：
```
board 是一个如上所述的 2 x 3 的数组.
board[i][j] 是一个 [0, 1, 2, 3, 4, 5] 的排列.
```

### 解法 BFS
这题和`LC.752`如出一辙。
将每一种board的状态视为一个节点，两个状态若是能通过一次互换彼此转换，则视为两个节点间有边。
于是这就变成了一个，给出一个图中出发点和target，问最短路径的问题了。

于是，这样一个问题就可以通过BFS来做。（不要问为什么不用DFS，下面会解释。另外用一些图的算法比如本来就是拿来解最短路径问题的Dijkstra，这题也能AC）

具体的，将某个状态和到达这个状态需要的操作数作为一个组入队列。
为了防止循环探索，额外设置一个哈希集用来保存探索过程中已经探索过的状态。

由于哈希集不能保存列表类型，所以需要`list2tuple`和`tuple2list`两个函数，随时做转换。

每次循环，从队列中pop出一个状态。
若这个状态已经是target，直接返回相关操作数。
若这个状态已经被探索过，则不需重复探索，直接continue。
否则，定位这个状态中0的位置，然后尝试将0与上下左右进行互换，当然不能有越界。
将互换完成后的状态，以及操作数+1，入队。

另外此题可能会有永远无法达成目标的情况。
这也就是queue空了之后，即`while queue`循环跳出。
因此在最后加上一条return -1即可。

#### 关于为什么不能用DFS
说实话，现在还无法明确回答这个问题。
包括`LC.752`也是，我一开始第一感觉都是用DFS做，但是这两题都尝试了DFS，都失败了。

另一方面，网上别人的答案也都是清一色BFS，没有真正做DFS的。

也就是说，现在开始要改变BFS和DFS的效率差不会太大的观念了。
像在这两题中，DFS和BFS之间性能差距巨大。
即，存在一些题，只能用BFS做不能用DFS做。