## 题目描述
给定正整数 k ，你需要找出可以被 k 整除的、仅包含数字 1 的最 小 正整数 n 的长度。

返回 n 的长度。如果不存在这样的 n ，就返回-1。

注意： n 不符合 64 位带符号整数。

示例 1：
```
输入：k = 1
输出：1
解释：最小的答案是 n = 1，其长度为 1。
```
示例 2：
```
输入：k = 2
输出：-1
解释：不存在可被 2 整除的正整数 n 。
```
示例 3：
```
输入：k = 3
输出：3
解释：最小的答案是 n = 111，其长度为 3。
```

提示：
```
1 <= k <= 105
```

### 解法 数学 哈希集
这题本质上是个小学数学题。
乍一看可能找不到什么好的思路，所以可以先拿几个数脑补试一试。

假设现在有一个总共有`m`个1的数，尝试除以`k`无法除尽。设此时的余数为`r`。
很自然的，我们会想加一个1之后会发生什么。此时原数增大10倍再加1。
这是就涉及到`mod`运算在普通四则运算中的规律了。

简单来说，`mod`运算满足乘法分配率。
当`a % b = k`时，如果把`a`乘以2，那么此时就相当于有两个`a`分别对b取余，然后加起来，所以余数也乘以2（当然前提是`k * 2 < b`。

结合题设， 所以当`m % k = r`时，增加一个1，有`m = m * 10 + 1`，
自然的，就有`r = r * 10 + 1`，若新的`r`比`k`大，那么就需要再做一次取余。
总的来说，就是`r = (r * 10 + 1) % k`。

只要`r`不为零，这个运算就得一直迭代下去。

然后观察一下，发现如果`r`重复出现，那么`r`在迭代过程中会陷入循环。此时不必要也不能无限迭代下去了。
因此可以维护一个哈希集，用来保存出现过的所有余数。一旦有余数重复出现并且没有余数为零的情况出现，此时就需要直接跳出循环返回-1。

更多细节见代码。
官答中对代码还有更进一步的优化，比如`k % 2 == 0`或者`k % 5 == 0`时，必然是没有解的（前者只能被偶数整除，后者末位一定得是0或者5）
不过加了之后好像对效率没有多大提升，酌情看看吧。