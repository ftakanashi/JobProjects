## 题目描述
初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭一个。

第三轮，你每三个灯泡就切换一个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换一个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。

找出并返回 n 轮后有多少个亮着的灯泡。
 

示例 1：

![](https://assets.leetcode.com/uploads/2020/11/05/bulb.jpg)
```
输入：n = 3
输出：1 
解释：
初始时, 灯泡状态 [关闭, 关闭, 关闭].
第一轮后, 灯泡状态 [开启, 开启, 开启].
第二轮后, 灯泡状态 [开启, 关闭, 开启].
第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 

你应该返回 1，因为只有一个灯泡还亮着。
```
示例 2：
```
输入：n = 0
输出：0
```
示例 3：
```
输入：n = 1
输出：1
```

提示：
```
0 <= n <= 109
```

### 解法 脑经急转弯 求完全平方数个数
这道题还是挺有意思的。
拿到手上第一反应，是用DP做。
但是一看数据范围，n最大是`10^9`，不论是DP还是DFS啥的都不现实了。
进一步，针对每个n进行分别计算，模拟的路子都不现实了。
所以这题一定有什么巧妙的办法。

于是深入想。
第一步可以想到的，是决定`n`号灯泡最终是否是点亮的因素是什么？
因为题意是从间隔2开始到间隔n为止，每种间隔都尝试的，因此，`n`号灯泡会在其所有因数的轮次上被拉开关。

比如6号灯泡，在`i`是`2, 3, 6`三种情况下会被拉开关。因为被拉了三次，所以最终灭了。

于是总结到规律，`n`的因数个数（不包括1但包括`n`本身）是偶数的数最终会保持点亮状态。
但是这又要怎么算呢？总不能又是遍历`range(1, n+1)`吧。

于是纸上写了一下，发现当且仅当完全平方数符合要求。
仔细一想，一个数的因数一般情况下总是成对出现，这也就意味着一般情况下除去1之后因数个数总是奇数，因此灯泡总是熄灭的。
而只有完全平方数，因为完全平方的时候只算一个因数，所以因数个数是奇数，而去掉1之后剩下的个数就是偶数了。

至此，这道题就转化成了求`1-n`之间总共有几个完全平方数。
这个问题就简单多了。