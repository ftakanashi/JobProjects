## 题目描述

请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

示例 1：
```
输入：s = "42"
输出：42
```
示例 2：
```
输入：s = "   -42"
输出：-42
```

示例 3：
```
输入：s = "4193 with words"
输出：4193
```
示例 4：
```
输入：s = "words and 987"
输出：0
```
示例 5：
```
输入：s = "-91283472332"
输出：-2147483648
```

提示：

- 0 <= s.length <= 200
- s 由英文字母（大写和小写）、数字（0-9）、' '、'+'、'-' 和 '.' 组成

### 解法 有限状态自动机
基于规则的解法就不说了。
这里说一下基于有限状态自动机（DFA）的解法。

当时在`LC65.有效数字`里遇到过DFA，但是那里情况很复杂，说实话让自己凭空想出那些规则和状态确实有点难。

这道题相对没那么复杂，可是说是一个比较好的上手DFA的例子。

说到DFA，他由一些状态和状态之间的转换规则构成。状态中包含一个start状态和一个end状态。
具体到这类判断字符串有效性的问题上，转换规则是基于当前状态和当前扫描到的字符定的。

因为规则由两方面因素决定，所以规则表写成一个二维表。

这题中，状态定义为下面四种：
```text
start: 0
signed: 1
num: 2
end: 3
```
其中num表示当前扫描已经扫描到了数字部分的状态，signed表示已经确定了数字的符号。

除了状态种类，还要看扫描到的字符的种类，有以下几种：
```text
空格: 0
正负号: 1
0-9数字: 2
其他: 3
```

有了上面的定义，其实写出规则表就不困难了，按照上面定义的下标0123，写出规则表如下：
```text
0 1 2 3
3 3 2 3
3 3 2 3
3 3 3 3
```
每一行对应当前状态，每一列对应当前扫描到的字符种类，然后相应行列的数字代表当前条件下的下一个状态。
举个例子，比如第二行是已经确定了符号的状态，此时如果扫描到的字符是空格、又来一个正负号、亦或是所有非0-9的字符，都是非法的，所以都通向end状态3。
只有扫描到的字符是0-9数字才是合法的，并且状态进入 数字状态 2。

至于32位带符号整数的限制，就不再DFA的规则里判断了，在外面自己判断吧。