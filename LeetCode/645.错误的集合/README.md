## 题目描述
集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。

给定一个数组 nums 代表了集合 S 发生错误后的结果。

请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

示例 1：
```
输入：nums = [1,2,2,4]
输出：[2,3]
```
示例 2：
```
输入：nums = [1,1]
输出：[1,2]
```

提示：
```
2 <= nums.length <= 104
1 <= nums[i] <= 104
```

### 解法1 原地哈希
因为题设就是数组中的数字范围是1-n，因此可以套用原地哈希套路，即扫描数组，将`nums[i]`尽可能放到`nums[nums[i] - 1]`的位置上。

这样，在发现哈希冲突之后就可以知道重复的数字是谁了。
但是这道题还要求输出丢失的数是谁，所以必须得遍历完整个数组。
另一方面，发现哈希冲突时当前位置本应该填入的数，有可能是那个丢失的数，因此需要记录下。

总之，我们需要在扫描完整个数组，原地哈希结束后，知道重复的那个数字（即哈希冲突的数字）最终处于的位置，而那个位置原本应该填入丢失的数。
这样就可以知道两个需要知道的答案了。

### 解法2 数学
解法1严格限制了空间复杂度在O(1)。如果空间无限制且要求不能改变数组本身，那么就得想想其他办法。

跳出数组原地哈希的套路，从更源点的角度想想，其实这题简单的一批。
`set(nums)`可以获得这个数组对应的哈希集。因为只有一个重复数字，所以这个哈希集的长度比数组长度小1。

比较哈希集和原数组，以及哈希集和理想的无重复数组，你就会发现，前两者比较刚好差一个重复数字，而后两者比较刚好差一个丢失数字。
那么怎么获得具体数字呢？求和作差啊。

所以两行代码就可以搞定这题。
