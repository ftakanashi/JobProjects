## 题目描述
给你一个下标从 0 开始的二维整数数组 flowers ，其中 flowers[i] = [starti, endi] 表示第 i 朵花的 花期 从 starti 到 endi （都 包含）。同时给你一个下标从 0 开始大小为 n 的整数数组 people ，people[i] 是第 i 个人来看花的时间。

请你返回一个大小为 n 的整数数组 answer ，其中 answer[i]是第 i 个人到达时在花期内花的 数目 。

示例 1：

![](https://assets.leetcode.com/uploads/2022/03/02/ex1new.jpg)
```
输入：flowers = [[1,6],[3,7],[9,12],[4,13]], people = [2,3,7,11]
输出：[1,2,2,2]
解释：上图展示了每朵花的花期时间，和每个人的到达时间。
对每个人，我们返回他们到达时在花期内花的数目。
```
示例 2：

![](https://assets.leetcode.com/uploads/2022/03/02/ex2new.jpg)
```
输入：flowers = [[1,10],[3,3]], people = [3,3,2]
输出：[2,2,1]
解释：上图展示了每朵花的花期时间，和每个人的到达时间。
对每个人，我们返回他们到达时在花期内花的数目。
```

提示：
```
1 <= flowers.length <= 5 * 104
flowers[i].length == 2
1 <= starti <= endi <= 109
1 <= people.length <= 5 * 104
1 <= people[i] <= 109
```

### 解法 差分 双指针
这题有点意思。

首先不考虑多个人的情况，如果只是给定一个固定的时间点，让求这个时间点上开花的数目，那么就是一个简单的差分数组问题。
考虑到这题并不是严格的从1开始每个点都会有变化，所以可以用哈希表来构建差分"数组"，然后按序遍历各个key即可。

也正是因为这里的差分数组不是连续的，所以可能会存在给定的时间点并不存在于哈希表的key中，
换言之，给定的时间点可能是两个哈希表中存在的时间点之间的情况。

如果只是给定一个时间点，那么我们可以在构建完差分数组，并从小到大遍历所有key时加一个判断，当遍历到的key大于给定时间点时，就不再继续遍历，返回当前累计的答案。

这道题的麻烦点在于`people`是多个，且不排序的。
不过也没有特别麻烦，我们可以对`people`进行排序，同时记录下排序前各个人对应的原始下标，从而通过这个下标找到答案数组中对应的答案并填值。

这个排序的目的是，一旦排序之后，针对多个`people`，不用每次都从头遍历，而全局只需要遍历一遍就行了。
也就是说，此时实际上差分数组是一个序列，`people`中每个人到的时间也是一个序列。
实际上我们可以用双指针在这里两个序列中分别向前遍历。
从而找到每个人到的时间时，差分数组遍历到其左边位置（含本身位置）为止累计的值。这值就是这个人能看到的花的数量了。

类似的，我们也可以通过差分数组维护一个时间 -> 花数量的映射，然后通过二分查找的方式来为每个人求解。
这里就不多说了。给出的代码是双指针的。