## 题目描述
如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 特殊数组 。

周洋哥有一个整数数组 nums 和一个二维整数矩阵 queries，对于 queries[i] = [fromi, toi]，请你帮助周洋哥检查子数组 nums[fromi..toi] 是不是一个 特殊数组 。

返回布尔数组 answer，如果 nums[fromi..toi] 是特殊数组，则 answer[i] 为 true ，否则，answer[i] 为 false 。

示例 1：
```
输入：nums = [3,4,1,2,6], queries = [[0,4]]
输出：[false]
解释：
子数组是 [3,4,1,2,6]。2 和 6 都是偶数。
```

示例 2：
```
输入：nums = [4,3,1,6], queries = [[0,2],[2,3]]
输出：[false,true]
解释：
子数组是 [4,3,1]。3 和 1 都是奇数。因此这个查询的答案是 false。
子数组是 [1,6]。只有一对：(1,6)，且包含了奇偶性不同的数字。因此这个查询的答案是 true。
```

提示：
```
1 <= nums.length <= 105
1 <= nums[i] <= 105
1 <= queries.length <= 105
queries[i].length == 2
0 <= queries[i][0] <= queries[i][1] <= nums.length - 1
```

### 解法 前缀和
题意很清晰明了，官方答案给的是DP思路，实际做题过程中可能稍微难想到一点。这里提供一种更容易想到的前缀和思路。

要判断数组的某个片段是否符合奇偶相间的要求，最直觉的就是扫描一遍，但是如果对每个query都扫描一遍，显然复杂度过高。
如果可以用某个数字来体现这个片段的奇偶相间特性就好了。

于是我们可以考虑将某个片段`nums[i:j+1]`扫描，若其从`i+1`开始的每个数字，都和前一个数字奇偶性相异，
就将对应位置`i+1`的一个flag值设置为1，否则就是0。

如此，我们便可通过一次遍历nums，获取到一个基于上述flag值的前缀和数组。
用于表示从数组开头到当前位置，所有相邻数字对中，有几对是奇偶性互异的。

当query来`[a, b]`时，我们只需要考察 `b-a` 是否等于 `flags[b]-flags[a]`。
只要两者相等，说明整个片段内的所有相邻数字都是奇偶性相异的。