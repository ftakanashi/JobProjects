## 题目描述
给定一个二叉树，返回它的 后序 遍历。

示例:
>```
>输入: [1,null,2,3]  
>   1
>    \
>     2
>    /
>   3 
>```
>输出: [3,2,1]

- 进阶: 递归算法很简单，你可以通过迭代算法完成吗？

### 解法1 递归
不解释

### 解法2 栈迭代
有些许时间没复习二叉树的一些知识点，差点给整岔了。。

前中后序遍历是针对DFS而言的，和BFS没关系。

在DFS的情况下，递归当然很简单。如果硬要用迭代的办法来做，显然需要手动建立一个栈来模拟递归时的栈。

第一个想到的办法是照着上一题前序遍历的情况，以根，右子树，左子树的顺序入栈。这样出栈就变成了后序。

可这里的问题是，当我第二次从栈中拿出根，如何让他知道左右子树已经处理完毕。这是后序遍历和前序遍历不同之处。

由于肯定不能破坏二叉树本身，因此不能删除节点。
**这里的办法，是设置一个`prev`指针指向上一个处理完的节点（这是解题的关键重点）。**

我们规定始终以左子树，右子树，根节点的后序顺序处理各个节点。
此时当我拿出一个节点node时，prev恰好是其右子节点，说明此时这棵树已经完成处理。
可以直接将node.val入res并prev置node。

另一可能，prev是node.left的情况。此时node左子树已经处理完成，接下来就要处理右子树了。
当然别忘了此时node在栈外，所以是先node入栈然后node.right入栈。

最后，如果prev不是node的任意一个子节点，此时，说明node和prev的关系应该是某个高级节点的右子树和左子树。
此时就需要node遍历到其最左下角节点，并从这里开始处理node这个右子树。

更多说明建议参考教科书。
自己写的代码烂得一批……