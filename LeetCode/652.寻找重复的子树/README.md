## 题目描述
给定一棵二叉树 root，返回所有重复的子树。

对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。

如果两棵树具有相同的结构和相同的结点值，则它们是重复的。

示例 1：

![](https://assets.leetcode.com/uploads/2020/08/16/e1.jpg)
```
输入：root = [1,2,3,4,null,2,4,null,null,4]
输出：[[2,4],[4]]
```
示例 2：

![](https://assets.leetcode.com/uploads/2020/08/16/e2.jpg)
```
输入：root = [2,1,1]
输出：[[1]]
```
示例 3：

![](https://assets.leetcode.com/uploads/2020/08/16/e33.jpg)
```
输入：root = [2,2,2,3,null,3,null]
输出：[[2,3],[3]]
```

提示：
```
树中的结点数在[1,10^4]范围内。
-200 <= Node.val <= 200
```

### 解法 DFS
看到这题，第一个想法是，先写一个树的序列化函数，然后DFS遍历每个子树，并且计算其序列化结果。
然后在外部维护一个计数器，维护树的序列以及其出现的次数。

显然，当某个序列的计数超过2的时候，就有重复子树，此时将`node`收割即可。

但是因为序列化函数没法用cache等手段进行加速，所以每次序列化其实都是一个重复遍历整个子树的过程，显然整个过程的复杂度会来到`O(n^2)`。

最后结果，虽然AC但是果然性能很差。

于是考虑用其他办法。

注意到，这里的树的一个序列化后的字符串，仅仅是一个标识，虽然标识需要和树的结构有关联，但是并不一定每次都要遍历树。
出于这个考虑，实际上可以随便拿一个值，比如生成一个uuid作为树的标识，然后将uuid和树结构关联起来，再进行DFS即可。

具体的，我们定义一个DFS函数，在函数中，我们以`node.val, dfs(node.left), dfs(node.right)`这样一个三元组作为一个树的标识。
并且将这样一个三元组与一个uuid的对应维护起来。
之后，只需要维护一个计数器看各个uuid的出现次数即可。

具体见代码。