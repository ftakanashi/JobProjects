## 题目描述
给你一个二维整数数组 intervals ，其中 intervals[i] = [lefti, righti] 表示第 i 个区间开始于 lefti 、结束于 righti（包含两侧取值，闭区间）。区间的 长度 定义为区间中包含的整数数目，更正式地表达是 righti - lefti + 1 。

再给你一个整数数组 queries 。第 j 个查询的答案是满足 lefti <= queries[j] <= righti 的 长度最小区间 i 的长度 。如果不存在这样的区间，那么答案是 -1 。

以数组形式返回对应查询的所有答案。

示例 1：
```
输入：intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]
输出：[3,3,1,4]
解释：查询处理如下：
- Query = 2 ：区间 [2,4] 是包含 2 的最小区间，答案为 4 - 2 + 1 = 3 。
- Query = 3 ：区间 [2,4] 是包含 3 的最小区间，答案为 4 - 2 + 1 = 3 。
- Query = 4 ：区间 [4,4] 是包含 4 的最小区间，答案为 4 - 4 + 1 = 1 。
- Query = 5 ：区间 [3,6] 是包含 5 的最小区间，答案为 6 - 3 + 1 = 4 。
```
示例 2：
```
输入：intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]
输出：[2,-1,4,6]
解释：查询处理如下：
- Query = 2 ：区间 [2,3] 是包含 2 的最小区间，答案为 3 - 2 + 1 = 2 。
- Query = 19：不存在包含 19 的区间，答案为 -1 。
- Query = 5 ：区间 [2,5] 是包含 5 的最小区间，答案为 5 - 2 + 1 = 4 。
- Query = 22：区间 [20,25] 是包含 22 的最小区间，答案为 25 - 20 + 1 = 6 。
```

提示：
```
1 <= intervals.length <= 105
1 <= queries.length <= 105
queries[i].length == 2
1 <= lefti <= righti <= 107
1 <= queries[j] <= 107
```

### 解法 堆
题意不难理解，至于解法是直接抄别人的。这个解法，我只能说凭自己是比较难想到的。
但是知道了这个解法之后又发现它是如此简洁有力，并且合理。

首先由于题目中的interval和query都是乱序的，不方便处理。
可以先各自排个序。

query没啥可说的，直接从小到大排序即可。
奥妙在于interval如何排序。

我们考虑，query从小到大排序后，从小到大扫描时，如果一个query已经找到了对应的最小区间，那么接下来更大的query
只可能对应这个区间和更加靠右的那些区间。

于是，对于interval，我们可以先按照区间的左端点进行排序。
排序完成后，根据区间长度和右端点为基准维护一个堆。
具体的，从左到右遍历query，同时从左到右遍历interval。碰到值`q`的时候，将所有左端点小于等于`q`的interval都入堆。
表示这些区间可能会是包含`q`的区间。
由于堆是小顶堆并且以长度和右端点为排序基准，这么一来，此时处于堆顶的区间只要包含`q`就必然是`q`对应的最小区间。
若不包含`q`，则我们可以直接pop掉这个区间。也不用担心pop掉之后这个区间是否可能会是后续其他`q`的最小区间。
因为这个区间既然连`q`都不包含（并且别忘了其左端点小于等于`q`，这也就意味着其右端点也必然小于`q`才能做到不包含`q`），后面更大的数
就更加不可能包含了。

进一步的，如果pop一波后堆空了，这就说明当前所有左端点小于等于`q`的那些"可能包含`q`的区间"都不包含`q`，此时`q`没有对应的最小区间。
只能返回-1。

最后别忘了输出的数组要和原输入的`queries`下标一一对应，所以最开始对`queries`进行排序时需要带上下标，然后填空ans。