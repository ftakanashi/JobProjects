## 题目描述

如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：

二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。

偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增

奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减

给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。

示例 1：
>![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_1_1966.png)
>
>输入：root = [1,10,4,3,null,7,9,12,8,6,null,null,2]
>
>输出：true
>
>解释：每一层的节点值分别是：
>
>0 层：[1]
>
>1 层：[10,4]
>
>2 层：[3,7,9]
>
>3 层：[12,8,6,2]
>
>由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。

示例 2：
>![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_2_1966.png)
>
>输入：root = [5,4,2,3,3,7]
>
>输出：false
>
>解释：每一层的节点值分别是：
>
>0 层：[5]
>
>1 层：[4,2]
>
>2 层：[3,3,7]
>
>2 层上的节点值不满足严格递增的条件，所以这不是一棵奇偶树。

示例 3:
>![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_1_333_1966.png)
>
>输入：root = [5,9,1,3,5,7]
>
>输出：false
>
>解释：1 层上的节点值应为偶数。

示例 4：
>输入：root = [1]
>
>输出：true

示例 5：
>输入：root = [11,8,6,1,3,9,11,30,20,18,16,12,10,4,2,17]
>
>输出：true


### 解法 BFS遍历检查
题意不是很复杂，也可以看得出来就是用BFS就可以解决这个问题。

只是一般BFS关注点在"遍历完元素"这一点上，而在这题里，显然，遍历的时候要关注"层之间的区别"。

为了做到这点，可按照这样的范式来写代码顺序：首先遍历一遍当前队列把所有当前层元素处理一遍。
然后，再遍历一遍把当前层节点popleft出来，然后append其子节点进队。

再仔细一想，其实上面过程可以在一个for循环内完成，无非是这个循环的跳出条件不是传统BFS中的queue.empty()，
而是循环开始时的队列长度。即循环固定此时，保证处理节点次数不超过本层节点个数。

如此，便可以按层来处理节点的同时，BFS完整棵树。

另外注意题目中的两个判断条件，

第一是所有节点的奇偶性应该和所在层的level值的奇偶性相异。

第二是偶数层的严格递增和奇数层的严格递减。

所以代码需要额外维护一个level层数以及switch的flag用于判严格递增还是递减。