## 题目描述
给你一个整数数组 arr ，你一开始在数组的第一个元素处（下标为 0）。

每一步，你可以从下标 i 跳到下标：
```
i + 1 满足：i + 1 < arr.length
i - 1 满足：i - 1 >= 0
j 满足：arr[i] == arr[j] 且 i != j
```
请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。

注意：任何时候你都不能跳到数组外面。

示例 1：
```
输入：arr = [100,-23,-23,404,100,23,23,23,3,404]
输出：3
解释：那你需要跳跃 3 次，下标依次为 0 --> 4 --> 3 --> 9 。下标 9 为数组的最后一个元素的下标。
```
示例 2：
```
输入：arr = [7]
输出：0
解释：一开始就在最后一个元素处，所以你不需要跳跃。
```
示例 3：
```
输入：arr = [7,6,9,6,9,6,9,7]
输出：1
解释：你可以直接从下标 0 处跳到下标 7 处，也就是数组的最后一个元素处。
```
示例 4：
```
输入：arr = [6,1,9]
输出：2
```
示例 5：
```
输入：arr = [11,22,7,7,7,7,7,7,7,22,13]
输出：3
```

提示：
```
1 <= arr.length <= 5 * 10^4
-10^8 <= arr[i] <= 10^8
```

### 解法 BFS + 哈希表优化
乍一看以为这题要用并查集，但是仔细思考之后发现并查集在这没用。因为默认可以一格一格走，因此其实整个数组处于同一个连通分量中。

于是思考搜索的办法。
将每个数字视为一个节点，相邻数字以及相同数字之间有一条边。
那么这个问题就是在一个无向图中寻找一条两点之间的最短路径问题。
显然可以使用BFS，第一次走到终点时就结束搜索提升效率。

问题是，如果直接无脑BFS，会超时。
一般的BFS思路大概是这样的：
建立一个queue和一个seen，将`(0, 0)`加入queue，表示从下标为0的原点走了0步。
接着，每从queue中pop出一个`pos, step`时，检查其pos是否在seen中，若是直接跳过，若否将其加入seen，并且探索`pos +- 1`以及所有和pos位置同值 的位置。
由于需要知道每个值有哪些同值的位置，因此事先还需要维护一个num2pos的哈希表，用来维护每个值分别散布在哪些下标处。

在这题中，上述算法可能会遇到的问题是，本题中可能存在大量相同的数字，导致探索同值位置出现大量冗余计算。

一个例子case就是一个长度为10000的数组，前9999个都是7，最后一个是11。
显然，按照上述算法进行BFS探索时，每扫描到一个7，都会将剩余9998个7全部入队列，尽管队列再pop出他们时会因为他们的位置
在seen中而continue掉，但这仍然避免不了队列过于膨胀。

一个显而易见的优化思路是将seen.add操作放在某个位置被加入队列之前。
但是每次扫描到7之后仍然需要进行9998次的in操作，而这些in全部都是True，都是白费的时间（虽然空间上省了)

跳出来考虑，当扫描到某个数字之后，实际上进行下一步同值位置探索的时候，是一口气将所有同值位置加入队列的。
换言之，反正是一锤子买卖，所以一旦加入后，原哈希表num2pos实际上就可以pop掉这个值了。
放到上面的具体例子中，当扫描到原点时，我直接一口气将下标`0`到`9998`全部放入队列，接着`num2pos.pop(7)`。
接着扫描到下标`1`时，此时值仍然是`7`，但是`7 in num2pos`是False，就不用再考虑这种情况了。

结合了这个对哈希表及时的剪枝优化后，就可以得到AC的代码了。