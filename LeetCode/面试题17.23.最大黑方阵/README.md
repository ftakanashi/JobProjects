## 题目描述
给定一个方阵，其中每个单元(像素)非黑即白。设计一个算法，找出 4 条边皆为黑色像素的最大子方阵。

返回一个数组 [r, c, size] ，其中 r, c 分别代表子方阵左上角的行号和列号，size 是子方阵的边长。若有多个满足条件的子方阵，返回 r 最小的，若 r 相同，返回 c 最小的子方阵。若无满足条件的子方阵，返回空数组。

示例 1:
```
输入:
[
   [1,0,1],
   [0,0,1],
   [0,0,1]
]
输出: [1,0,2]
解释: 输入中 0 代表黑色，1 代表白色，标粗的元素即为满足条件的最大子方阵
```
示例 2:
```
输入:
[
   [0,1,1],
   [1,0,1],
   [1,1,0]
]
输出: [0,0,1]
```
提示：
```
matrix.length == matrix[0].length <= 200
```

### 解法 前缀和 + 检查边的合法性
首先注意审题。这题的输入以及要求给出的输出都是方阵，即正方形。
其次，要求给出的输出只要四条边上都是0即可。内部可以有1。

这道题，乍一看和一票求大矩阵中小矩阵相关性质的问题很像比如`LC.363, LC.1074, 面试题17.24, LC.85`等等。
当然，仔细一看就知道，这题和前三者关系不大。前三题关心的，都具体到矩阵中每个格子的值。
顺便一提，这类题通常使用 "行对枚举 二维转一维" + 前缀和的办法来做。

而这题，元素都是0和1，显然和`LC.85`的血缘关系更近。

一开始看标签里有DP，想了好久的DP都没想到合适的状态转移方程。
看了答案才发现，其实这题根本没那么复杂，而做法，其实也不算严格意义上的DP吧。

首先，要形成一个符合要求的子矩阵，从其右下角的位置来看，条件无非就是：
- 其上边有e个0
- 其左边有e个0
- 左边e个0后的那个元素上边有e个0
- 上边e个0后的那个元素左边有e个0

e是边长。也就是4条边都是0即可。

于是做法就很简单，通过像`LC.85`那样先累计计数0的连续个数。以左和上为方向。
比如原矩阵是
```text
1 0 1
0 0 1
0 0 1
```
那么左方向的计数矩阵`left`就是
```text
0 1 0
1 2 0
1 2 0
```
上方向的计数矩阵`up`是
```text
0 1 0
1 2 0
2 3 0
```
这样，对于任意一个位置比如`2,1`而言，我只要按照上面说过的检查四条边的规则，发现:
```text
最大可能的边长是 min(left[2][1], up[2][1]) = 2
而 up[2][1-2+1] 即左下角的上方有2个0；
left[2-2+1][1] 即右上角的左方有2个0； 
```
这么一来，说明对于位置`2,1`，最大边长2就是合法的了。

当然，更多情况下比如位置`1,1`，虽然其最大可能的边长也是2，但是经过检查后发现并不能做到符合条件（因为位置`0,0`是1），
此时也不能就此断定`1,1`不符条件，应该将边长减1，缩小范围继续检查。经检查，边长设定为1时，符合要求了。

所以，边长探索过程是一个从最大可能边长开始逐渐缩小的过程。
当然，探索的起点处的matrix值必须是0，要不然就无从谈起了。

按照以上想法，朴素地写代码即可。
代码中补充了一些注释方便理解。