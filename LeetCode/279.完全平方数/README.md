## 题目描述
给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

示例 1：
```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```
示例 2：
```
输入：n = 13
输出：2
解释：13 = 4 + 9
```
提示：
- 1 <= n <= 10^4

### 解法 BFS
其实带有一点贪心的味道。

由于题目给出条件是n不大于10000,很明显，可选的完全平方数最大也就10000，即候选完全平方数是`[i**2 for i in range(101)]`。

这么一来就很好办了。对于一个数字，由于要个数尽量少，所以我选择从末尾开始遍历完全平方数候选，即优先选择尽量大的完全平方数作为组成因子。

每选择一个后，`n - square`的剩余部分再去做同样操作，直到剩余部分为0。（其实这是递归或者说DFS的味道，不过这题还是用BFS硬写了）

需要注意，对于`rest = n - square`，如果还是从10000开始从后往前遍历会超时。需要优化。

一个明显的优化思路就是，对于rest，其实从square开始扫描就行，因为rest不可能比n大而比square大的那些完全平方数也比n大。

基于以上思路和优化思路写代码。

#### 2021/06/11追加笔记
这道题挺恶心的。。

首先，无论是DFS，BFS还是DP，思路都是比较清晰的。
核心都是将输入`n`通过减去一个完全平方数后剩余的`rest`视作一个更小规模的问题去解，只要把解+1就可以得到原问题的答案了。

然而，不论是用DFS还是BFS，还是DP，我怎么做都超时。
另外官方虽然给出了DP代码，但是没有Python版本。我把Java的翻译成Python后提交，还是超时。

以BFS为例，我写的第一版代码大概这样：
```python
q = deque()
q.append((n, 0))
while q:
    rest, cnt = q.popleft()
    if rest == 0: return cnt
    for i in range(int(sqrt(rest)), 0, -1):
        q.append((rest - i**2, cnt + 1))
return n
```
上述代码因为超时，需要进一步优化。
优化点主要在下面三点。

第一，在试图从rest中减去一个完全平方数的时候，要计算一次`sqrt(rest)`。虽然这里使用了库函数，但是本质上并不是O(1)
操作。另一方面，由于这个循环从大到小遍历因子`i`，因此其实可以保证`rest - i**2`总是小于rest的一半的
（假设rest恰好是两个完全平方数的和即`rest = a + b`，假设`a < b`，那么肯定在前半段遍历就已经有了`b = i**2`的情况，没必要到后半段计`a = i**2`的情况）

因此，可以考虑将当前因子`i`也一并加入队列，而每次从rest中减去完全平方数的操作，从上一轮的`i`开始即可，没必要计算`sqrt(rest)`。
这也是最大的一个优化点

第二，优化上面那点之后，由于不在保证`rest - i**2 >= 0`了，所以循环中可以添加一条判断以过滤这些没必要考虑的情况，节省队列空间。

第三，注意到代码中多次计算`i ** 2`，有大量重复计算。虽说理论上这个操作是O(1)的，但是实际上优化后时间性能有很大提升…
怎么优化？空间换时间。因为题目规定了n最大不过10000，即i最大不过100。所以提前设置一个`squares = [i**2 for i in range(101)]`。
之后取`squares[i]`就可以得到`i**2`了。

结合以上三点之后就写出解法1的代码了：
```python
from math import sqrt
from collections import deque
class Solution:
    def numSquares(self, n: int) -> int:
        q = deque([])
        q.append((n, 0, 100))
        squares = [i**2 for i in range(101)]    # 优化3 O1时间计算平方
        while q:
            rest, cnt, prev_i = q.popleft()
            if rest == 0: return cnt
            for i in range(prev_i, 0, -1):
                if rest >= squares[i]:    # 优化2 别忘了可以continue的情况，从而避免队列内存超容
                    q.append((rest - squares[i], cnt + 1, i))    # 优化1 上一轮i也入对 最重要优化
        
        return n
```

### 解法2 数学
万万没想到这题居然还有数学解法。。

用到的定理是四平方和定理，其内容是，任意一个正整数都可以被表示为至多四个完全平方数的和。
换言之，这题的返回只有`1, 2, 3, 4`四种可能。

然后这个定理还有一个更有趣的推论，当上述答案是4的时候，充分必要条件是这个正整数可以被表示为`4^k * (8m+7)`。
另外显然，如果这个数本身是完全平方数，那么答案是1。

如此1和4这两个答案可以很快判断出来。

接着是2和3。注意到如果答案是2，那么就遍历扫描`1, sqrt(n)`之间的所有整数，看`n`是不是两个完全平方数的和就行了。

如果排除了答案1，2，4还没找到可能，那么答案就是3了。

以上，通过O(sqrt(n))的复杂度就可获得答案。