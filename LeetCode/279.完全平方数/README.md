## 题目描述
给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

示例 1：
```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```
示例 2：
```
输入：n = 13
输出：2
解释：13 = 4 + 9
```
提示：
- 1 <= n <= 10^4

### 解法 BFS
其实带有一点贪心的味道。

由于题目给出条件是n不大于10000,很明显，可选的完全平方数最大也就10000，即候选完全平方数是`[i**2 for i in range(101)]`。

这么一来就很好办了。对于一个数字，由于要个数尽量少，所以我选择从末尾开始遍历完全平方数候选，即优先选择尽量大的完全平方数作为组成因子。

每选择一个后，`n - square`的剩余部分再去做同样操作，直到剩余部分为0。（其实这是递归或者说DFS的味道，不过这题还是用BFS硬写了）

需要注意，对于`rest = n - square`，如果还是从10000开始从后往前遍历会超时。需要优化。

一个明显的优化思路就是，对于rest，其实从square开始扫描就行，因为rest不可能比n大而比square大的那些完全平方数也比n大。

基于以上思路和优化思路写代码。