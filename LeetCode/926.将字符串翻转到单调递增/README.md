## 题目描述
如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。

给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。

返回使 s 单调递增的最小翻转次数。

示例 1：
```
输入：s = "00110"
输出：1
解释：翻转最后一位得到 00111.
```
示例 2：
```
输入：s = "010110"
输出：2
解释：翻转得到 011111，或者是 000111。
```
示例 3：
```
输入：s = "00011000"
输出：2
解释：翻转得到 00000000。
```

提示：
```
1 <= s.length <= 105
s[i] 为 '0' 或 '1'
```

### 解法 DP
今天感觉很准…看了这题一会儿感觉得用DP，尝试了一下AC了。

直接来说，构建DP数组`[[0, 0] for _ in range(n)]`。其中`dp[i][j]`表示原字符串`s`的前`i`位数字经过翻转后末尾是`j`（`j`是0或者1）的情况，
需要最小翻转多少次。

然后想一下递推公式。

当当前位数字`s[i]`是0的时候，很显然`dp[i][0]`应该是`dp[i-1][0]`因为只要你前面都是0了，再加上我一个就能做到全0串符合题意要求。
另一方面，`dp[i][1]`应该是`dp[i-1][1] + 1`。因为前面只要末尾是1了，只要将本位置也翻转成1，也符合题意要求。
这其中其实含隐含了一种情况，也就是前面全是0，然后把本位置翻转成1，也是一种末尾是1的可能性。但问题是这种可能性的翻转次数必然大于`dp[i-1][0]`，
而由于最后显然是要以`min(dp[-1])`作为答案的，所以可以忽略。

接下来考虑`s[i]`是1的情况。此时`dp[i][0] = dp[i-1][0] + 1`。相当于前面全是0，然后把本位置的1翻转成0。
最后是稍有些复杂的`dp[i][1]`。
考虑如下两种情况，第一种，前面全是1，那么直接追加本位置的1，相当于是`dp[i][1] = dp[i-1][1]`。
第二种，前面全是0，也可以直接追加，相当于`dp[i][1] = dp[i-1][0]`。
总的来看，可以说`dp[i][1] = min(dp[i-1])`。

最后初始状态根据首位是0还是1分类讨论即可。或者也可在最前面插入一个空位`0,0`。

以上。