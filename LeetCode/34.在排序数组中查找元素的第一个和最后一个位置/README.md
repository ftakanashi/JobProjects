##题目描述

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

进阶：
- 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？
 

示例 1：
>输入：nums = [5,7,7,8,8,10], target = 8
>
>输出：[3,4]

示例 2：
>输入：nums = [5,7,7,8,8,10], target = 6
>
>输出：[-1,-1]

示例 3：
>输入：nums = [], target = 0
>
>输出：[-1,-1]
 

提示：
- 0 <= nums.length <= 105
- -109 <= nums[i] <= 109
- nums 是一个非递减数组
- -109 <= target <= 109

### 解法1 双指针
不解释。O(n)。

记得循环条件加边界检查以及`i > j`的时候返回`-1, -1`。

### 解法2 二分查找
一开始想到的二分查找是先二分查找到任意一个target位置。然后从那个位置开始分别向前后扫描。

不过这个办法并非O(logn)。虽然二分查找过程是的，但是后续的扫描，如果target的区间很大，或者整个数组都是同一个数，那么显然还是O(n)了。

另一方面，题意也很清楚，在数组中找到某个target值形成区块的第一个值的位置和最后一个值的位置即可。其实求这两个值分别是二分查找的两个变体。

两个变体在代码上的区别就在于如何处理`nums[mid] == target`的情况，以及，返回left还是right。知道了这个情况之后，就直接做两次二分查找即可。

为了代码复用，定义一个额外的二分查找方法，并在方法参数里加上是否寻找左边界的bool参数即可。