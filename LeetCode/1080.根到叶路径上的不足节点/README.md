## 题目描述
给你二叉树的根节点 root 和一个整数 limit ，请你同时删除树中所有 不足节点 ，并返回最终二叉树的根节点。

假如通过节点 node 的每种可能的 “根-叶” 路径上值的总和全都小于给定的 limit，则该节点被称之为 不足节点 ，需要被删除。

叶子节点，就是没有子节点的节点。

示例 1：

![](https://assets.leetcode.com/uploads/2019/06/05/insufficient-11.png)
```
输入：root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1
输出：[1,2,3,4,null,null,7,8,9,null,14]
```
示例 2：
```
输入：root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22
输出：[5,4,8,11,null,17,4,7,null,null,null,5]
```
示例 3：
```
输入：root = [1,2,-3,-5,null,4,null], limit = -1
输出：[1,null,-3,4]
```

提示：
```
树中节点数目在范围 [1, 5000] 内
-105 <= Node.val <= 105
-109 <= limit <= 109
```

### 解法 DFS
二叉树，无脑DFS就完了。不过问题在于如何设计dfs函数的逻辑和返回值。
这里提供这样一种思路。

首先还是得仔细审题，搞清楚所谓的"不足节点"到底是什么含义。
题目中明确了，不足节点是指 任意 一条经过该节点的根叶路径，都综合都不满足limit的要求。而不是从该节点开始到叶子的路径不满足limit要求。
我一开始理解错了这一点，导致浪费了很多时间。

我们设计dfs函数为`dfs(node, path)`。`node`当然表示扫描到的某个节点，而`path`表示从根节点到当前节点整个路径上所有节点的和。
而这个函数，我们期望他返回`node`节点是否 "足" 了。也就是说当他不是不足节点的是否返回True，反之返回False。

递归边界，显然是叶子节点，只需要返回 `node.val >= limit`即可。

在函数体中，面对`node`，我们可以先分别对其两个子节点进行进一步的递归`dfs(node.left, node.val + path)`和`dfs(node.right, node.val + path)`。
从而可以得到两个左右子节点是否是不足节点，需要删除。
如果是，那么就直接将对应节点删除例如`node.left = None`。

接着考虑这层递归的返回。
注意到只要左或者右子节点返回了True，这就说明在两个子节点中至少有一个满足不是"不足节点"的要求。
换言之，所有经过那个节点的根叶路径中，至少有一条是满足limit要求的。
而因为`node`是他的父节点，所以这条路径一定是通过`node`的，从而证明了`node`本身不是"不足节点"。

这一套逻辑，简化一下就是，`dfs(node.left, node.val + path) or dfs(node.right, node.val + path)`，就是本层递归的返回。


最后，最外层执行一次`dfs(root, 0)`即可。
但是还需要考虑到root节点本身是不足节点的情况，此时根据题意整棵树都该砍掉了。所以应该返回None。