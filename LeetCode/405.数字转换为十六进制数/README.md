## 题目描述
给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。

注意:

- 十六进制中所有字母(a-f)都必须是小写。
- 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 
- 给定的数确保在32位有符号整数范围内。
- 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。

示例 1：
```
输入:
26

输出:
"1a"
```
示例 2：
```
输入:
-1

输出:
"ffffffff"
```

### 解法1 经过二进制中介进行模拟
这题题设是一点都不难。但是细节上还是有一些可以注意下的地方。

对这种32位整数的题目Python处理总是稍微麻烦一点，毕竟不支持整数位数的概念。
这里我们采取一个最麻烦最常规的办法。

首先对num的正负性进行讨论。大于0的直接按照进制转就是了，等于0则直接返回`"0"`。
问题在于小于零的情况。

当num是负数时，首先将其取绝对值，接着求出其绝对值的二进制表达。将最高位符号位置1。
然后根据补码取反+1的原则对二进制表达进行响应的处理。这里取反不难，稍微复杂一点的是+1涉及到进位。当然这里二进制表达的话进位代码也不难写了。

最后以四位一组的形式，输出十六进制即可。

### 解法2 利用Python自带的负数进制处理特性
其实如果不考虑这么多，直接"把负数也看成正数"来处理，这题也是不会出错的。
这是因为Python中对负数的相关运算做了匹配。

例如，`-1 % 16`结果是`15`，即直接求出了其最低位的十六进制表达是`f`。
再例如`-1 // 16`结果是`-1`，保证计算下一位时还能求出`f`。

如上所示，`-1//16`永远是`-1`，所以这里的循环条件显然不能是`num != 0`之类的。
因为题目给出了限定32位，所以答案最多是8个十六进制数，因此直接`for _ in range(8)`即可。

另外，要求输出中没有前导0，因此当num是0的时候就可以不用继续计算满8次，直接break即可。

根据上述思想写成第二种解法 代码。
说说可能很难懂，建议实际看下代码，就知道Python在这里面做的一些工作了。