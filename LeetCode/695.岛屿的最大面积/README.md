## 题目描述
给定一个包含了一些 0 和 1 的非空二维数组 grid 。

一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)

 

示例 1:
```
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。
```

示例 2:
```
[[0,0,0,0,0,0,0,0]]
对于上面这个给定的矩阵, 返回 0。
```
 
```
注意: 给定的矩阵grid 的长度和宽度都不超过 50。
```

### 解法1 BFS
一看就知道，可以用BFS或者DFS做。先来看BFS。

对于这种二维矩阵多块区域的BFS，必然要挨个区域探索。
为了避免从不同起点开始对同一片区域的重复探索，可以在外围设置一个seen哈希集，保存已经访问过的位置。
这个哈希集的另一个用处，就是在对一片区域的BFS过程内，防止对已经访问过的位置再访问导致死循环。

因为这题要求的是区域面积，所以从BFS队列中每弹出一个位置，只要其还没有被访问过（即不在seen中）这个区域的面积就可+1。

最后比较每个区域的面积，将其中最大值返回即可。

### 解法2 DFS
同样为了避免从不同起点出发的DFS重复探索一片区域多次，在外围设置seen哈希集。

其余的就是dfs函数返回一个数值，最小当然是1，其实是返回从当前格子出发能够探索到的格子总面积。
四个方向的dfs函数值返回加上1就是整个区域的面积了。