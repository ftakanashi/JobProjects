## 题目描述
给定一个长度为 n 的整数数组 nums ，其中 nums 是范围为 [1，n] 的整数的排列。还提供了一个 2D 整数数组 sequences ，其中 sequences[i] 是 nums 的子序列。
检查 nums 是否是唯一的最短 超序列 。最短 超序列 是 长度最短 的序列，并且所有序列 sequences[i] 都是它的子序列。对于给定的数组 sequences ，可能存在多个有效的 超序列 。

例如，对于 sequences = [[1,2],[1,3]] ，有两个最短的 超序列 ，[1,2,3] 和 [1,3,2] 。
而对于 sequences = [[1,2],[1,3],[1,2,3]] ，唯一可能的最短 超序列 是 [1,2,3] 。[1,2,3,4] 是可能的超序列，但不是最短的。

如果 nums 是序列的唯一最短 超序列 ，则返回 true ，否则返回 false 。
子序列 是一个可以通过从另一个序列中删除一些元素或不删除任何元素，而不改变其余元素的顺序的序列。

示例 1：
```
输入：nums = [1,2,3], sequences = [[1,2],[1,3]]
输出：false
解释：有两种可能的超序列：[1,2,3]和[1,3,2]。
序列 [1,2] 是[1,2,3]和[1,3,2]的子序列。
序列 [1,3] 是[1,2,3]和[1,3,2]的子序列。
因为 nums 不是唯一最短的超序列，所以返回false。
```
示例 2：
```
输入：nums = [1,2,3], sequences = [[1,2]]
输出：false
解释：最短可能的超序列为 [1,2]。
序列 [1,2] 是它的子序列：[1,2]。
因为 nums 不是最短的超序列，所以返回false。
```
示例 3：
```
输入：nums = [1,2,3], sequences = [[1,2],[1,3],[2,3]]
输出：true
解释：最短可能的超序列为[1,2,3]。
序列 [1,2] 是它的一个子序列：[1,2,3]。
序列 [1,3] 是它的一个子序列：[1,2,3]。
序列 [2,3] 是它的一个子序列：[1,2,3]。
因为 nums 是唯一最短的超序列，所以返回true。
```

提示：
```
n == nums.length
1 <= n <= 104
nums 是 [1, n] 范围内所有整数的排列
1 <= sequences.length <= 104
1 <= sequences[i].length <= 104
1 <= sum(sequences[i].length) <= 105
1 <= sequences[i][j] <= n
sequences 的所有数组都是 唯一 的
sequences[i] 是 nums 的一个子序列
```

### 审题
题目可能稍微有点拗口…
简单来说，就是`sequences`当中有一些子序列。题目保证`nums`可以提供这些子序列。但是可以提供这些子序列的超序列可能会有多个。
题目问的，就是`nums`是否是唯一一个可以提供这些子序列的超序列，且是最短超序列

### 解法 图 拓扑排序
这题虽然标签有拓扑排序，但是并不是狭义上的拓扑排序问题（即给出一个有向图，让你求出一个符合拓扑关系的序列），而是另一个小变体。
即，给出一个有向图与一个拓扑排序序列，问这个排序序列是否是这个图的唯一拓扑排序。

这个变体的做法实际上比狭义上的拓扑排序还要简单一些。
因为求唯一性只需要在遍历过程中实时检测下一步能走的节点是否唯一即可。下面是具体的思路。

第一步我们先要构建图以及维护一个统计了所有节点的入度的数组。
具体到这道题，构建图很简单：遍历所有`sequences`中的序列，并将所有相邻的`a,b`数对以`a -> b`边的形式添加进图里即可。
这个过程中入度的数组`in_deg`也可以统计完成。

下一步，我们维护一个队列`q`，队列中始终维护着下一步可以走的节点的编号。
显然，当某轮遍历开始时，若`q`的总长度大于1，那么说明下一步有多个可能可以走的节点，因此在求唯一性这个问题上我们可以直接返回False。
另一方面，若`q`长度为0，无路可走，也可以直接返回False。不过这题保证了`sequences`中所有序列都是合法的`nums`子序列，也就不会出现环的情况，所以不会有`q`长度为零的情况出现。

而`q`长度为1是理想情况，直接往下走即可。
此时还需要及时更新`in_deg`，并且将下一个节点加入队列。

举个简单的例子，假如`q`在初始状态下长度就是2，说明整个图有两个最上层的节点。此时，由于这两个节点之间互相是平等的，所以在拓扑排序中无论哪个节点
放在第一位都是合法的序列，这就说明拓扑排序序列绝对不唯一了。

更多细节请看代码。