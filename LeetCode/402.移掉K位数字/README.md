## 题目描述

给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。

注意:

num 的长度小于 10002 且 ≥ k。

num 不会包含任何前导零。

示例 1 :
>输入: num = "1432219", k = 3
>
>输出: "1219"
>
>解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。

示例 2 :
>输入: num = "10200", k = 1
>
>输出: "200"
>
>解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。

示例 3 :
>输入: num = "10", k = 2
>
>输出: "0"
>
>解释: 从原数字移除所有的数字，剩余为空就是0。

示例 4：
>输入：num = "5337", k = 2
>
>输出："33"
>
>解释：移除5和7两个数字，剩余33是最小的。


### 审题
这道题目，其实代码实现方面不是很困难，只是要找到思路，如何解决比较麻烦。
所以在给出一个具体的代码解答之前，我们还是先来看下这道题到底在问什么。

首先明确一件事，移除的数字可以是不相邻的。所以并不是简单的一个滑动窗口就能解决的。

另一方面，从最简单的情况入手，删除一位数字后，剩下的数字按原顺序连接起来怎么样才能让其值最小呢。

比如1432219这个数字，删除一位数字的时候显然凭感觉可以知道删除4是最好的。但是要让感觉慢下来，
仔细分析为什么4是最好的。

可以感觉到，删除的数字越靠左，数字越大，那么删除它带来的"收益"越大。越靠左，说明可以从左到右扫描数字，
越大，多大算大呢。比如1231...这样一个数，从左往右，删除1，肯定不行，首位变成2了。
删除2，第二位就变成了3，也不行。依次类推，即当删除某个数之后，他后面那个数，将补位上来。如果那个数比他本身大，
那么显然，删除它是不合适的，不如保留他删除下一位。

有了这个思路，整理一下很快就可以得到一个更加完整的描述，要删除的那个数，其实是从左到右扫描的一个不递减序列的最后一位数。
比如1231...时，那个数就是3。1432219时，那个数是4。

以上是删除一位的情况，如果k>1，显然可以把这个操作连着做k次就行了。这还要解决的一个问题是如何证明每一步得到的解都是最优的。
如果是的话，那么这就是一个贪心的思想咯。

虽然不给出严格证明，但是注意到，输入的num是定长，而k也是定值。所以最终输出的位数是确定的。
比如1432219且k=2的时候，第一次删除4，第二次删除3是贪心得到的结果。
而第一次如果不删除4，那怎么着最终都会是14...开头的东西，肯定大于12...开头。
因此大概可以知道，这是一个局部最优解，即按照上述删除一位的做法不断地做，不断地优化剩余的num，可以得到正确答案。

即，这就是一个贪心法。

### 解法2 单调栈 **推荐记这个**
>类似套路还有LC316, LC321, LC1081

补充一个通过栈实现的解法。
是这么回事，上面审题中说的思想，其实可以换个说法。就是从左到右扫描，当发现某个数字比其左边的更小，那么就删除其左边的数字。
这其实就可以用一个单调栈来解决了。

比如`1432219`的情况，从左到右扫描依次入栈，保持栈的单调递增。栈变化情况如下：
```text
1
1 4
1 3
1 2
1 2 2
===
1 2 1
1 2 1 9
```
注意上面过程并非全程都有单调性。分界点在划线处。
在维护单调栈的过程中每发生一次pop都计数，当发生k次pop之后无需继续删除数字，因此可以直接把剩余数字全部入站。

完成遍历后，直接将栈中数字串联起来即可。

这里还需要考虑一些特殊情况，
第一，如果数列本身是一个递增的数列怎么办。更一般的，上面算法过程最终得到的stack，其长度可能并没有小到我们预期的n - k。
此时可以直接暴力地选取前`n - k`个数字作为结果返回。

第二，由于题目要求返回结果不能有前导0以及结果为空字符串时返回0。为了处理这些情况，还需要写一些额外的代码。

### 解法1 贪心
有了思路，代码是很简单的了。而且上面思路天然是递归的，所以很快写出第一版递归代码。

```python
class Solution:
     def removeKdigits(self, num: str, k: int) -> str:
         if k == 0:
             res = num.lstrip('0')
             if res == '':
                 res = '0'
             return res
 
         i = 1
         while i < len(num) and int(num[i]) >= int(num[i - 1]):
             i += 1
         new_num = num[:i - 1] + num[i:]
 
         return self.removeKdigits(new_num, k - 1)
```

虽然AC了，但是时间花了很久。一看，显然，每次递归都从`i=1`开始扫描是没必要的。

因为上一层递归扫描就已经保证了到`0:i`为止的序列是不递减的了。

因此可以再递归入口设置一个从i开始扫描的参数。注意上一层递归结束后有一个字符被删除了，所以i也要相应减去1。

此外，如果删除的恰好是第一个字符，那么i-1变成了0，此时i-1变成了-1了，循环条件会变得奇怪。
所以保持i最小是1。

经过上述修改的代码如下：
```python
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:

        def remove(num: str, k: int, i: int) -> str:
            if i < 1: i = 1
            if k == 0:
                res = num.lstrip('0')
                return '0' if res == '' else res
            while i < len(num) and int(num[i]) >= int(num[i-1]):
                i += 1
            new_num = num[:i - 1] + num[i:]

            return remove(new_num, k - 1, i - 1)
        
        return remove(num, k, 1)
```

这个代码稍微加快了一点速度。但是还是不太理想。

注意到，其实我始终是为了找num开头的若干个数字形成不递减序列，然后删除这个序列的末尾数字，接着继续扫描下一个数字。

这个过程其实可以用栈来模拟。栈中保存的始终是一个不递减序列。

这样写出的最终版代码，放在了main.py中。