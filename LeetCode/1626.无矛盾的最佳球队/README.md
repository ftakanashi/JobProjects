## 题目描述
假设你是球队的经理。对于即将到来的锦标赛，你想组合一支总体得分最高的球队。球队的得分是球队中所有球员的分数 总和 。

然而，球队中的矛盾会限制球员的发挥，所以必须选出一支 没有矛盾 的球队。如果一名年龄较小球员的分数 严格大于 一名年龄较大的球员，则存在矛盾。同龄球员之间不会发生矛盾。

给你两个列表 scores 和 ages，其中每组 scores[i] 和 ages[i] 表示第 i 名球员的分数和年龄。请你返回 所有可能的无矛盾球队中得分最高那支的分数 。

示例 1：
```
输入：scores = [1,3,5,10,15], ages = [1,2,3,4,5]
输出：34
解释：你可以选中所有球员。
```
示例 2：
```
输入：scores = [4,5,6,5], ages = [2,1,2,1]
输出：16
解释：最佳的选择是后 3 名球员。注意，你可以选中多个同龄球员。
```
示例 3：
```
输入：scores = [1,2,3,5], ages = [8,9,10,1]
输出：6
解释：最佳的选择是前 3 名球员。
```

提示：
```
1 <= scores.length, ages.length <= 1000
scores.length == ages.length
1 <= scores[i] <= 106
1 <= ages[i] <= 1000
```

### 解法 排序 DP
一道比较经典的DP题。
首先DP框架应该是要想到的，因为这里没法做贪心（全局最优解没有办法通过单调的方法获取）。所以只能DP。

至于DP，我第一时间想的是能不能把所有队员按照`age, score`的顺序进行升序排序，然后从左到右扫描做处理。
不过题目有一个隐性条件，就是当age相同时互相之间不会产生矛盾。所以扫描到某个队员的两个属性分别是`a, s`时，其前面如果有同age的，处理上就会稍显麻烦。

反过来，如果按照`score, age`排序，就会好做一点。

具体的，我们首先构建`members`数组，每个元素`(score, age)`表示一个队员。将`members.sort()`。

然后，我们定义DP数组`dp[i]`表示排序后如果从前`i`个队员中选择，能够达到的最大score总和数。
对于第`i`个队员`members[i] = (s, a)`，我们可以遍历`j < i`，寻找那些`members[j][1] <= a`的位置。
由于排序的第一要素是score，且`j < i`，所以可以保证`members[j][0]`即`j`队员的分数必然小于当前`i`队员的分数。
所以只要`j`队员的年龄小于等于`i`队员的年龄，就可以保证将`i`队员和`j`队员同时选入队中。
此时就可以尝试将`dp[i]`更新为`dp[j] + members[i][0]`。

综述一下，状态转移方程式：
```python
for j in range(i):
    if members[j][1] <= members[i][1]:
        dp[i] = max(dp[i], dp[j] + members[i][0])
```

最后的答案，即`max(dp)`。

这里还要额外提一下一个思路，就是是不是有必要遍历所有`j < i`。
因为一开始我尝试了从`i-1`开始从右向左遍历，碰到第一个`members[j][1] <= members[i][1]`就更新`dp[i]`然后break掉。

这么做虽然能clear所有示例中的case，但是是不对的。
比如这样一个例子：
```python
members = [
    (10, 1),
    (20, 5),
    (21, 6),
    (22, 4),
    (30, 10),
]
```
当尝试填充DP数组，扫描到最后一位队员时，此时前面所有人的年龄都小于他，原理上来说，他可以选择任何一个`j < i`作为更新`dp[i]`的基础。

但是实际上这其中的较大值是下标2处，即`(21, 6)`队员对应的值，是51，而非下标3处`(22, 4)`队员对应的32。

所以，对于`j`的遍历还是应该做全量的，而不能break。