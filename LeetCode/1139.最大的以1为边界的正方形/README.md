## 题目描述
给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。

示例 1：
```
输入：grid = [[1,1,1],[1,0,1],[1,1,1]]
输出：9
```
示例 2：
```
输入：grid = [[1,1,0,0]]
输出：1
```

提示：
```
1 <= grid.length <= 100
1 <= grid[0].length <= 100
grid[i][j] 为 0 或 1
```

### 解法 DP
用DP还是比较容易想到的。
由于只要看边界是否为1，所以可以给每个位置都维护一个`(x, y)`的DP量。
分别表示这个位置向上和向左分别有多少个连续的1。

显然，对于所有`grid[i][j]`是0的位置，`dp[i][j] = (0, 0)`。相对的，如果是1，则`(1, 1)`。

然后是状态转移方程。
这个也比较好想。在遍历过程中，如果某个位置本身是1且上方也是1，那么显然`dp[i][j][0] = dp[i-1][j][0] + 1`就行了。
左方则是依葫芦画瓢。

这题稍有难度的，是在做出了整个DP数组后如何判断某个位置能否是一个符合题目要求的正方形的右下角。

假设最终正方形的边长是L的话，显然我们要检查`dp[i][j]`中的最小值是否大于等于L，此时保证了正方形的右边和下边。
接着检查`dp[i-L][j][1]`和`dp[i][j-L][0]`是否也都大于等于L，这保证了剩下两条边。

那么L到底如何确定，我一开始想了不少时间，还以为自己大思路错了，结果一看答案，原来就是遍历…
L最大只能是`min(dp[i][j])`，所以从`min(dp[i][j])`开始从大到小遍历即可
碰到符合上述所有条件的L，就和当前ans对比保留大者。

最终别忘了题目要求返回的事边上总的1的数量，所以返回应该是ans的平方。