## 题目描述
给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

示例 1:
```
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```
示例 2:
```
输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

### 解法 DP
这题本质上属于最大子序和系列的DP题。
模板是`LC.53`。

但是如果直接套用`LC.53`的解法，会发现有问题。
比如`2 -2 3 -3`这组输入。按照`LC.53`的思路，得到的DP数组应该是`2 -2 3 -3`。
（状态转移方程是`dp[i] = max(dp[i-1] * nums[i], nums[i])`）

问题出在，每当我想确定以一个位置为结尾的最大乘积，我只看本位制数字和上一个位置的dp值。
但如果本位置的数字是负数，显然为了达到最终乘积最大，我应该使用的是上一个位置的最小值，而dp值的定义只有最大值。

换句话说，如果上一个位置的最小值是个很小的负数，而本位置又是负数，那么两者相乘可能就是我们想要的最大乘积了。

于是，DP数组在保存"最大值"的基础上还应该再维护一个"最小值"。这样只要让当前位置乘以这两个值，取其中较大者就可以万无一失了。

具体的，状态转移方程如下：
```python
dp_max[i] = max(dp_max[i-1] * nums[i], dp_min[i-1] * nums[i], nums[i])
dp_min[i] = min(dp_max[i-1] * nums[i], dp_min[i-1] * nums[i], nums[i])
```