## 题目描述
反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

说明:
- 1 ≤ m ≤ n ≤ 链表长度。

示例:
>输入: 1->2->3->4->5->NULL, m = 2, n = 4
>
>输出: 1->4->3->2->5->NULL

### 解法 就…模拟
由于要求一遍扫描，显然最简单的就是扫描过去。

扫到第m个节点时打断其与前一个节点的连接，然后开始边扫描边反转。

当反转到第n个节点时，停止反转操作并打断其与后一个节点的连接。

然后重新拼凑，将反转后的片段重新塞回去。

整个过程中为了避免重复扫描，设立了很多指针，需要注意一下。

比如对于示例而言，首先是`i`指针用于从头到尾扫描。没什么可说的。

然后是`prev`指针指向第m-1个节点。这是为了打断和第m个节点连接，以及反转完成后用来连接原第n个节点用的。

`last_node`和`tmp`都是反转过程中要用到的指针。

`tail`指向原第m个节点。由于只能一遍扫描，扫描到m个节点时无法定位其反转后应该连接的第n+1个节点，因此先保存下来后续扫描到n+1之后再连过去。

虽然指针很多，但是逻辑还是清晰的，在纸上涂涂画画，就能弄明白了。

然后别忘了为了考虑m=1的情况，可是设置一个dummy。