## 题目描述
给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。

题目数据保证总会存在一个数值和不超过 k 的矩形区域。


示例 1：

![](https://assets.leetcode.com/uploads/2021/03/18/sum-grid.jpg)
```
输入：matrix = [[1,0,1],[0,-2,3]], k = 2
输出：2
解释：蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。
```
示例 2：
```
输入：matrix = [[2,2,-1]], k = 3
输出：3
```

提示：
```
m == matrix.length
n == matrix[i].length
1 <= m, n <= 100
-100 <= matrix[i][j] <= 100
-105 <= k <= 105
```

- 进阶：如果行数远大于列数，该如何设计解决方案？

### 解法 行列分治+前缀和+二分查找
这道题还是比较有意思的。
首先，看到矩阵的区域和，总是下意识想到二维数组的前缀和的办法。
诚然可以这么做，但是因为要求子矩阵的左上角和右下角都是自由移动的，在整理完前缀和之后，
可能需要O(m^2 * n^2)的时间去遍历所有可能的子矩阵。

另一方面，如果其实我们可以想到`LC.85`以及`LC.84`之间的联系。
**对于求这种矩阵中某个子矩阵的问题，通常可以将矩阵按行或者按列分治**。将其转换成数个一维的问题。

具体到这道题，我们可以按行分治，遍历所有可能的行间矩阵，即大框架是这样的：
```python
for i in range(m):
    for j in range(i, m):
        针对i-j行间的矩阵做探索
``` 
由于我们遍历了所有行间矩阵，因此即便有多个行，也可以看成一个行处理。换句话说，每个行间矩阵，可以看做是一个一维数组，每个元素是
对应列的总和。

比如示例
```text
1   0   1
0   -2  3
```
如果将其看做`i=0,j=1`的行间矩阵，那么其实他可以看做是`1 -2 4`这个数组。

接下来问题就变成了，如何从这个数组中找到一个子数组，使得其总和小于等于k的同时尽量大。
这个问题其实就很像`LC.1099`之类的题目，可以用**前缀和**来做。

如果某个数组的数字全是非负的，那么前缀和就会是一个不递减的数组。
此时要找的其实是下标对`a, b (a<b)`使得`p[b] - p[a-1]`最大且小于等于`k`。
这个问题可以通过遍历所有a，然后在a的右边二分查找相应的`p[b] <= p[a-1] + k`即可。

可惜这题并没有限定数字非负，因此前缀和数组并非不递减。对于这种问题，需要遍历右边界b并维护一个额外不递减数组，保存已经遍历过的部分。
每当遍历到一个新的右边界时，在这个额外的有序的数组中**二分查找一个左边界**，使得`p[b] - p[a-1] <= k`，即`p[a-1] >= p[b] - k`。
由于这题不需要求具体的a,b是多少，只要给出`p[b] - p[a-1]`的值即可。因此额外的数组中不需要保存下标信息。

还是以上面的为例子，首先输入的数组是`1 -2 4`。其前缀和数组本来应该是`0 1 -1 3`（注意前缀和总是有个开头的0，方便处理）。
但是这个无序无法二分查找，因此前缀和一个一个求并有序地插入。
比方说我们现在已经有了有序的前缀和数组`p = [-1, 0, 1]`，接下来新的前缀和是3。
此时我们从有序的前缀和数组中查找一个数，使得`3 - x <= 2`，换句话说，是在这个数组中查找`x >= 1`。即大于等于1最小的数。
可以通过`bisect.bisect_left(p,1)`来查找。
这个方法会返回下标`2`，然后我们更新答案`ans = max(ans, 3 - p[2])`。
接着别忘了要把新前缀和`3`也给有序的插入进前缀和数组。此时可以再利用一次二分查找：`p.insert(bisect.bisect_left(p, 3), 3)`。

以上操作显然是O(nlogn)的。由于每个行间矩阵都要做类似的操作，所以这个算法总体是O(m^2 * nlogn)。

题目中提到的行远大于列的情况，此时可能以列分治更加合理，算法总体变成了O(n^2 * mlogm)。具体算法这里就不写了。

最后，以上保持有序的前缀和数组，可以通过Python自带的`sortedcontainers.SortedList`来实现。
这个类本身就有二分查找方法`bisect_left`以及有序插入方法`add`等。相当于是简单地在我上面的代码上包了一层。
