## 题目描述
给你一个链表的头结点 head ，这个链表是根据结点的绝对值进行升序排序, 返回重新根据节点的值进行升序排序的链表。
 

示例 1:
```
输入: head = [0,2,-5,5,10,-10]
输出: [-10,-5,0,2,5,10]
解释:
根据结点的值的绝对值排序的链表是 [0,2,-5,5,10,-10].
根据结点的值排序的链表是 [-10,-5,0,2,5,10].
```
示例 2：
```
输入: head = [0,1,2]
输出: [0,1,2]
解释:
这个链表已经是升序的了。
```
示例 3：
```
输入: head = [1]
输出: [1]
解释:
这个链表已经是升序的了。
```

提示:
```
链表节点数的范围是 [1, 105].
-5000 <= Node.val <= 5000
head 是根据结点绝对值升序排列好的链表.
```
```
进阶:
你可以在O(n)的时间复杂度之内解决这个问题吗?
```

### 解法 模拟
直接用归并排序之类的办法推到重来就不说了。

这里直接尝试O(n)解法。
O(n)解法也不复杂，因为输入已经是按照绝对值排好序的，因此对于扫描到负数，
或者说扫描到当前节点值小于上一节点值的情况，就说明这个节点应该放到链表头部去。

所以只要扫描过程中实时维护`prev`，`curr`，`head`，三个指针即可。
前两个用于扫描并判断某个节点是否应该放到头部，而第三个则是实时维护新头部位置。