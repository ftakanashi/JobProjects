## 题目描述
给定一个表示分数的非负整数数组。 

玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。

每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。

给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。

示例 1：
```
输入：[1, 5, 2]
输出：False
解释：一开始，玩家1可以从1和2中进行选择。
如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。
所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。
因此，玩家 1 永远不会成为赢家，返回 False 。
```
示例 2：
```
输入：[1, 5, 233, 7]
输出：True
解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。
     最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。
```

提示：
```
1 <= 给定的数组长度 <= 20.
数组里所有分数都为非负数且不会大于 10000000 。
如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。
```

### 解法 DP
因为每次选分数的时候，可以从头或尾上选，因此可知，任意一个输入`nums`能否输赢，与`nums[1:]`和`nums[:-1]`两者有关。
于是想到了字符串套路的DP框架。

即，建立二维DP数组，`dp[i][j]`表示如果输入是`nums[i~j]`时的输赢情况。最终返回`dp[0][-1]`即可。

但是如果将dp状态简单定义为先手能否获胜的bool型，转移方程并不好想。
比如示例1的例子，显然`dp[0][1]`和`dp[1][0]`都是True，但是求`dp[1][1]`的时候，无非两种可能，取开头的1或者末尾的2。
比如取末尾的2，取完之后剩下的`1 5`对于对手来说就是一个对手先手情况的子问题，但是`dp[0][1]`只是说明对手能在那种情况下获胜，
却不知道获胜多少。因此无法确定`dp[1][1]`。

换言之，按`1 5`算，对手净胜4分，而如果当前位置的不是2而是100，那么显然，100的得分可以将对手净胜分给弥补回去。相反，2则不够弥补。

至此，我们发现，应该将dp状态定义为`dp[i][j]`表示对于输入`nums[i~j]`而言，先手可以取得的最大净胜分。
这题只要求返回True还是False，换言之返回`dp[0][-1] >= 0`即可。

有了明确定义后，题目就不难了。首先初始化，显然`dp[i][i] = nums[i]`
接着状态转移方程，继续沿用上面的思路，对于`nums[i~j]`而言，有两种取法。第一取`nums[j]`，那么剩下的`nums[i~j-1]`就是对手的先手，彼时
对手可以获得净胜分`dp[i][j-1]`，而我这次的净胜分，则是`nums[j] - dp[i][j-1]`。
同理，第二种情况，我可以得到的净胜分是`nums[i] - dp[i+1][j]`。

得到转移方程：
```python
dp[i][j] = max(nums[j] - dp[i][j-1], nums[i] - dp[i+1][j])
```
注意前序状态总是在当前状态左下方，因此DP遍历是从对角线逐渐向右上方遍历。

初始化和状态转移方程都有了，这题就不难了。