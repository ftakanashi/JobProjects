## 题目描述
给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。

- 进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？

示例 1：
![](https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg)
```
输入：root = [1,3,null,null,2]
输出：[3,1,null,null,2]
解释：3 不能是 1 左孩子，因为 3 > 1 。交换 1 和 3 使二叉搜索树有效。
```
示例 2：
```
输入：root = [3,1,4,null,null,2]
输出：[2,1,4,null,null,3]
解释：2 不能在 3 的右子树中，因为 2 < 3 。交换 2 和 3 使二叉搜索树有效。
```

提示：
```
树上节点的数目在范围 [2, 1000] 内
-231 <= Node.val <= 231 - 1
```

### 解法1 中序遍历序列处理
一个最最直接简便的办法，我通过中序遍历把各个节点值遍历出来保存进一个列表。
然后将这个列表重新排序，最后将值按顺序写入树中。

另一方面，由于题设中只有两个节点交换了。因此其实这道题换个说法，就是在一个已排序的序列中，任意交换两个元素。然后找出这两个元素是什么。

一开始我还探索了好些规律。其实很简单：比如`1 2 3 4 5 6 7`中，将2和6交换，得到`1 6 3 4 5 2 7`。
这个序列中，从左到右扫描时，有两组`nums[i-1] > nums[i]`的情况。第一组情况的`i-1`和第二组情况的`i`就是我们要找的两个元素。
另一种需要讨论的可能性是相邻两个元素交换，此时会形成如`1 2 4 3 5 6 7`。此时只有一组上述逆序对，此时`i-1`和`i`无疑就是要求的两个东西了。

基于上述想法，写代码就一点也不难了。
代码中给出的是基于递推的中序遍历过程。并且维护了prev变量指向上一个节点，用于判断逆序是否出现。

注意，本解法虽然没有显性地保存所有节点到栈中。
但是考虑到一些极端的结构如全左树，此时栈还是需要O(n)空间，所以这并不是题目进阶要求的O(1)空间解法。

### 解法2 Morris遍历
说到用O(1)的空间中序遍历二叉树，那么就是Morris遍历了。

这里只需要将morris遍历中收割结果的部分改造成适合这道题的情形即可。

具体的，我们仍然需要一个prev保存上一个节点，然后和本节点作比较，如果出现逆序情况，则保存相关的值到变量a,b中。
找到合适的a和b之后，交换两者的值即可。

>一个坑：
>
>按以上方法写了Morris遍历解法之后，不知道为什么总是超时。经过一番考察发现，超时并非是我的代码问题，而是树结构出现了环而没有复原的问题。
>
>我们知道，Morris遍历利用了中序遍历前节点（所谓左子树右下节点）的右子指针来指向根节点，从而避免了使用额外的空间。
>但是这道题，如果按照解法1中收割结果部分的代码：
```python
if node.val < prev.val:
    if a is not None:
        b = node
        break
    else:
        a, b = prev, node
prev = node
```
>看似没什么问题，但是break提供了提前退出的可能性。一旦提前退出，树结构中 "左子树右下节点 -> 本节点" 的这个连接就会残留着。
>因为题设是in-place的修改，所以验证算法的程序就会去读这个带有循环结构的树，导致超时。
>
>所以，虽然在上述代码的`b=node`之后答案已经确定了。但为了复原树结构，一定要去掉代码中的break，把整个树遍历一遍之后才能完事。