## 题目描述
编写一个程序，找出第 n 个丑数。

丑数就是质因数只包含 2, 3, 5 的正整数。

示例:
```
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
```
说明:  
- 1 是丑数。
- n 不超过1690。

### 解法1 堆
显然，确定一个数是不是丑数可以从其除以2，3，5的商是不是丑数开始计算。
反过来，从1开始，每个数都乘以2，3，5得到三个数，然后将得到的三个数维护到一个小顶堆。

小顶堆每pop一次count就+1，直到count达到n为止。

上述利用堆的思路是比较朴素符合直觉的。

另外，需要注意去重。比如2 * 3和3 * 2一样，只能在堆里出现一次。
为了判定某个乘积是不是已经在堆里出现过了，可以再设置一个seen set，来避免重复。

### 解法2 DP
遵循上个解法的基本思想， 一个不漏地把丑数求出来然后计数到第n个返回答案，这个做法肯定没错。

只是上个解法中，为了得到第n个丑数，可能会产生很多多余的，大于第n个丑数的数。
有没有更加精确控制输出数量的办法呢。

由于因数是2，3，5，我只要从1出发求出所有数的2，3，5倍即可。
为了稳健，我们只取用当前状态下的最小值。

比如1的2，3，5倍分别是2，3，5。但是不将所有结果都收割，而是只取用2。此时1的2倍已经计算出来，因此之后都不用计算1的2倍，所以下一个需要计算2倍
的数字变成2。

下一步，2 * 2和1 * 3，1 * 5比较。此时1 * 3最小，因此收割3，同时将下一个要取3倍的数字变成3。

再下一步，这次比较2 * 2, 2 * 3， 1 * 5，最小的是2 * 2 = 4。因此收割4，下一个乘以2的数字再加一变成3。

依次类推，显然可以设置三个指针`p2, p3, p5`，每个指针指向下一个需要乘以相应倍数的数，然后获取当前三个指针指向数字乘以相应倍数后的最小值，
这个操作做了k次，这个最小值就是第k个丑数。最小值对应的那个指针则指向下一个丑数。

这里需要注意，
第一，比如上述例子中可能会出现`p2, p3, p5`分别指向了`3, 2, 2`。此时最小值6可能来自于`p2`或者`p3`。也就是重复的情况。
此时为了避免重复计数，应该将两个指针共同向前移1。即知道min值后确定min值是由哪个指针产生的过程，各个if分支都是并列的。

第二，这个过程不能状态压缩。因为有三个指针，硬要压缩也必须保留走得最快的`p2`和走得最慢的`p5`之间的所有数据，要不然会有遗漏。