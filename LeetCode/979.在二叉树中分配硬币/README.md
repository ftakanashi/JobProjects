## 题目描述
给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。

在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。

返回使每个结点上只有一枚硬币所需的移动次数。

示例 1：
```
输入：[3,0,0]
输出：2
解释：从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。
```
示例 2：
```
输入：[0,3,0]
输出：3
解释：从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。
```
示例 3：
```
输入：[1,0,2]
输出：2
```
示例 4：
```
输入：[1,0,0,null,3]
输出：4
```

提示：
```
1<= N <= 100
0 <= node.val <= N
```

### 解法 DFS
这题有点意思。
本质上还是设计一个需要有所考量的DFS函数。

这题中我们注意到，其实对于任意一个子树而言，存在一个硬币净盈亏的概念`p`。
我们不妨将其定义为，要让这个子树所有节点的硬币数都为1，所剩余的硬币。
比如对于一个值为0的叶子节点，那么`p`就是-1。若叶子节点值为3，则`p`是2。

由于整个树保证节点数和硬币数一致，所以当某个子树有`p`个硬币的盈亏时，为了让其达到要求，就一定会需要`abs(p)`次操作将`p`个硬币从子树根移动到子树中或者反之。

因此，dfs函数设计成这样：
`dfs(node)`返回`p`。显然对于叶节点，直接返回`node.val - 1`即可。
对于非叶子，则需要计算`dfs(node.left)`和`dfs(node.right)`。
两个答案分别套上绝对值，加到`ans`上。
同时别忘了计算`node`作为根节点的子树的`p`值，是`node.val - 1 + dfs(node.left) + dfs(node.right)`。

按照上述思路构建dfs函数，执行即可。