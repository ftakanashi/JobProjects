##题目描述
根据一棵树的前序遍历与中序遍历构造二叉树。

注意:你可以假设树中没有重复的元素。

例如，给出

前序遍历 `preorder = [3,9,20,15,7]`

中序遍历 `inorder = [9,3,15,20,7]`

返回如下的二叉树：
```
    3
   / \
  9  20
    /  \
   15   7
```


### 解法 根据前序和中序遍历序列的性质进行递归构造
我就说这题怎么这么面熟…原来和JZ.07重建二叉树一模一样。

这里简单再说下想法。

首先，前序遍历的性质就是其第一个数字肯定是根节点的值。这么一来，只需要搞清楚在第二个以后的序列中左右子树的分界点在哪里。

那么在哪咧。这个问题就可以使用中序遍历的性质。中序遍历中的任意一个节点，其左子树的所有节点都在其左边，右子树的所有节点都在其右边。

由于前提条件给出树中没有重复元素，所以可以提前将中序遍历的值：下标关系维护到一个哈希表里之后使用。

建立一个递归函数，接收某个前序遍历序列的下标（表示要构建这个下标的值为根节点的子树时），以及两个中序遍历序列的下标分别标识左右边界
（表示要构建的子树所有元素再中序遍历中的范围）。

显然这个递归函数中，通过定位根节点值再中序遍历中的位置以及左右边界，可以确定左右子树的元素个数。
从而反过来，确定左右子树在前序遍历中的边界。