## 题目描述
给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。

删除完毕后，请你返回最终结果链表的头节点。

你可以返回任何满足题目要求的答案。

（注意，下面示例中的所有序列，都是对 ListNode 对象序列化的表示。）

示例 1：
```
输入：head = [1,2,-3,3,1]
输出：[3,1]
提示：答案 [1,2,1] 也是正确的。
```
示例 2：
```
输入：head = [1,2,3,-3,4]
输出：[1,2,4]
```
示例 3：
```
输入：head = [1,2,3,-3,-2]
输出：[1]
```

提示：
```
给你的链表中可能有 1 到 1000 个节点。
对于链表中的每个节点，节点的值：-1000 <= node.val <= 1000.
```

### 解法 哈希表
这题有点意思！很久没有碰到看完答案后大呼np的题目了。
首先理解题意。题目说了"反复"删去，然后又说多种可能性只要返回一种就行。这个本身其实就有点矛盾的。
其实不用管这么多，就管从左到右扫描，然后反复删除当前链中总和是零的片段即可。

比如`1, 2, 3, -3, 2`，整个逻辑可能就是先扫描到-3，发现`3, -3`是一个需要删除的片段。
删除后再扫描到`-2`，然后发现`2, -2`也是可以删除，最终剩下`1`这个单节点。

不难看出，需要用到前缀和+哈希表的策略。从左到右扫描过程中可以维护每个位置的前缀和，并且有哈希表记录已经出现过的前缀和。
当某个前缀和在前面已经出现过，此时说明这两个前缀和间的部分是一个可以删除的片段。

然而这题麻烦就在于，前缀和相同的情况非常复杂。
两对相同前缀和之间可能有重叠，不重叠，包含等关系。也有可能有三个以上相同的前缀和。

这里，官答给出了一个大道至简的方案。不论相同前缀和有多少个，如何出现。我们只需要关注最前面的和最后面的一对，即覆盖面积最大的一段即可。

于是，我们可以先遍历一遍链表，用一个哈希表记录所有前缀和值最后一次出现的节点。即形成一个 `前缀和 -> 节点对象` 的对应关系。

然后进行第二次遍历。由于第一次遍历过程没有改变任何值，所以前缀和的所有值都不会有改变。因此第二次遍历继续重新计算前缀和。
算出某个节点对应的前缀和之后，到哈希表中找对应节点。如果有对应节点且不是自身，
那么这个节点必然是具有相同前缀和的最靠后的节点，可以放心大胆地讲当前节点和那个节点之间的片段删除。
具体的删除，就是将当前节点的`p.next = s2node[s].next`。

这里其实还隐含了很妙的一点。那就是前缀和和链表的特性天然是契合的。
我们知道一个前缀和数组如果`presum[i] == presum[j]`，其实表示的是原数组中`nums[i+1:j+1]`这个片段，即`i`位置后面一个数字开始，到`j`位置
为止的片段总和是0。即`i`位置本身需要保留。
而链表中，指针在`i`位置节点时恰好是无法删除该节点的，直接将其指针指向修改到对应`j`节点的`.next`，天然就删除了上述片段了！

此外，还有一个就是前缀和数组通常会多一个前缀0，对应到链表中，就是常见的增加一个dummy头节点的套路。也是契合的。

于是，可以用很简洁的代码写出上述逻辑。看代码！