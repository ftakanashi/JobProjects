## 题目描述
编写一个程序，通过填充空格来解决数独问题。

示例：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png)
```
输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
解释：输入的数独如上图所示，唯一有效的解决方案如下所示：
```
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714_solutionsvg.png)

提示：
```
board.length == 9
board[i].length == 9
board[i][j] 是一位数字或者 '.'
题目数据 保证 输入数独仅有一个解
```


### 解法 DFS回溯 + 位运算标记
思路没有什么复杂的。就一格一格扫描，碰到已有数字的就直接跳过；
碰到空格的，则尝试从1-9填入数字。注意到不能有冲突，因此填入之前需要检查冲突情况。
只要没冲突的，就尝试填入后，进入下一层DFS。

若下一层DFS没有任何数字填入，为了让本层也知道，让DFS返回一个Bool。当下一层返回False，我们就知道说明本格不能填当前数字，
于是将其回溯成空格，接着尝试下一个数字。

一个优化点在于如何检查冲突。最朴素的办法当然是哈希集之类的。
这里结合`LC.36`的经验，使用位运算优化空间，用一个9位的二进制数，代表某一行、一列和一个小宫内的数字出现情况。

通过与`(1 << (n-1))`进行`|=`, `^=`和`&是否大于0`运算，可以类似地进行add, remove, in等哈希检查操作。

整体代码稍微有点长，但是不要怕，不难。 

#### 2021/08/10 解法一的优化
> https://www.nowcoder.com/practice/78a1a4ebe8a34c93aac006c44f6bf8a1?tpId=37&&tqId=21267&rp=1&ru=/ta/huawei&qru=/ta/huawei/question-ranking

在牛客上做这题，写了类似的以`dfs(x, y)`为入口的代码。但是超时。
真是特么日了狗了……

分析了一下，若以坐标`x, y`作为dfs的入口参数，则实际上，每次扫描到一个新位置时，
都会进入新的一层DFS，而CPU执行这个过程要进行上下文的切换。
可能就是这个上下文切换，比较费时间。

为了克服这个困难，就需要找一个dfs的方法可以不以坐标作为入口。
一个自然的想法就是直接`dfs()`，然后扫描的过程中碰到非0位置，直接跳过。
大概的样子是这样的：
```python
def dfs():
    for i in range(9):
        for j in range(9):
            if grid[i][j] != 0: continue
            for cand in range(1, 10):
                if not check(i, j, cand): continue
                grid[i][j] = cand
                update(i, j, cand)
                if dfs(): return True
                grid[i][j] = 0
                remove(i, j, cand)
            return False

    return True
```

虽然看着很费时，因为进入下一层dfs后要从新从`0,0`位置开始扫描一边全表。
但是别忘了这个表大小是固定的，且只有9 * 9的81。
事实证明，即使这么从头扫，也比递归上下文切换花的时间少…

优化后的代码也加入到main.py里了。记得参考。