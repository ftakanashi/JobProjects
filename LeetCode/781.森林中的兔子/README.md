## 题目描述
森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 answers 数组里。

返回森林中兔子的最少数量。

示例:
```
输入: answers = [1, 1, 2]
输出: 5
解释:
两只回答了 "1" 的兔子可能有相同的颜色，设为红色。
之后回答了 "2" 的兔子不会是红色，否则他们的回答会相互矛盾。
设回答了 "2" 的兔子为蓝色。
此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。
因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。

输入: answers = [10, 10, 10]
输出: 11

输入: answers = []
输出: 0
```
说明:
```
answers 的长度最大为1000。
answers[i] 是在 [0, 999] 范围内的整数。
```

### 解法 贪心
这道题看着不简单，但其实示例数据给了很好的提示。

首先看到第二组示例数据，三个相同的数字10。这三个兔子当然可以具有各自不同的颜色但这样总兔子数很多。
由于题目要求结果尽量小，因此我们利用贪心思想。
具体的，我们默认将这三个兔子视为一个颜色。此时0号兔子的答案10中，其实也包括了1号和2号兔子。这样可以做到最大程度的"重叠"，
从而减少没有来回答的兔子（毕竟有n只兔子回答的话，答案至少也是n了）。

又因为相同色的兔子回答总是一样 且不同回答的兔子颜色肯定不一样，因此我们将所有回答相同的兔子视为相同色。
如此看来，只需要一个counter统计各个回答数以及做出这个回答的兔子数，然后将各种回答数+1的和求出来就好了。

真的吗？
这里还存在一个问题，比如输入`[2,2,2,2,2]`。按上述理论，答案会是3。
但是分析一下就发现，我们尽量将这5个兔子视作同色，0，1，2号兔子的答案没问题，但3，4号答案就和假设出现了矛盾。
此时不得不将3，4号视作另外一种颜色，与此同时，会不可避免地引入一只未出现在输入中的兔子。

换言之，上述输入的兔子虽然回答都是2，但前三个可以分成一组，后两个需要与一个未出现的兔子分成一组。
总的来说，这里需要至少兔子数，是大于等于输入长度5的最小的`2+1=3`的倍数。

更一般的，对于counter中任意一项`k: v`，如果有`v % (k+1) == 0`，那么意味着所有兔子都出现在输入中了，可以直接`+= v`。
否则，兔子至少要增加大于`v`的最小的`k+1`的倍数。
将这个理论套回`10,10,10`这类`k > v`的情况中，发现也适用（彼时大于`v`最小`k+1`倍数就是`k+1`自身）

再验证特殊情况，`k==0`时也适用（`v % (k+1)`总是等于0）。
于是按照上述思路写代码即可。