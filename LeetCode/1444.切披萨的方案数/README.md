## 题目描述
给你一个 rows x cols 大小的矩形披萨和一个整数 k ，矩形包含两种字符： 'A' （表示苹果）和 '.' （表示空白格子）。你需要切披萨 k-1 次，得到 k 块披萨并送给别人。

切披萨的每一刀，先要选择是向垂直还是水平方向切，再在矩形的边界上选一个切的位置，将披萨一分为二。如果垂直地切披萨，那么需要把左边的部分送给一个人，如果水平地切，那么需要把上面的部分送给一个人。在切完最后一刀后，需要把剩下来的一块送给最后一个人。

请你返回确保每一块披萨包含 至少 一个苹果的切披萨方案数。由于答案可能是个很大的数字，请你返回它对 10^9 + 7 取余的结果。

示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/10/ways_to_cut_apple_1.png)
```
输入：pizza = ["A..","AAA","..."], k = 3
输出：3 
解释：上图展示了三种切披萨的方案。注意每一块披萨都至少包含一个苹果。
```
示例 2：
```
输入：pizza = ["A..","AA.","..."], k = 3
输出：1
```
示例 3：
```
输入：pizza = ["A..","A..","..."], k = 1
输出：1
```

提示：
```
1 <= rows, cols <= 50
rows == pizza.length
cols == pizza[i].length
1 <= k <= 10
pizza 只包含字符 'A' 和 '.' 。
```

### 解法 DP
如果采用DP的思路来做，那么这题就是一道较高维的，稍有些复杂的DP，但不算太麻烦。

首先，直观的来说，任何一块披萨的符合题意的切分方案数，实际上都可以用其中一部分更小披萨的方案数加和而来。

比如某一块披萨的切割成`k`块的方案数，其实可以就是其下方和右方所有子披萨的`k-1`块方案数总和。

假设我们这边说的某块披萨是指整个大披萨中的`pizza[i][j]`的右下方矩形（这是很自然的，因为题意固定了切一刀之后，上方或者左方的披萨会被分出去）
此时，将这个披萨切成`k`块，要考虑所有的`pizza[i'][j]`（其中`i'`为`i+1 ~ m-1`），以及所有的`pizza[i][j']`（其中`j'`为`j+1 ~ n-1`）。
这些小披萨的`k-1`的方案数。

讲到这里，借助一点DP升维的思想，其实大体的思路就有了。
我们初始化一个DP数组，size为`k+1 * m * n`，其中`dp[k][i][j]`表示，将`pizza[i][j]`分割为`k`块符合要求的披萨时的方案数量。
根据上面的递推逻辑，有
```python
dp[k][i][j] = sum(dp[k-1][i2][j]) + sum(dp[k-1][i][j2])
```

这个DP数组的初值则稍微有点难想到。这里我们先按下不表。
先来考虑上面的逻辑中尚存在一些bug。

以横向切割为例，上面我们认为`dp[k][i][j]`的一部分组成是`dp[k-1][i][j]`来的。
但是这里有一个隐含的前提条件，那就是`pizza[i][j]`的每一行都是有至少一个苹果的。
加入这个矩形的比如前两行都没有苹果，那么此时即便从第二行下方切割开，也不是一种有效的切割方法。

换言之，上面的递推方程的一个前提条件是，`apples[i][j]` 必须大于 `apples[i'][j]`。
其中`apples`数组维护的是`i, j`位置右下方的整个矩形中的苹果总数。
（实际上前者只可能大于等于后者，所以大于的意思就是不等于

有了这个数组之后，还可以顺便解决掉DP数组初值的问题。
对于任何一个位置`i, j`，只要其`apples[i][j] > 0`即其右下方只要有至少一个苹果，
那么就等同于`dp[1][i][j] = 1`，即表示其右下方区域内至少可以有1种一刀都不切的分割方案（即整个拿出。

至此，全部的思路就齐了。总结一下。
首先是构建`apples`数组，统计每个位置其右下方矩形的苹果总数。
（这个过程中可以顺便把DP数组的初值也搞定

然后遍历DP数组。注意`k`的遍历范围是`range(1, k+1)`。
填充每个位置。递推方程式：
```python
        for k in range(1, k+1):
            for i in range(m):
                for j in range(n):

                    for i2 in range(i+1, m):
                        if apples[i][j] == apples[i2][j]: continue
                        dp[k][i][j] += dp[k-1][i2][j]
                    
                    for j2 in range(j+1, n):
                        if apples[i][j] == apples[i][j2]: continue
                        dp[k][i][j] += dp[k-1][i][j2]
```

最后别忘了补充一些细节比如MOD处理等。

根据DP数组定义，最终答案是`dp[k][0][0]`。