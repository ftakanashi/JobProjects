## 题目描述
给你一个整数数组 nums 。如果 nums 的一个子集中，所有元素的乘积可以表示为一个或多个 互不相同的质数 的乘积，那么我们称它为 好子集 。

比方说，如果 nums = [1, 2, 3, 4] ：
```
[2, 3] ，[1, 2, 3] 和 [1, 3] 是 好 子集，乘积分别为 6 = 2*3 ，6 = 2*3 和 3 = 3 。
[1, 4] 和 [4] 不是 好 子集，因为乘积分别为 4 = 2*2 和 4 = 2*2 。
```
请你返回 nums 中不同的 好 子集的数目对 10^9 + 7 取余 的结果。

nums 中的 子集 是通过删除 nums 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。

示例 1：
```
输入：nums = [1,2,3,4]
输出：6
解释：好子集为：
- [1,2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [1,2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
- [1,3]：乘积为 3 ，可以表示为质数 3 的乘积。
- [2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
- [3]：乘积为 3 ，可以表示为质数 3 的乘积。
```
示例 2：
```
输入：nums = [4,2,3,15]
输出：5
解释：好子集为：
- [2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [2,3]：乘积为 6 ，可以表示为互不相同质数 2 和 3 的乘积。
- [2,15]：乘积为 30 ，可以表示为互不相同质数 2，3 和 5 的乘积。
- [3]：乘积为 3 ，可以表示为质数 3 的乘积。
- [15]：乘积为 15 ，可以表示为互不相同质数 3 和 5 的乘积。
```

提示：
```
1 <= nums.length <= 105
1 <= nums[i] <= 30
```

### 解法 DFS
这题说难倒也不太难。
题意不难懂，而且看到要取子集，很容易想到用DFS，回溯之类的办法做。

这题的难点在于，如何避免选择有重复质因子的数字进入子集。
由于数据范围很小，只到30，而30以内的，无重复质因子的数字一共就那么几个。
首先是那些本身就是质数的数，共10个：
```text
2 3 5 7 11 13 17 19 23 29
```
接着是那些虽然是合数，但是所有质因子没有重复的数字：
```text
6 10 14 15 21 22 26 30
```

显然，除了上面提到的数字，其他所有出现在nums中的数字都无法被选入子集，可以再预处理阶段就剔除。

另一方面，由于输入允许重复数字且同种类数字的不同实例选入子集算多个，因此可以直接一个counter套一下，
考察每个种类的数字被选入时的子集数量，最后乘以这个数字的计数即可。

最后还有一个特殊数字，`1`。
根据题意，1可以被选入任意子集任意个，因此需要单独拿出来。具体来说，就是我们先无视所有1，求出能得到多少子集。
然后这个数量乘以`1`的计数值`cnt`的2^cnt次方。

接着就是按照选子集的套路，先对所有数字种类按大小排序，然后从前向后扫描。
每扫描到一个数字时，可以选择将该数字选入子集或者不选入，而这又分别引向两条不同分支的深一层DFS。

需要注意，将数字选入子集时，需要保证之前选入的所有数字的所有质因子和本数字的质因子没有任何重复。
这点可以依靠预处理时将所有数字的质因子写成一个集合，然后DFS过程中维护一个`used_factors`集合，保存至今为止选入的所有数字的所有质因子。
只要当前数字的质因子集合与`used_factors`的交集为空，那么就可以放心地选该数字入子集；否则就不能。

更多细节，见代码。

#### P.S. DP也是可以的
这题，其本质其实和背包问题很像，甚至可以说就是一个背包的变体。

具体的，每个质因子可以视作一个物品，而nums中的每个数字可以看做一个物品的组合。
而题目的要求，正是对每个物品组合，判断其是否能够被装进背包。

上面的描述中，其实也提到了推导过程中对某个特定数字，有"拿"或者"不拿"两种选择，所以背包的意思很浓了。

我也参考官方答案随便写了个不带任何优化的DP代码，`dp[i][mask]`表示前`i`个数字选择完后，质因子选择情况恰好是`mask`时总共有几种子集。
（mask的表达请参考官方答案或者看代码

这样，最后只要计算`sum(dp[-1][1:])`，就可以得到答案。
在些小case上能够跑过，不过整体代码超时了，主要是因为没有对数字种类合并做出处理。
另外，空间上也可做状态压缩。
不过因为没时间了，这里就不继续写了，目前状态的代码是这样的：
```python
MOD = 10 ** 9 + 7
class Solution:
    prime = [2,3,5,7,11,13,17,19,23,29]
    p2pos = {n: i for i, n in enumerate(prime)}

    @cache
    def getPrimeFactors(self, num: int) -> List[int]:
        prime_factors = []
        fac = 2
        while num > 1:
            while num % fac == 0:
                prime_factors.append(fac)
                num = num // fac
            fac += 1
        return prime_factors

    @cache
    def generateMask(self, num: int) -> int:
        mask = 0
        for fac in self.getPrimeFactors(num):
            mask |= (1 << self.p2pos[fac])
        return mask

    def numberOfGoodSubsets(self, nums: List[int]) -> int:
        valid = self.prime + [6,10,14,15,21,22,26,30]
        one_cnt = nums.count(1)
        nums = [num for num in nums if num in valid]
        n = len(nums)

        dp = [[0 for _ in range(1024)] for _ in range(n + 1)]
        for i in range(n+1):
            dp[i][0] = 1
        for i in range(1, n+1):
            num = nums[i-1]
            num_mask = self.generateMask(num)
            for mask in range(1, 1024):
                if num_mask & mask == num_mask:
                    dp[i][mask] += dp[i-1][mask ^ num_mask] % MOD
                dp[i][mask] += dp[i-1][mask] % MOD
        res = sum(dp[-1][1:]) % MOD
        if one_cnt > 0:
            res = res * (2 ** one_cnt % MOD) % MOD
        return res
```