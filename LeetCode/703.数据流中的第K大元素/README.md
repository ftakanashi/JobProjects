## 题目描述
设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。

请实现 KthLargest 类：

KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。
int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。
 

示例：
```
输入：
["KthLargest", "add", "add", "add", "add", "add"]
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
输出：
[null, 4, 5, 5, 8, 8]

解释：
KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // return 4
kthLargest.add(5);   // return 5
kthLargest.add(10);  // return 5
kthLargest.add(9);   // return 8
kthLargest.add(4);   // return 8
```

提示：
```
1 <= k <= 104
0 <= nums.length <= 104
-104 <= nums[i] <= 104
-104 <= val <= 104
最多调用 add 方法 104 次
题目数据保证，在查找第 k 大元素时，数组中至少有 k 个元素
```

### 解法 堆
一个最直接的想法是
维护一个有序的数组二分查找到其插入位置并插入，由于后排元素要挨个后退所以一次add操作最多为O(n)，n为操作add的次数。

在此之上，既然是求第K大，那么显然可以用堆来做。问题是怎么做。

用堆的一个直接想法是，构建一个大顶堆，然后每新来一个元素后将其入堆，之后pop k次，自然可以得到新数组的第K大元素。
而pop出来的这些之后肯定还要再入堆。

总的来看，时间复杂度就变成了O(klogk)，也没比上面办法好多少。

**这里就需要知道通过堆求解第K大元素的另一个套路。**
因为只要求解第K大元素，且整个过程中不会有元素丢失
（如果要算有丢失的情况，可以参考LC480题）
所以不必关心初始状态下k+1大及之后的元素。

于是我们反其道而行之，构建元素个数始终维持在k的小顶堆。
显然最开始的堆顶就是初始状态的答案。

之后add进来的数，如果小于等于当前堆顶，那么没必要看，直接返回堆顶。
如果比当前堆顶大，那么就将其入堆后再pop掉堆顶，再返回最新堆顶才是答案。

这么一来，只需要pop一次就可以，因此一次add操作的复杂度是O(2*logk)。具体来说，
入堆一次logk，pop掉堆顶后重新整理堆序一次logk。