## 题目描述
给出一个完全二叉树，求出该树的节点个数。

说明：

完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。

示例:
>输入: 
>
>```text
>    1
>   / \
>  2   3
> / \  /
>4  5 6
>```
>输出: 6


### 解法1 递归
由于是二叉树的一个简单问题。二叉树的问题大多都可以通过递归来解决。

递归函数本体功能就是计算某棵树的节点个数，当树根节点本身是None返回0，当树根左右子树都为None就返回1。

很简洁明了。

### 解法2 BFS
由于是一棵树，所以可以用BFS或者DFS来遍历节点。

这里只是节点计数而已，所以很简单。

不多说了，作为代表这里用BFS。而上面的方法1递归，实际上就是一个DFS。

### 解法3 完全二叉树的性质:二分查找+位运算
上述无论是DFS还是BFS，都没有充分利用完全二叉树的性质。下面是一种利用完全二叉树的高速方法。

首先要明确，输入的树，各个节点的值并不一定是按照示例中的那样按照广度优先的顺序递增排列。换言之，这题里节点的值本身没有什么意义。

回到题意，完全二叉树的节点个数，很明显取决于树的层数以及最后一层的"完全程度"。

加入树有`h`层，比如上面示例`h=2`，那么显然总个数介于`2**h`到`2**(h+1) - 1`之间。
>注意h从0开始计数，这里先解决如何确定h？其实由于输入是完全二叉树，所以可以一直往左子树走。每走深一层，层数h就增1。

有了这个性质，实际上我们只要在这个区间内做探索，探索节点不是None的最大边界在哪里即可。

区间中做探索，显然可以用二分查找。但是二分查找的条件，是某个节点是不是None。这个又要怎么判断呢？
这里用到了完全二叉树的另一个性质：
```text
完全二叉树BFS序的第n个节点（n从1开始计数），可以通过下面的方式来定位。
首先，n先转换成二进制，然后去除开头的1。如果知道这个节点在第h层，那么可以
n -= (1 << h)

然后，n的二进制剩余部分从高位到低位，分别对应着从根节点开始到该节点的路径。
某位是0则走左子树，是1则走右子树。

比如上面示例中的n=5节点。5的二进制是101。去掉开头的1之后，剩下01。
所以n=5节点位于根节点的 左子树 的 右子树。
```

将这个性质应用回来，判断某个节点存不存在，就只要看他的n是多少，然后二进制转换一下，从根节点开始去走一遍即可。
>二进制从右到左的扫描可以直接x & 1后x = x >> 1
>
>从左到右的扫描则需要维护一个y = 最大位数，x & (1 << y)后y -= 1

一点分析，
在这个算法中，首先没用用到任何额外空间。
其次，二分查找本身是一个logN的过程，同时每次查找判断节点性质时又是一个简单的二叉树从根节点向叶子节点探索的过程，也是logN的。

总的来说，时间上是O((logn)^2)的。因此比BFS或则DFS的O(n)要快一点。