## 题目描述
桌子上有 n 个球，每个球的颜色不是黑色，就是白色。

给你一个长度为 n 、下标从 0 开始的二进制字符串 s，其中 1 和 0 分别代表黑色和白色的球。

在每一步中，你可以选择两个相邻的球并交换它们。

返回「将所有黑色球都移到右侧，所有白色球都移到左侧所需的 最小步数」。

示例 1：
```
输入：s = "101"
输出：1
解释：我们可以按以下方式将所有黑色球移到右侧：
- 交换 s[0] 和 s[1]，s = "011"。
最开始，1 没有都在右侧，需要至少 1 步将其移到右侧。
```
示例 2：
```
输入：s = "100"
输出：2
解释：我们可以按以下方式将所有黑色球移到右侧：
- 交换 s[0] 和 s[1]，s = "010"。
- 交换 s[1] 和 s[2]，s = "001"。
可以证明所需的最小步数为 2 。
```
示例 3：
```
输入：s = "0111"
输出：0
解释：所有黑色球都已经在右侧。
```

提示：
```
1 <= n == s.length <= 105
s[i] 不是 '0'，就是 '1'。
```

### 解法 贪心
看完题目后还是比较容易想到贪心思路的，但是具体怎么做则需要思考思考。
在充分压缩优化细节后，可以做到不做任何实际的交换，一次遍历就算出来。

首先看看比较直白的思路。
比较容易想到，我们可以从右到左遍历，用双指针维护整个序列最后一个0以及除了这个0之后所有1的最后一个1。类似于：
```text
xxxxx10000111...
     i   j
```
此时将两者交换的次数为 `j - i`，之后 `j -= 1`，然后 `i` 继续向前扫描可能的1。

以上思路也能勉强AC，代码：
```python
class Solution:
    def minimumSteps(self, s: str) -> int:
        s = list(s.rstrip("1"))
        j = len(s) - 1
        i = len(s) - 1
        ans = 0 
        while i >= 0:
            while i >= 0 and s[i] == "0":
                i -= 1
            if i < 0: break
            ans += (j - i)
            s[i], s[j] = s[j], s[i]
            j -= 1
        return ans
```

但如上所述，直接进行交换操作的效率并不高。下面是一种更精炼的做法。

由于最靠右的连续多个1是可以忽略的，某个中间形态末尾一定是 xxx1000... 这样的一个1加上若干个0的形式。
显然让这里的1交换到最右边的操作次数，等于末尾0的个数。
而交换后，继续往左扫描1，此时继续要将新的这个1归位，实际上就是将其交换到刚才那个1的左边。
可以发现：交换次数仍然是0的个数。

至此，一个相对很精妙的算法就有了：
我们从右到左扫描s，并记录扫描过的0的数量。
当碰到1时，意味着我们需要将其交换到其右侧一片0的最右端，次数恰好就是此时扫过的0的数量。于是可以收割答案。
此时不用做真正的交换操作，继续向左扫描，保持上述算法。

扫描完整个序列后答案自然也就有了。