## 题目描述
给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。

它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足 encoded[i] = perm[i] XOR perm[i + 1] 。比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。

给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。

示例 1：
```
输入：encoded = [3,1]
输出：[1,2,3]
解释：如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]
```
示例 2：
```
输入：encoded = [6,5,4,6]
输出：[2,4,1,5,3]
```

提示：
```
3 <= n < 105
n 是奇数。
encoded.length == n - 1
```

### 解法 利用异或性质
观察了一番题目之后发现，如果encoded是`a b c d`的话，perm可以表示为`x x^a x^a^b x^a^b^c x^a^b^c^d`。其中x表示`perm[0]`。
即只要确定第一个元素是什么，就可以获得整个序列了。

所以第一个思路是列举1到n间所有的数字并将其当做开头元素，尝试生成perm。生成perm过程中，只要数字之间没有重复，且生成完后恰好长度是n-1，那么这个
数字就是perm正确的开头数字了。

写了一下代码发现通过了绝大多数case，但是一个很长的case通不过。
自然，这个办法是O(n^2)的，于是想能不能通过数学方法更快获得答案。

在`LC.1486`中我们提到过异或运算的一些性质比如
```text
a^a = 0
a^b = b^a
(a^b)^c = a^(b^c)
4k ^ 4k+1 ^ 4k+2 ^ 4k+3 = 0
```
利用这些性质可以优化这道题的解法。

由于n是确定的，所以最开始就可以求出`1^2^3...^n`的值。这个值可以利用上面最后条性质在O(1)时间内得到。记为`total`。
由于交换律，依据前面的表达方式，上面这个值还可以写成`x^x^x^x^x ^ a^a^a^a ^ b^b^b ^ c^c ^ d`。
偶数个相同的数异或后是0，根据这个性质，上式简化为`x^b^d`。
于是，可以得到`x = total^b^d`。

换言之，perm序列的第一个数x，可以通过total以及encoded中下标为奇数的数一起异或得到。

有了x之后，再扫描一遍encoded把每个数异或上去，就可以得到perm序列了。