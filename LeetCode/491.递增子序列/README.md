## 题目描述
给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

示例 1：
```
输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
```
示例 2：
```
输入：nums = [4,4,3,2,1]
输出：[[4,4]]
```

提示：
```
1 <= nums.length <= 15
-100 <= nums[i] <= 100
```

### 解法 记忆化DFS
这题字里行间透露着用DFS做的气息，但是不论怎么优化都很难AC。
最后是以一种非常不优雅的方式AC的，正想看看官方答案有什么高明的解法，结果官方答案是暴力的…
既然这么不讲武德，那么我也就直接用这个不优雅的DFS做了。

构建dfs函数`dfs(pos: int, stack: tuple)`。
表示扫描到`pos`位置且当前的序列为`stack`元组表示时的情况。

此时，对于`nums[pos]`这个数字，我们有两种选择。选用或者不选用。

若选用，则需要将其加入到`stack`中去。通常这是一个单调栈套路，可以`while stack and stack[-1] ...: stack.pop()`来做。
但由于此时的`stack`是一个元组，另外，这种做法也是线性的，由于`stack`保证有序了，所以这里完全可以二分做。
即
```python
tgt_pos = bisect.bisect(stack, nums[pos])
stack = stack[:tgt_pos] + (nums[pos], )
```

若不选用，那么就直接`dfs(pos+1, stack)`即可。

注意以上算法并没有解决重复问题。比如`4 6 7 7`这个示例1中的例子，单纯使用上述算法会有重复的两个`4,7`以及重复的`4,6,7`等。
为了去重，我将结果容器改成了set…
这也是我认为这个算法不优雅的地方。其实应该可以精确控制dfs过程从而在探索过程中直接去重。不过懒得想了。

另外尽力优化了一波，比如二分，比如dfs输入都是可哈希的所以加了记忆化。