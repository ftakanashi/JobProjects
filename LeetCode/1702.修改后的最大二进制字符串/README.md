## 题目描述
给你一个二进制字符串 binary ，它仅有 0 或者 1 组成。你可以使用下面的操作任意次对它进行修改：

操作 1 ：如果二进制串包含子字符串 "00" ，你可以用 "10" 将其替换。
比方说， "00010" -> "10010"
操作 2 ：如果二进制串包含子字符串 "10" ，你可以用 "01" 将其替换。
比方说， "00010" -> "00001"
请你返回执行上述操作任意次以后能得到的 最大二进制字符串 。如果二进制字符串 x 对应的十进制数字大于二进制字符串 y 对应的十进制数字，那么我们称二进制字符串 x 大于二进制字符串 y 。

示例 1：
```
输入：binary = "000110"
输出："111011"
解释：一个可行的转换为：
"000110" -> "000101" 
"000101" -> "100101" 
"100101" -> "110101" 
"110101" -> "110011" 
"110011" -> "111011"
```
示例 2：
```
输入：binary = "01"
输出："01"
解释："01" 没办法进行任何转换。
```

提示：
```
1 <= binary.length <= 105
binary 仅包含 '0' 和 '1' 。
```

### 解法 贪心
题目虽然有点绕，但是本质并不难。
不难发现，居然两种操作都是可以对任意位置的子串做无限次数，那么第一个想到的就是字符串中任意连续的n个0都可以变成
n-1个1和1个0的组合。
其次，因为10总是可以变成01，所以字符串中所有的1都可以向右移动，形成一个类似于 `000..01111..1` 的字符串。

形成如上字符串之后，再把左侧的0都变成1，于是我们就可以得到一个相对比较大的类似于 `11...1011...1` 的字符串了。
这也是大多数用例得到的最终解。但并不是覆盖所有情况的通解。

有两种特殊一点的情况需要考虑。
第一，如果最开始字符串中就没有0，那么没什么可说的，我们就直接返回原字符串。
第二，原字符串开头如果有连续多个1，此时虽然上述算法可以跑通，把所有1都移到最右边，但是并不是可以让其最大化的解。
比如 `11000`，我们把最左边的1都移到最右边，再把0都尽量改为1，最终得到的是 `11011`。

然而如果我们一直对其做第一类操作，其实可以直接得到 `11110` ，是一个更大的解。
事实上对于这个情况，由于左侧连续多个1是不需要变动的，因为不可能有比这更大的情况了。
我们可以将左侧连续多个1剔除作为固定的前缀。将剩余部分再按照上述算法做处理。

最终就可以得到一个最大解了。