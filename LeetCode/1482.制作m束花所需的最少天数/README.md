## 题目描述
给你一个整数数组 bloomDay，以及两个整数 m 和 k 。

现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。

花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。

请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。

示例 1：
```
输入：bloomDay = [1,10,3,10,2], m = 3, k = 1
输出：3
解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。
现在需要制作 3 束花，每束只需要 1 朵。
1 天后：[x, _, _, _, _]   // 只能制作 1 束花
2 天后：[x, _, _, _, x]   // 只能制作 2 束花
3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3
```
示例 2：
```
输入：bloomDay = [1,10,3,10,2], m = 3, k = 2
输出：-1
解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。
```
示例 3：
```
输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3
输出：12
解释：要制作 2 束花，每束需要 3 朵。
花园在 7 天后和 12 天后的情况如下：
7 天后：[x, x, x, x, _, x, x]
可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。
12 天后：[x, x, x, x, x, x, x]
显然，我们可以用不同的方式制作两束花。
```
示例 4：
```
输入：bloomDay = [1000000000,1000000000], m = 1, k = 1
输出：1000000000
解释：需要等 1000000000 天才能采到花来制作花束
```
示例 5：
```
输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2
输出：9
```

提示：
```
bloomDay.length == n
1 <= n <= 10^5
1 <= bloomDay[i] <= 10^9
1 <= m <= 10^6
1 <= k <= n
```

### 审题
到了`x`天后数组中所有小于等于`x`的位置都会开花。
而开花的位置互相间连成长度大于或者等于`k`的一片时就可以收割一束花。当某天可以收割`m`束花的时，这个天数就是所求。

### 解法 二分查找
说实话这道题做的有点心态崩了…
因为真的没想出来一丁点儿思路。
然后看了其他人的答案，发现他们又好多好多思路…还是自己太菜了。

这几天的题目也有很多这种"threshold的二分查找"套路。总之记住这种套路的可能性吧。
当题目问某个值在某种条件下的最值，不一定要用DP或者贪心，在上下限确定的情况下可以用"threshold二分查找"。

下面来说说这题的解法。其实想到了的话就一点也不难了。
根据threshold二分查找的规则，显然，不论输入怎么给，最少至少需要`min(bloomDay)`天，最多需要`max(bloomDay)`天才能收割到符合要求的花束。
于是查找的范围定了。

接着，在`x`天时，如何判断能否收割到`m`个花束从而返回True，亦或是相反情况返回False呢？
由于外面套的二分不过O(logn)而已，所以这里既是用朴素的O(n)办法，总体也不过才O(nlogn)，可以接受。
所以这里直接用朴素的办法即可。
具体来说，就是维护一个花束的count和一个花束内花朵的count：
```python
def check(day):
    bloom_count = flower_count = 0
    for b in bloomDay:
        if b <= day:
            flower_count += 1
            if flower_count == k:
                bloom_count += 1
                flower_count = 0
                if bloom_count == m: return True
        else:
            flower_count = 0
    return False
```
扫描过程中，当已经盛开的花朵连续数量达到`k`，则收割一个花束并且归零花朵。当任意一片连续的被打断，则直接归零花朵。