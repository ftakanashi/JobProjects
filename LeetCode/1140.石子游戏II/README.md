## 题目描述
爱丽丝和鲍勃继续他们的石子游戏。许多堆石子 排成一行，每堆都有正整数颗石子 piles[i]。游戏以谁手中的石子最多来决出胜负。

爱丽丝和鲍勃轮流进行，爱丽丝先开始。最初，M = 1。

在每个玩家的回合中，该玩家可以拿走剩下的 前 X 堆的所有石子，其中 1 <= X <= 2M。然后，令 M = max(M, X)。

游戏一直持续到所有石子都被拿走。

假设爱丽丝和鲍勃都发挥出最佳水平，返回爱丽丝可以得到的最大数量的石头。

示例 1：
```
输入：piles = [2,7,9,4,4]
输出：10
解释：如果一开始Alice取了一堆，Bob取了两堆，然后Alice再取两堆。爱丽丝可以得到2 + 4 + 4 = 10堆。如果Alice一开始拿走了两堆，那么Bob可以拿走剩下的三堆。在这种情况下，Alice得到2 + 7 = 9堆。返回10，因为它更大。
```
示例 2:
```
输入：piles = [1,2,3,4,5,100]
输出：104
```

提示：
```
1 <= piles.length <= 100
1 <= piles[i] <= 104
```

### 解法 DFS 博弈
这道题是直接抄的答案…
不过记录一下是为了记录一个略新的范式（基于博弈的DFS）

一般来说DFS总是层层向下推进，然而对于双人博弈的场景，很容易就会去想，是否要引入类似于`player`这样的一个变量作为DFS的入口。
其实对于双人博弈，可以不用引入。
我们不必要对dfs进入时具体哪个玩家做出逻辑判断，只需要抓住，dfs函数总是返回**当前玩家**的最优解即可。

比如这题，我们可以定义`dfs(i, M)`表示现在从第`i`堆石头开始取，并且当前M值是`M`的情况下，当前玩家能够最终取得的最大石子数量。
先不管当前玩家是谁，很显然的一些点是

1，如果`i >= n`，已经越界，玩家不可能取到任何石子且不需要递进到下一层dfs，显然可以直接返回0。
2，如果`i + 2 * M >= n`且`i < n`，此时显然当前玩家可以取走剩下的所有石子。
对于剩余情况，则需要遍历`range(1, 2 * M + 1)`来判断了。

现在问题是如何把当前玩家转化为Alice的最优策略。
由于Alice是先手，所以入口肯定是`dfs(0, 1)`。而最关键的点来了：
由于石子的总是总是确定的，所以为了要让最终Alice能够拿到尽量多的石子，我们需要保证Bob拿到尽可能少的石子。
换句话说，在`dfs(i, M)`中，进行下一层dfs时若取`x`则应当保证`dfs(i + x, max(x, M))`尽可能小。
更直接的，`sum(piles[i:]) - dfs(i + x, max(x, M))`最大。

基于以上的逻辑构建DFS过程就可以了。

剩下两个优化的点。
第一，i和M都是数字，可以记忆化搜索。
第二，每次调用sum比较低效，这里可以仿照前缀和，搞一个后缀和数组，从而根据`i`方便地拿到剩余石子的总数。

最后总结一下，这种dfs函数本身不管当前玩家是谁，只要求当前最佳策略。然后对某个特定玩家，dfs时要保证下一层dfs，即另一个玩家的回合时收益尽可能少，
这就是一个大体的博弈dfs的模板或者说思想。