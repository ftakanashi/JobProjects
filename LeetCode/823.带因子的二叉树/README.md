## 题目描述
给出一个含有不重复整数元素的数组 arr ，每个整数 arr[i] 均大于 1。

用这些整数来构建二叉树，每个整数可以使用任意次数。其中：每个非叶结点的值应等于它的两个子结点的值的乘积。

满足条件的二叉树一共有多少个？答案可能很大，返回 对 109 + 7 取余 的结果。

示例 1:
```
输入: arr = [2, 4]
输出: 3
解释: 可以得到这些二叉树: [2], [4], [4, 2, 2]
```
示例 2:
```
输入: arr = [2, 4, 5, 10]
输出: 7
解释: 可以得到这些二叉树: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].
```

提示：
```
1 <= arr.length <= 1000
2 <= arr[i] <= 109
arr 中的所有值 互不相同
```

### 解法 DP
题意不难理解。由于arr中的所有数字都是正整数且互不相同。
所以一个符合题目要求的树节点，其两个子节点，包括所有后辈节点，必然都是小于他的。

所以，我们先对arr做一个排序（给的几个示例数据都是有序的，但题目并不一定给出有序数据

排序后每遍历到一个数字，其实其可以组成的符合要求的树，其后辈节点一定都在其左侧，所以可以遍历左侧的所有节点看是否能成为其左右子节点。

于是，一个O(n^2)的DP套路就出来了。

我们定义和数组同长度的dp数组，`dp[i]`表示以排序后的`arr[i]`为根节点的符合要求的树总共有多少个。
显然，`dp[0]`以及所有对应数字是质数的`dp[i]`都是1。

一般的，则可以遍历`i`左边的数字`arr[j]`，看`arr[i] % arr[j]`是否等于0。
若等于0，可以整除，则看`arr[i] // arr[j]`是否也存在于arr中。设这个数字为`arr[k]`，若其存在，
则`dp[j] * dp[k] * 2` 就可以加到`dp[i]`上面去了。
这里，乘以2是考虑到左右子树的对称性。即`arr[j]`和`arr[k]`可以分别作为左右子树，形成的树是不同的。

这里还有一个小细节，存在一种可能，`arr[j] == arr[k]`。即`arr[i]`是一个完全平方数。
此时，上述因子式就不能乘以2，因为两边是对称的了。

以上就是DP的全部思路。最终要求的是全部的树的种类，所以返回应该是`sum(dp)`，考虑到mod还需要稍微处理一下。