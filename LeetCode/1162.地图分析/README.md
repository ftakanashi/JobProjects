## 题目描述
你现在手里有一份大小为 N x N 的 网格 grid，上面的每个 单元格 都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的。

我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个单元格之间的距离是 |x0 - x1| + |y0 - y1| 。

如果网格上只有陆地或者海洋，请返回 -1。
 

示例 1：
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/08/17/1336_ex1.jpeg)
```
输入：[[1,0,1],[0,0,0],[1,0,1]]
输出：2
解释： 
海洋单元格 (1, 1) 和所有陆地单元格之间的距离都达到最大，最大距离为 2。
```
示例 2：
```
输入：[[1,0,0],[0,0,0],[0,0,0]]
输出：4
解释： 
海洋单元格 (2, 2) 和所有陆地单元格之间的距离都达到最大，最大距离为 4。
```

提示：
```
1 <= grid.length == grid[0].length <= 100
grid[i][j] 不是 0 就是 1
```

### 解法 多源BFS
>这题好像是春招的时候网易的笔试题吧？…

用BFS没什么疑惑。一开始的思路也很自然，既然你要求全局的海洋离陆地最远距离，那么我就以一个个海洋作为起始点，做BFS探索，查找距离这个海洋最近的
陆地的距离。
最后取所有结果中最大的即可。

但是这么一波之后发现有数据无法AC。
看了答案，原来要用多源BFS。

首先转换视角，海洋到陆地的距离，也就是陆地到海洋的距离。如果从陆地出发进行BFS，探索到一个海洋之后，这必然是整个探索过程第一次探索到这里。
因此出发点陆地也是海洋离得最近的陆地了。
换句话说，从陆地开始，第一次探索到某个海洋时就可以确定该海洋距离陆地最近的距离了。

这么做好处很明显。原来，我要从每个海洋开始对整个地图进行探索，总体复杂度在`n^2 * n^2 = n^4`。
而如果改成了从陆地探索，两个起点出发的探索范围彼此相遇后就不会继续向前探索，因此总体只需要`n^2`。

然而问题是，陆地有很多，所以这是一个多源BFS问题。

多源BFS在实现上和普通BFS没有本质性区别，只不过在初始化的时候，添加多个点入队列就行了。
另一方面，多源BFS还可以这样理解：我有一个虚拟的源点，以同样的权值连接到了各个多源的起点。
第一步从虚拟源点开始，于是下一步就把真正的多源起点给入队了。我们这里，相当于直接跳过了脑内的第一步，直接初始到第二步，所以将多个起点入队。

以上。