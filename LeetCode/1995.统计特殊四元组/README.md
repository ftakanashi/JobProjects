## 题目描述
给你一个 下标从 0 开始 的整数数组 nums ，返回满足下述条件的 不同 四元组 (a, b, c, d) 的 数目 ：
```
nums[a] + nums[b] + nums[c] == nums[d] ，且
a < b < c < d
```
示例 1：
```
输入：nums = [1,2,3,6]
输出：1
解释：满足要求的唯一一个四元组是 (0, 1, 2, 3) 因为 1 + 2 + 3 == 6 。
```
示例 2：
```
输入：nums = [3,3,6,4,5]
输出：0
解释：[3,3,6,4,5] 中不存在满足要求的四元组。
```
示例 3：
```
输入：nums = [1,1,1,3,5]
输出：4
解释：满足要求的 4 个四元组如下：
- (0, 1, 2, 3): 1 + 1 + 1 == 3
- (0, 1, 3, 4): 1 + 1 + 3 == 5
- (0, 2, 3, 4): 1 + 1 + 3 == 5
- (1, 2, 3, 4): 1 + 1 + 3 == 5
```

提示：
```
4 <= nums.length <= 50
1 <= nums[i] <= 100
```

### 解法 哈希表
这题虽然标的等级是easy，但是实际上还是需要一点思考的…
被标了easy完全是因为数据比较友好，数据长度最长不过50。
所以直接四重循环暴力搜也可以过。
当然，暴力就不提了，这里来说说一种更高级的做法。

看到这道题，很容易想到twoSum系列。
我一开始也把这题当做是一个threeSum的变体来思考。
但是后来意识到，并非如此。

本题虽然不要求输出具体的下标各是多少，但是对于下标之间的关系，有严格要求`a < b < c < d`。
换言之，诸如`1,1,3,1`这样的一个输入，在题意中是不存在符合要求的四元组的。
而如果按照双指针做threeSum的思路，我们第一步就需要排序，从而打破了原数组的顺序，导致会出现合法的四元组。
因此，这题首先首先，不能排序！

既然不能排序，就尝试思考能不能用哈希的办法来做（也是借鉴了twoSum的另一种思路）。

设四个数分别是`a b c d`。要求`a + b + c == d`。
于是我们想到，可以逆序遍历数组，确定可能的d并将其加入哈希表。
在某个时刻，在哈希表中会有若干个可能的d，接着我们需要对前面的所有数做一个三重循环，找出所有可能的a,b,c的组合。
然后判断`a + b + c  in seen`。
这样的一种做法，复杂度在`O(n^3)`。

还可以进一步优化，将要求的等式移项，变成`a + b == d - c`。
针对这样一个等式，套用上面的思路，我们应该确定可能的`d - c`。
而可能的`d - c`无非针对某个位置右边进行一个`O(n^2)`的扫描而已。
而此时左边的`a + b`也是个`O(n^2)`的扫描。
所以这个做法可以做到整体复杂度是`O(n^2)`。

上面的这种思路很像`LC.454`，使用哈希表先在 n^2 时间里预处理一半的数据，然后再用 n^2 的时间检查另一半数据是否在哈希表中。
从而将原本朴素思路中的单向的 n^4 算法，通过付出一定空间给哈希表作为代价后，降低到 n^2 。

具体的，实现上述算法时还需要注意以下几点。
我们可以遍历b，以b为边界作为基准。
当遍历到某个特定的b时，按照上述描述应该对`range(b+1, n)`进行 n^2 的扫描确定所有 `d - c`的值。
但是因为扫描到当前的b之前，前面已经对大部分`d-c`做过计算了，所以这里只需要计算当 `c == b+1`时，
也就是这步扫描提供的一种新的c的可能，与后面所有d的差值即可。

另外，因为数据可能有重复，所以我们使用的哈希表不能是一个简单哈希集，而应该是一个计数器。
我们计算`d-c`差值的计数次数，倘若计数次数大于1次，说明有多种`a + b == d - c`的组合，都加上就是了。