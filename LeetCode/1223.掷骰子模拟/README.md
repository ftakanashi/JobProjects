## 题目描述
有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。

不过我们在使用它时有个约束，就是使得投掷骰子时，连续 掷出数字 i 的次数不能超过 rollMax[i]（i 从 1 开始编号）。

现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。

假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。

示例 1：
```
输入：n = 2, rollMax = [1,1,2,2,2,3]
输出：34
解释：我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。
```
示例 2：
```
输入：n = 2, rollMax = [1,1,1,1,1,1]
输出：30
```
示例 3：
```
输入：n = 3, rollMax = [1,1,1,2,2,3]
输出：181
```

提示：
```
1 <= n <= 5000
rollMax.length == 6
1 <= rollMax[i] <= 15
```

### 解法 DP
一道典型的DP型暴力的解法…

我们知道DP适合的问题是，某个状态的值依赖于上一个状态。但是这题中显然决定一个状态的维度非常多。
比如第几次掷骰子，掷出的值是多少，以及本次掷出的值连续了多少次了。

既然有那么多状态，那么就不断暴力升维即可。

具体的，我们定义一个size为 `n * 6 * 16` 的`dp`数组。
其中`dp[i][j][k]`表示，第`i`次掷骰子得到的值为`j`并且这个值已经连续了`k`个的总的排列数。
（为了方便，我们将骰子的1-6分别对应到值0-5。另外也请注意题目给出的最大的`rollMax`值是15，这也是为什么第三维长度是16的原因。
其实这里也可以把1-15映射到0-14，不过后面处理有点麻烦，就不这么处理了。

首先考虑初始值。显然`dp[0][j]`中，每个`dp[0][j][1]`都是`1`。
相当于第一次掷骰子，不论掷出的值是什么，都可以表示为连续了`1`个值的情况。且排列数都为1。

然后考虑状态转移方程（其实也没那么复杂）
试想，当我现在掷骰子得到了一个值`p`的时候，我可以考虑填充`dp[i][p]`中的15个值（下标1到下标15，下标0处为多余的浪费掉的空间）
大多数情况中，`p`和上一次的值（将其表示为`j`）不同，此时`dp[i][p]`的15个值，只有`dp[i][p][1]`是可以改的，并且值是`dp[i-1][j]`的和
另一方面，如果`p == j`，此时在`k + 1 <= rollMax[j]`的前提下，`dp[i][p][k + 1]`为`dp[i-1][j][k]`。

将上面的逻辑整理成代码就像这样：
```python
dp = [[[0 for _ in range(16)] for _ in range(6)] for _ in range(n)]
for j in range(6):
    dp[0][j][1] = 1

for i in range(1, n):
    for p in range(6):    # 假设当前掷到的值是p

        for j in range(6):    # 遍历上一次掷到的值
            if p == j:
                for k in range(1, 16):
                    # 遍历所有可能的连续次数
                    if k < rollMax[j]:
                        # 这次即使再掷出p，连续次数也符合条件时
                        dp[i][p][k+1] += dp[i-1][j][k]
                    else:
                        break
            else:
                # 本次掷出的值不等于上次的值的话，就比较自由了，可以整合上次掷出的所有值
                for k in range(1, 16):
                    dp[i][p][1] += dp[i-1][j][k]
```

最终要返回的，就是`dp[-1][j][k]`的总和。另外别忘了mod。

不难发现，上面的状态转移时第一维度只用到了`dp[i-1]`。
所以可以把第一维状态压缩。
详情见给出的代码。
