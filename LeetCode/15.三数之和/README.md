## 题目描述
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

 

示例：
>给定数组 nums = [-1, 0, 1, 2, -1, -4]，
>
>满足要求的三元组集合为：
>```
>[
>  [-1, 0, 1],
>  [-1, -1, 2]
>]
>```


### 解法1 双指针（twoSum进化版）
不知道为什么印象里总感觉这道题可以用哈希表做…
不过整了很久没整出来。
最后还是看了答案原来是双指针就行了。

记得twoSum的时候，可以排序然后前后双指针，比较和和指定结果的大小关系然后让双指针向中间移动。

这道题同理。只不过这次，指定的和是遍历中的某个数字且双指针范围限定在其右边即可。

总的来说算法如下：

首先排序数组。然后依次从左到右遍历。
当遍历到`nums[i]`时尝试寻找在`nums[i+1:]`中是否有和为`-nums[i]`的pair。

注意，由于排序了加上从左到右扫描，因此通常`nums[i] < 0`。
而这个子问题则是一个twoSum问题，按照twoSum的操作做就行了。
当`nums[i] > 0`（注意，为了防止`[0, 0, 0]`这种情况，等于零不能计入在内）了，其右边和肯定也大于0，不可能再有符合条件的pair，直接结束扫描。

由于题目要求结果中不能有重复的项目。最简单的做法当然是把结果收集器整成一个set就行了。

如果在扫描过程中就试图排除重复也不困难。首先是外层的`i`扫描的时候设置一个prev变量。
每次扫描到的如果和prev一样，那么可以直接跳过。
另一方面，内层循环双指针逼近的时候，其实有点麻烦，因为你既要考虑和各自prev的相同情况，也要考虑l和r的相对位置关系。

我给出的代码里，采用了结果容器set化以及外层循环的优化，内层双指针逼近的优化没有做。
从结果来看，外层循环优化后确实比单纯的结果容器set化要提高了很多速度。

总体来看，一开始排序用了O(nlogn)，然后扫描是O(n)，每次双指针逼近也是O(n)，后两部分是嵌套循环所以是O(n^2)。
整体上这个算法是O(n^2)的。