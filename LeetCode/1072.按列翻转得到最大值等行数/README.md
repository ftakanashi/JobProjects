## 题目描述
给定 m x n 矩阵 matrix 。

你可以从中选出任意数量的列并翻转其上的 每个 单元格。（即翻转后，单元格的值从 0 变成 1，或者从 1 变为 0 。）

返回 经过一些翻转后，行与行之间所有值都相等的最大行数 。

示例 1：
```
输入：matrix = [[0,1],[1,1]]
输出：1
解释：不进行翻转，有 1 行所有值都相等。
```
示例 2：
```
输入：matrix = [[0,1],[1,0]]
输出：2
解释：翻转第一列的值之后，这两行都由相等的值组成。
```
示例 3：
```
输入：matrix = [[0,0,0],[0,0,1],[1,1,0]]
输出：2
解释：翻转前两列的值之后，后两行由相等的值组成。
```

提示：
```
m == matrix.length
n == matrix[i].length
1 <= m, n <= 300
matrix[i][j] == 0 或 1
```

### 解法 哈希表
这题看似是矩阵的题，但是仔细思考一下发现其实没有那么复杂。

首先，由于对列的翻转总是整个列一起做的，所以如果能通过翻转若干次列之后让某一行全变成0或者1，那么意味着最开始和这行完全相等的行
在这个时刻都已经变成了全0或者全1。

除此之外，这题还有一个有意思的地方在于，当上面说的那种行变成全0或者全1后，最开始和此行的初始状态完全相反（0对1，,1对0）的行也会变成
符合要求的行。并且是0还是1，是反过来的。

我们称这样一种行以及其相反的行为一种特征行。
于是，题目就变成了，在一个矩阵中，寻找计数最多的特征行。问题变成了如何抽取这种特征以计数。

方法有很多，我还看到有人用连续数字来标识的。
我们这用了最简单的，字符串化。并且将所有以1开头的行全部都反转一次，统一把以0开头的行作为特征。

比如 `01110` 是一个特征行，对应的`10001`我们认为是同样特征的行，因为将其反转后就是`01110`。

计数自然用一个哈希表就行了。