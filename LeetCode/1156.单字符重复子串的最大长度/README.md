## 题目描述
如果字符串中的所有字符都相同，那么这个字符串是单字符重复的字符串。

给你一个字符串 text，你只能交换其中两个字符一次或者什么都不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度。

示例 1：
```
输入：text = "ababa"
输出：3
```
示例 2：
```
输入：text = "aaabaaa"
输出：6
```
示例 3：
```
输入：text = "aaabbaaa"
输出：4
```
示例 4：
```
输入：text = "aaaaa"
输出：5
```
示例 5：
```
输入：text = "abcdef"
输出：1
```

提示：
```
1 <= text.length <= 20000
text 仅由小写英文字母组成。
```

### 解法 模拟
虽然官答中把这种思路归类为滑窗，但是我觉得模拟的意味更重一点。并且细节很多。

首先在不考虑交换任何字符的情况下，显然我们可以通过从左到右扫描最长的连续子串是多长就可以得到答案。 这很简单。

我们假设现在我们扫描完了一个连续子串，且其中字符为`a`，长度为`m`。
此时由于连续子串已经扫描完了，所以当前位置的字符必然不是`a`。假设其为`x`
按照题意，我们现在可以考虑，将`x`置换为`a`。

这时的置换也不是随时可以进行的。有个隐性的前提条件是，在除了前面的一连串`a`之外，还有其他的`a`存在于字符串中。
这个判断比较容易的一个做法是事先维护一个counter计数，然后看连续`a`的个数是否小于等于`counter[a]`就行了。

这里还有一个细节，小于和等于还不一样。如果小于，说明除了这一片连续`a`之外，至少还有一个`a`可以拿来和`x`互换位置，因此可以更新的答案为`m + 1`。
若等于，则说明除了这一片连续`a`外已经没有`a`，此时应当更新答案为`m`本身。

除此之外，还需要考虑一种情况，就是如示例2那样，将`x`交换为`a`后，是否恰好能将后面的另一片连续`a`给连上。
这个事情可以通过在扫描完第一个连续子串后下标加1，再扫描相同字符的连续子串长度来判断。

这里还有最后一个需要注意的细节，假设字符串类似于`...aa...axaa...a...`，将`x`置换为`a`后可以将前后两片`a`连成一片从而让答案最大化。但是
具体的长度，则还需要看在这两片`a`外是否还有其他`a`。若有则可以满打满算将两片`a`长度加起来再加1。
若没有，那么拿来和`x`置换的`a`本身肯定也是在这片`a`当中的（是第一片的最左侧或者第二片的最右侧`a`），此时不应当额外加1。


考虑到以上所有细节，大致规划算法如下：

用游标`i`扫描一片连续的`a`。直到`text[i] != 'a'`，记录此时的下标为`j`。
收割答案`j - i`或者`j - i + 1`（取决于`j-i`和`counter['a']`之间的相对大小。

令`k = j + 1`，扫描下一片连续的`a`直到`text[k] != 'a'`。
收割答案`k - i`或者`k - i - 1`（取决于`k - i - 1`和`counter['a']`之间的相对大小

细节确实比较多，建议看下代码