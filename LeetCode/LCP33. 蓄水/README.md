## 题目描述
给定 N 个无限容量且初始均空的水缸，每个水缸配有一个水桶用来打水，第 i 个水缸配备的水桶容量记作 bucket[i]。小扣有以下两种操作：
```
升级水桶：选择任意一个水桶，使其容量增加为 bucket[i]+1
蓄水：将全部水桶接满水，倒入各自对应的水缸
```
每个水缸对应最低蓄水量记作 vat[i]，返回小扣至少需要多少次操作可以完成所有水缸蓄水要求。

注意：实际蓄水量 达到或超过 最低蓄水量，即完成蓄水要求。

示例 1：
```
输入：bucket = [1,3], vat = [6,8]
输出：4
解释： 第 1 次操作升级 bucket[0]； 第 2 ~ 4 次操作均选择蓄水，即可完成蓄水要求。vat1.gif
```

示例 2：
```
输入：bucket = [9,0,1], vat = [0,2,2]
```

输出：3
```
解释： 第 1 次操作均选择升级 bucket[1] 第 2~3 次操作选择蓄水，即可完成蓄水要求。
```

提示：
```
1 <= bucket.length == vat.length <= 100
0 <= bucket[i], vat[i] <= 10^4
```

### 解法 贪心
题意不是特别复杂，关键还是在于思路。
首先应该明确，如果确实需要进行升级水桶的操作，那么升级操作一定比蓄水操作要更靠前。这样才是符合利益最大化的。
升级一次再蓄水，比蓄水一次再升级，铁定可以多注水1个单位。这点没有疑问。
另外，蓄水次数一定不为零，所以所有的操作可以分成前几个升级操作（如果有必要的话）以及后几个蓄水操作。

在确定这个前提的情况下，我们可以考虑设总共有`k`次蓄水操作。
对于一个水缸和对应的桶`vat[i]`和`bucket[i]`来说，存在这样一个关系，就是`bucket[i] * k >= vat[i]`。
反过来，也就是`bucket[i] >= ceil(vat[i] / k)`。注意，初始时`bucket[i]`可能没到达这个水平，因此就需要升级操作了。

因此，大体的思路就出来了。
`k`的取值范围可以定的稍微宽泛一点，比如最小值肯定是1即一次到位全部注水完毕，最大值很难确定，可以简单设置为`max(vat) + 1`。
我们只需要遍历其中所有可能的`k`，然后计算对所有桶缸对而言，各自的`bucket[i]`需要升级的次数（最少为0，最大为`vat[i]`）。
然后统计每种`k`的情况下，`k`加上各个桶升级次数的总和，就是此时的答案了。

收割出全局最小答案即可。