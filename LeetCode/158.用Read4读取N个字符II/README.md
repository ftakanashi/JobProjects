## 题目描述
给你一个文件 file ，并且该文件只能通过给定的 read4 方法来读取，请实现一个方法使其能够使 read 读取 n 个字符。注意：你的 read 方法可能会被调用多次。

read4 的定义：

read4 API 从文件中读取 4 个连续的字符，然后将这些字符写入缓冲区数组 buf4 。

返回值是读取的实际字符数。

请注意，read4() 有其自己的文件指针，类似于 C 中的 FILE * fp 。
```
    参数类型: char[] buf4
    返回类型: int
```
注意: buf4[] 是目标缓存区不是源缓存区，read4 的返回结果将会复制到 buf4[] 当中。

下列是一些使用 read4 的例子：
```
File file("abcde"); // 文件名为 "abcde"， 初始文件指针 (fp) 指向 'a' 
char[] buf4 = new char[4]; // 创建一个缓存区使其能容纳足够的字符
read4(buf4); // read4 返回 4。现在 buf4 = "abcd"，fp 指向 'e'
read4(buf4); // read4 返回 1。现在 buf4 = "e"，fp 指向文件末尾
read4(buf4); // read4 返回 0。现在 buf4 = ""，fp 指向文件末尾
```

read 方法：

通过使用 read4 方法，实现 read 方法。该方法可以从文件中读取 n 个字符并将其存储到缓存数组 buf 中。您 不能 直接操作 file 。

返回值为实际读取的字符。

read 的定义：
```
    参数类型:  char[] buf, int n
    返回类型:  int
```
注意: buf[] 是目标缓存区不是源缓存区，你需要将结果写入 buf[] 中。
注意：
```
你 不能 直接操作该文件，文件只能通过 read4 获取而 不能 通过 read。
read  函数可以被调用 多次。
请记得 重置 在 Solution 中声明的类变量（静态变量），因为类变量会 在多个测试用例中保持不变，影响判题准确。请 查阅 这里。
你可以假定目标缓存数组 buf 保证有足够的空间存下 n 个字符。 
保证在一个给定测试用例中，read 函数使用的是同一个 buf。
```

示例 1：
```
输入： file = "abc"， queries = [1,2,1]
输出：[1,2,0]
解释：测试用例表示以下场景:
File file("abc");
Solution sol;
sol.read (buf, 1); // 调用 read 方法后，buf 应该包含 “a”。我们从文件中总共读取了 1 个字符，所以返回 1。
sol.read (buf, 2); // 现在 buf 应该包含 "bc"。我们从文件中总共读取了 2 个字符，所以返回 2。
sol.read (buf, 1); // 我们已经到达文件的末尾，不能读取更多的字符。所以返回 0。
假设已经分配了 buf ，并保证有足够的空间存储文件中的所有字符。
```
示例 2：
```
输入：file = "abc"， queries = [4,1]
输出：[3,0]
解释：测试用例表示以下场景:
File file("abc");
Solution sol;
sol.read (buf, 4); // 调用 read 方法后，buf 应该包含 “abc”。我们从文件中总共读取了 3 个字符，所以返回 3。
sol.read (buf, 1); // 我们已经到达文件的末尾，不能读取更多的字符。所以返回 0。
```

提示：
```
1 <= file.length <= 500
file 由英语字母和数字组成
1 <= queries.length <= 10
1 <= queries[i] <= 500
```

### 审题
真是读题都读了半个小时…
其实read，read4这类函数的逻辑应该是很贴合比较底层的比如C语言之类的逻辑的，但是放到Python中，就觉得这特么是个啥玩意儿…

Python中的列表没有了固定长度这个概念，但是这题中，你应该时刻意识到这里面碰到的所有列表都是在模拟数组，因此都是应该具有固定长度的。在这个基础上继续审题。

首先，应该意识到buf和buf4是两个不同的数组。
buf4是传递给read4的参数，其应该是一个长度为4的数组。作用是将read4返回的结果依次保存在其各个位置上。
注意，buf4由于固定长度4，所以会用空字符串来代表一个空值，即更底层语言中所谓的未初始化的值。

一个Python语境中调用read4的例子大概如下：
```python
buf4 = ["" for _ in range(4)]    # 声明一个固定长度为4的列表
# 假设我们读取的文件内容是 "abc" ，即长度为3
read_cnt = read4(buf4)    # 调用read4
# 此时read_cnt == 3
# 并且，buf4变成了 ["a", "b", "c", ""]
```

而buf则是每次调用read后的输出。
题目中也说了，其足够长，能够容纳每次输出的所有内容（实际上我调试的时候打印了下，发现其长度是512，即512个空字符串组成的列表）。
每次调用`read(buf, n)`时，按照题目的要求，将输出内容（大多数时候是长度为n的字符串，若n很大超过了文件剩余内容，则是剩余内容长度的字符串）
以字符的单位从左到右依次放入buf。
本题虽然说要求read函数返回实际返回的字符数，但是其实不用返回任何内容，后台程序是通过读取buf中内容来判case是否通过的。
注意每次调用read方法的时候题目并不会清空buf，所以还需要手动完成这一操作。

### 解法 队列 缓存
理清楚题目意思之后，基本上就能感觉到这题的一个难点以及大概的解决办法了。
难点就是，由于多次调用，而每次调用读取出来的字符串可能会多于要求的字符数`n`。
而多出来的那部分已经读出来了，不能塞回文件里，该怎么办。

解决办法也很自然能够想到，放个缓存就行了。
当read被调用时，不是直接去进一步调用read4，而是先检查下缓存，如果缓存中还有内容就先用缓存中的内容。
且有可能缓存中的内容本身就能够满足此次read调用要求的字符数n，若如此那read4都不用调用，直接就可以写入buf了。

而上述缓存显然是一个FIFO的结构，所以我这里用了队列。

具体的更多细节都写在了代码注释中。

