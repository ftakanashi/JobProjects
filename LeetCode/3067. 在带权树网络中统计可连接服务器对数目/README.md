## 题目描述
给你一棵无根带权树，树中总共有 n 个节点，分别表示 n 个服务器，服务器从 0 到 n - 1 编号。同时给你一个数组 edges ，其中 edges[i] = [ai, bi, weighti] 表示节点 ai 和 bi 之间有一条双向边，边的权值为 weighti 。再给你一个整数 signalSpeed 。

如果两个服务器 a ，b 和 c 满足以下条件，那么我们称服务器 a 和 b 是通过服务器 c 可连接的 ：
```
a < b ，a != c 且 b != c 。
从 c 到 a 的距离是可以被 signalSpeed 整除的。
从 c 到 b 的距离是可以被 signalSpeed 整除的。
从 c 到 b 的路径与从 c 到 a 的路径没有任何公共边。
```
请你返回一个长度为 n 的整数数组 count ，其中 count[i] 表示通过服务器 i 可连接 的服务器对的 数目 。

示例 1：

![](https://assets.leetcode.com/uploads/2024/01/21/example22.png)
```
输入：edges = [[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]], signalSpeed = 1
输出：[0,4,6,6,4,0]
解释：由于 signalSpeed 等于 1 ，count[c] 等于所有从 c 开始且没有公共边的路径对数目。
在输入图中，count[c] 等于服务器 c 左边服务器数目乘以右边服务器数目。
```
示例 2：

![](https://assets.leetcode.com/uploads/2024/01/21/example11.png)
```
输入：edges = [[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]], signalSpeed = 3
输出：[2,0,0,0,0,0,2]
解释：通过服务器 0 ，有 2 个可连接服务器对(4, 5) 和 (4, 6) 。
通过服务器 6 ，有 2 个可连接服务器对 (4, 5) 和 (0, 5) 。
所有服务器对都必须通过服务器 0 或 6 才可连接，所以其他服务器对应的可连接服务器对数目都为 0 。
```

提示：
```
2 <= n <= 1000
edges.length == n - 1
edges[i].length == 3
0 <= ai, bi < n
edges[i] = [ai, bi, weighti]
1 <= weighti <= 106
1 <= signalSpeed <= 106
输入保证 edges 构成一棵合法的树。
```

### 解法 DFS
这题属于是写出来了之后觉得肯定AC不了，结果AC了的…

首先理解题意，要求是`a`和`b`两个点都可以走到`c`且路径和可以被标志数整除。另外这两个路径不能有重合。
结合题目明确说的给出的图是一个树来看，实际上我们可以视作以`c`为根节点的一棵树。

而`a`和`b`分别是位于两个不同子树中的节点。

至此其实大概的算法就已经有了。
我们以某个节点为根，进行DFS遍历。dfs函数的逻辑为从某个节点出发遍历其所有后辈节点，从中寻找可达节点的数目。
所谓可达节点，就是到达这个节点的总路程可以被标志数整除的情况。

dfs函数写出来之后，其实还没完。
针对任意一个节点作为根节点，此时我们应当从其各个子节点开始遍历，以便找出其所有互相独立的子树中可达节点的数量。
而如果其只有一个子树，那么无论其中有多少可达节点，对于当前的根节点来说，并不存在任何符合要求的节点对，只能是0。

如此，我们遍历所有节点，按照上述算法将一个节点作为根节点时的各个子树中的可达节点数量找到。若其子树数量大于1，则每两个子树中的可达节点的乘积，
表示这两个子树中可达节点两两配对的情况。将总数加起来即可。

最后一个小知识点别忘了，因为题目保证图是一棵树，所以其总结点数目是边数+1。