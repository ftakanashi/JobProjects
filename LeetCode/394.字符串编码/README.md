## 题目描述
给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

示例 1：
```
输入：s = "3[a]2[bc]"
输出："aaabcbc"
```
示例 2：
```
输入：s = "3[a2[c]]"
输出："accaccacc"
```
示例 3：
```
输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"
```
示例 4：
```
输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"
```

### 解法1 递归模拟
由于题目保证了输入的合法性，所以模拟起来很方便。
可能真正麻烦的在于示例2这种括号里面的括号。此时很自然地想到用递归的办法去接。

从左到右依次扫描，碰到数字，则累计数字位数看到底是多少（因为数字有可能是两位数及以上）

碰到字母，直接收割进结果。

碰到括号，则一方面记住这个括号对应的前面的数字，即倍数。

另一方面找到这个左括号匹配的右括号，然后将期间部分取出来。

找匹配括号这个问题可以用栈，不过由于这里只有中括号，更简单的，可以直接维护一个`left_count`表示当前还未匹配到的左括号。
碰到一个左括号自增1，碰到一个右括号自减1。

取出中括号里面的部分之后，递归调用函数本身并将结果乘以倍数，收割到结果中。

### 解法2 栈
一对中括号内部转化后的内容，在没看到右括号之前是无法确定的。
但是如果线性扫描，扫描到右括号就得回过头来处理内部内容。

回过头，因此用栈。

算法描述如下。
从左到右扫描，碰到所有非']'的字符全部都入栈。
当碰到']'时，从栈中弹出元素并维护部分结果res，直到栈中弹出了第一个'['。

然后是看res要重复几遍，还是从栈里弹出，这次是直到栈顶不是数字才停止弹出。
这些数字组成n。

然后，获得重复n遍的res，相当于就把`n[res]`给转化好了。
这个转化好的结果，把他当做一个普通字母，再次入栈。

扫描全部完成后，栈中会有一到多个字符串，将这些字符串按顺序串起来就是答案了。