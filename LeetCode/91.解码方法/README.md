## 题目描述
一条包含字母 A-Z 的消息通过以下方式进行了编码：
```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```
给定一个只包含数字的非空字符串，请计算解码方法的总数。

题目数据保证答案肯定是一个 32 位的整数。

示例 1：
>输入：s = "12"
>
>输出：2
>
>解释：它可以解码为 "AB"（1 2）或者 "L"（12）。

示例 2：
>输入：s = "226"
>
>输出：3
>
>解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。

示例 3：
>输入：s = "0"
>
>输出：0

示例 4：
>输入：s = "1"
>
>输出：1

示例 5：
>输入：s = "2"
>
>输出：1
 
提示：
- 1 <= s.length <= 100
- s 只包含数字，并且可能包含前导零。

### 解法1 DFS
比较经典的DFS情况。

其实最开始一眼，以为要用DP。但是仔细分析一下发现，要求的不是某个最大值或者最小值，而是方案总数，直觉上来说
DFS更方便一点（当然DP也可以做）

那么问题就是如何设计DFS函数了。

显然传入的参数应该是某个下标n。那么函数设计为求"从n开始往后的子字符串s[n:]总共有几种分法"的函数。

递归的，这个函数可以分解为以下的逻辑。

如果s[n]是0，那么很遗憾s[n:]不可分，所以是0。

如果s[n]不是0，那么首先可以是s[n+1:]的count加上1。其次还需要考虑s[n:n+2]刚好小于27的情况，此时是s[n+2:]的count加上1。
前后两种情况加起来就是所求值。

边界条件，则是当n大于等于len(s)时，表明探索到了头，此时返回1，表示找到了一种可能的分法。

按照上述想法，写出代码：
```python
def dfs(n: int) -> int:
    if n >= len(s):
        return 1

    c1 = c2 = 0
    if s[n] != '0':
        c1 = dfs(n + 1)
        if n < len(s) - 1 and 0 < int(s[n:n+2]) < 27:
            c2 = dfs(n + 2)
    return c1 + c2
```

不过这个函数提交会超时。问题就是DFS最常见的，重复计算太多了。

于是很自然的，想到整一个数组保存计算结果，如果计算结果已经存在就直接取用。

这个数组保存的计算结果就是每个n的dfs函数的返回值。即mem[n]代表的是s[n:]的分法数目。

于是，dfs+记忆机制，就可以跑过去了。

### 解法2 DP
既然可以用DFS做，那么显然也可以用DP做。

显然 DP数组`dp[i]`的含义应该是子串`s[:i+1]`总共有几种分法。

可能稍微困难一点的是考虑状态转移方程如何设计。
先从没有0的情况入手，没有0时，其实状态`dp[i]`是`dp[i-1]`以及`dp[i-2] if s[i-1:i+1] <= 26 else 0`的和。

再考虑存在0时的情况。其实只需要考虑当前字母和前一个字母。这无非就三种情况，其中一个为0或者两个都为0。

实际上，当当前位置是0的时候，只有前一个字母是1或者2的时候才是合法的，可以加上`dp[i-2]`。
且当前位置一旦是0，就不能加`dp[i-1]`了，因为0不能单独分出来。

另一方面，当当前位置不是0而前一个是0的时候，此时则不能加`dp[i-2]`，相反，`dp[i-1]`始终可以加。

综上所述，状态转移方程的规则设计如下：
```text
if 当前字符是0:
    if 前一个字符是1或2:
        dp[i] += dp[i-2]
else:
    if 前一个字符不是0 and s[i-1:i+1] <= 26:
        dp[i] += dp[i-2]
    dp[i] += dp[i-1]
```

将上述规则给代码化即可。注意这里因为涉及到`i-2`这个位置，
所以DP数组初始化的时候要在头上设立一个dummy位置，以保证`i=2`时也可以正确处理。
因此要注意dp数组和字符串的下标之间差一位。

当然上述是状态不压缩的情况。正式代码给出的是状态压缩后的优化版本。不压缩的写在注释里了。