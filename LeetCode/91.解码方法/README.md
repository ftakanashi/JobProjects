## 题目描述
一条包含字母 A-Z 的消息通过以下方式进行了编码：
```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```
给定一个只包含数字的非空字符串，请计算解码方法的总数。

题目数据保证答案肯定是一个 32 位的整数。

示例 1：
>输入：s = "12"
>
>输出：2
>
>解释：它可以解码为 "AB"（1 2）或者 "L"（12）。

示例 2：
>输入：s = "226"
>
>输出：3
>
>解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。

示例 3：
>输入：s = "0"
>
>输出：0

示例 4：
>输入：s = "1"
>
>输出：1

示例 5：
>输入：s = "2"
>
>输出：1
 
提示：
- 1 <= s.length <= 100
- s 只包含数字，并且可能包含前导零。

### 解法 DFS
比较经典的DFS情况。

其实最开始一眼，以为要用DP。但是仔细分析一下发现，要求的不是某个最大值或者最小值，而是方案总数，直觉上来说
DFS更方便一点（当然DP也可以做）

那么问题就是如何设计DFS函数了。

显然传入的参数应该是某个下标n。那么函数设计为求"从n开始往后的子字符串s[n:]总共有几种分法"的函数。

递归的，这个函数可以分解为以下的逻辑。

如果s[n]是0，那么很遗憾s[n:]不可分，所以是0。

如果s[n]不是0，那么首先可以是s[n+1:]的count加上1。其次还需要考虑s[n:n+2]刚好小于27的情况，此时是s[n+2:]的count加上1。
前后两种情况加起来就是所求值。

边界条件，则是当n大于等于len(s)时，表明探索到了头，此时返回1，表示找到了一种可能的分法。

按照上述想法，写出代码：
```python
def dfs(n: int) -> int:
    if n >= len(s):
        return 1

    c1 = c2 = 0
    if s[n] != '0':
        c1 = dfs(n + 1)
        if n < len(s) - 1 and 0 < int(s[n:n+2]) < 27:
            c2 = dfs(n + 2)
    return c1 + c2
```

不过这个函数提交会超时。问题就是DFS最常见的，重复计算太多了。

于是很自然的，想到整一个数组保存计算结果，如果计算结果已经存在就直接取用。

这个数组保存的计算结果就是每个n的dfs函数的返回值。即mem[n]代表的是s[n:]的分法数目。

于是，dfs+记忆机制，就可以跑过去了。