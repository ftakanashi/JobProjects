## 题目描述
有 n 个网络节点，标记为 1 到 n。

给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。

现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。

示例 1：
```
输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
输出：2
```
示例 2：
```
输入：times = [[1,2,1]], n = 2, k = 1
输出：1
```
示例 3：
```
输入：times = [[1,2,1]], n = 2, k = 2
输出：-1
```

提示：
```
1 <= k <= n <= 100
1 <= times.length <= 6000
times[i].length == 3
1 <= ui, vi <= n
ui != vi
0 <= wi <= 100
所有 (ui, vi) 对都 互不相同（即，不含重复边）
```

### 解法 Dijkstra算法
一个典型的Dijkstra算法的案例。

Dijkstra算法的具体就不说了，看经典数据结构与算法那个文件夹吧。

值得一提的是，Dijkstra除了基于堆的写法，还有一种基于枚举的写法。即在选择下一条要处理的边的时候，并不是选择
目前全局距离最小的边，而是简单地选择BFS中的下一条边。
在有visited机制的情况下，这种写法也是可以正确得到结果的。当然复杂度会更高一些。

另一方面，使用堆写，假设图有m条边，n个节点的话，前期准备工作（指构建dist数组）是O(n)的。
而在扫描的过程中，每条边都入堆、出堆一次，所以这块复杂度是O(mlogm)。

整体复杂度在O(n + mlogm)。