## 题目描述
给你一个由非负整数组成的数组 nums 。另有一个查询数组 queries ，其中 queries[i] = [xi, mi] 。

第 i 个查询的答案是 xi 和任何 nums 数组中不超过 mi 的元素按位异或（XOR）得到的最大值。换句话说，答案是 max(nums[j] XOR xi) ，其中所有 j 均满足 nums[j] <= mi 。如果 nums 中的所有元素都大于 mi，最终答案就是 -1 。

返回一个整数数组 answer 作为查询的答案，其中 answer.length == queries.length 且 answer[i] 是第 i 个查询的答案。

示例 1：
```
输入：nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]
输出：[3,3,7]
解释：
1) 0 和 1 是仅有的两个不超过 1 的整数。0 XOR 3 = 3 而 1 XOR 3 = 2 。二者中的更大值是 3 。
2) 1 XOR 2 = 3.
3) 5 XOR 2 = 7.
```
示例 2：
```
输入：nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]
输出：[15,-1,5]
```

提示：
```
1 <= nums.length, queries.length <= 10^5
queries[i].length == 2
0 <= nums[j], xi, mi <= 10^9
```

### 解法 字典树
这题是`LC.421`的加强版。

首先大的方向是使用字典树，解析nums中每个数字的二进制形式进去。

在`LC.421`中，由于没有`m`这个大小的限制，因此可以在已经建立好的树中自由地"唱反调"搜索。
而这题，由于多了`m`这个限制，不能自由搜索了。

特别是，比如query数的某位是0，而树的当前节点存在右子树时，本来可以直接朝右子树走一步，从而让异或结果更大。
可如果此时右子树代表的所有数字，都比要求的限制m大的话，就不能走了。
因此，再搜索过程中，除了考虑子树是否存在之外，还要将限制`m`也纳入考虑。

一开始我还尝试能不能用已经有的资源来考虑限制的问题，比如实时维护扫描到当前节点时，树中目标数的值。
但是发现这个值总是比子树中的值们小，因此不能作为依据。
最后的解决方案，是在每个树节点中加上一个`min_v`属性，用于记录以这个节点为根的子树中的最小值。
这样，每当可能要往这个节点走时，只要查看这个`min_v`是否符合限制要求，如果是，才可以走。

另外，`LC.421`的题目要求中数字限制是32位整数，而这题是10^9，因此最高位可以从31变成30，稍微节省一点时间。
在搜索树的过程中，如果某个节点的`min_v`大于了限制，则直接返回-1。

不要小看上面的优化。因为这题数据比较大，随便写写的代码耗时在10s前后徘徊，运气好点进10s的话能AC，超过了的话那就超时了。
加上上面优化后勉强能进9s。

答案的代码能到6s左右，大体逻辑框架是一样的，可能是一些细节的优化吧，目前懒得看了。