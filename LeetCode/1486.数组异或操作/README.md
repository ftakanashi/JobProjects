## 题目描述
给你两个整数，n 和 start 。

数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。

请返回 nums 中所有元素按位异或（XOR）后得到的结果。

示例 1：
```
输入：n = 5, start = 0
输出：8
解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。
     "^" 为按位异或 XOR 运算符。
```
示例 2：
```
输入：n = 4, start = 3
输出：8
解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8.
```
示例 3：
```
输入：n = 1, start = 7
输出：7
```

提示：
```
1 <= n <= 1000
0 <= start <= 1000
n == nums.length
```

### 解法 位运算 异或运算的性质
直接模拟的方法很简单 就不说了。
这里提一种通过利用异或运算的性质，从而实现O(1)时间的解法。

异或运算有以下几种运算性质：
```text
1. x^x = 0
2. x^y = y^x    交换律
3. (x^y)^z = x^(y^z)    结合律
4. x^y^y = x    自反性
5. 对于任意的i,都有 4i ^ 4i+1 ^ 4i+2 ^ 4i+3 = 0
```

这道题可以利用性质5。
由于性质5要求是连续的数列，这题给出的是步长是2的数列，这时候可以通过砍掉最后一位来实现转换。
换言之，首先输入的数列中每个数的奇偶性都是相同的。因此，只有当n和start同时为奇数时结果末位才是1，否则都是0。

在这个前提下，可以将原来要求的`start ^ start+2 ^ start+4 ...`转化成：
`(s ^ (s+1) ^ (s+2) ^ ... ^ (s + n - 1)) * 2 + e`。其中`s = start // 2`而`e`可以提前通过检查`n`和`start`获得。

接下来问题就变成如何求`s ^ (s+1) ^ (s+2) ^ ... ^ (s + n - 1)`。
利用上述性质5，其实可以知道，`0 ^ 1 ^ 2 ^ ... ^ n`可以根据末尾`n`针对4的余数的情况分类。
将这个过程定义为`f(n)`的话：
```text
if n % 4 == 0: f(n) = n
if n % 4 == 1: f(n) = n ^ (n-1)
if n % 4 == 2: f(n) = n ^ (n-1) ^ (n-2)
if n % 4 == 3: f(n) = n ^ (n-1) ^ (n-2) ^ (n-3)
```

而`f(s + n - 1)`其实可以写成`f(s-1) ^ X`，其中X就是我们要求的东西。
等式两边同时再异或一个`f(s-1)`，结合性质1，得到结果：
`X = f(s+n-1) ^ f(s-1)`。

按照上述思路，定义一个函数f，就可以了。