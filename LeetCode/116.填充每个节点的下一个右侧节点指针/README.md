## 题目描述
给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。
 

进阶：
- 你只能使用常量级额外空间。
- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。
 

示例：
![](https://assets.leetcode.com/uploads/2019/02/14/116_sample.png)
```
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
```

提示：
- 树中节点的数量少于 4096
- -1000 <= node.val <= 1000

### 解法1 BFS
第一种很直观的解法，BFS层序遍历，每层扫描出来之后按顺序把next指针接上就行了。

不解释。

### 解法2 递归
这种办法挺巧妙的。

想要解决题目这个任务，很明显递归函数里应该把`node.left.next = node.right`。

然而这个图中除了这种next连接之外，还有一种跨子树的next连接。比如上面示例中的5到6的连接。

这个连接没有办法在一个子树的范围内解决。如果你想做`node.left.right.next = node.right.left`之类的操作的话，
那么再加深一层就又不行了。
因此需要想一个办法，如何在处理当前子树时，可以refer到其右边的那一棵树（并不一定是其父节点的右子树，随着层数变深，有可能会是更远的关系）。

其实题目已经给出了这种reference，用next指针啊！

所以思路就出来了，每处理某课子树的时候，我希望其根节点的next已经搭建好（这样才能refer过去）。
这时除了让我自己的`node.left.next = node.right`之外，再让`node.right.next = node.next.left`即可。

由于在处理子树`node`时要求`node.next`已经搭建好，所以递归函数中各项处理的顺序不能乱了。