## 题目描述
给定一个无重复元素的数组 candidates 和一个目标数 target ，

找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：
- 所有数字（包括 target）都是正整数。
- 解集不能包含重复的组合。 

示例 1：
>输入：candidates = [2,3,6,7], target = 7,
>
>所求解集为：
>```
>[
>  [7],
>  [2,2,3]
>]
>```
示例 2：
>输入：candidates = [2,3,5], target = 8,
>
>所求解集为：
>```
>[
>  [2,2,2,2],
>  [2,3,3],
>  [3,5]
>]
>```

提示：
- 1 <= candidates.length <= 30
- 1 <= candidates[i] <= 200
- candidate 中的每个元素都是独一无二的。
- 1 <= target <= 500

### 解法1 DFS（回溯）
不限定个数，又要求组合，满满的可以用DFS做的感觉。

写了第一版，dfs函数的参数是已经选择的数字`choices`，基于此继续探索其余数字。

同时为了能够剪枝提升效率，可以提前将candidates先排个序（虽然例子给出的都是排好序的，但是条件并没有说一定是有序的）。

排序后的candidates，探索的时候当choices总和加上某个元素超过了target，那么这个元素之后的所有都可以不用管，直接break即可。

按照上述思想写代码后发现问题，由于每个元素不限取用次数，所以每进新一层递归都从candidates的头开始探索起。

这样一来，以示例一数据为例，最终结果集中有`[2,2,3],[2,3,2],[3,2,2]`这些。但是这些不能重复算。

由于已经排好序了，所以改进如下：
每层递归进去dfs后只能取用进递归前加入到choices中的最后一个元素及其之后的元素。

这样，还是以示例一为例，探索过程中，当3已经进入choices之后，就不会再去选2，因此后两种结果就得到回避了。

为了这个改进，相应地需要dfs函数加一个start参数表示每次探索的下边界。