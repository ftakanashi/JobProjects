## 题目描述

给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。

如果存在这样的三元组下标 (i, j, k) 且满足 i < j < k ，使得 nums[i] < nums[j] < nums[k] ，返回 true ；否则，返回 false 。

示例 1：
```
输入：nums = [1,2,3,4,5]
输出：true
解释：任何 i < j < k 的三元组都满足题意
```
示例 2：
```
输入：nums = [5,4,3,2,1]
输出：false
解释：不存在满足题意的三元组
```
示例 3：
```
输入：nums = [2,1,5,0,4,6]
输出：true
解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] == 0 < nums[4] == 4 < nums[5] == 6
```

提示：
- 1 <= nums.length <= 105
- -231 <= nums[i] <= 231 - 1
- 进阶：你能实现时间复杂度为 O(n) ，空间复杂度为 O(1) 的解决方案吗？


### 解法 伪单调栈 + 二分查找
其实这题就是一个简单版的`LC300.最长递增子序列`。那题里需要求最长，而这里只要求出有没有长度大于等于3的即可。
换句话说，只要在扫描过程中发现任意一个大于3的，那就可以了。

因此那题的做法都可以适用到这题里。

O(n^2)的DP当然也可以，这里选用伪单调栈的做法。

伪单调栈在于当新元素比栈顶小的时候，不是pop栈顶，而是在栈中找到第一个比其大的元素然后直接修改之的做法。
寻找过程可以用二分查找。

### 解法2 双指针
感觉又是一个新套路…

因为说是三元组就行，所以可以设置两个指针，p0和p1。

从左到右的扫描过程中，p0指向扫描过的最小的数，而p1指向p0之后比p0大但最小的数。

这样加入新扫描到的数比p1还大，那么条件就成立了。

#### 2022/01/12 追加笔记
解法2其实是一种简化版的解法1。

解法1中显式维护了一个单调栈，参考了`LC.300`那样的套路，将新扫描到的数字替换单调栈中相应位置的元素，
从而扫描整个数组所有递增序列。

因为这道题固定要找的递增序列长度为3，因此实际上我们知道解法1中的单调栈永远长度永远不会超过3
（甚至不超过2，因为一旦有了合法的第三个元素，不用加入栈我们就可以返回True了。

既然如此，那么也就无需显式维护单调栈，直接整两个变量模拟单调栈中的第一个元素和第二个元素就可以了。
这也就是解法2的双指针。

