## 题目描述
给你一个整数数组 nums 和一个正整数 k ，返回长度为 k 且最具 竞争力 的 nums 子序列。

数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。

在子序列 a 和子序列 b 第一个不相同的位置上，如果 a 中的数字小于 b 中对应的数字，那么我们称子序列 a 比子序列 b（相同长度下）更具 竞争力 。 例如，[1,3,4] 比 [1,3,5] 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， 4 小于 5 。

示例 1：
```
输入：nums = [3,5,2,6], k = 2
输出：[2,6]
解释：在所有可能的子序列集合 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 最具竞争力。
```
示例 2：
```
输入：nums = [2,4,3,3,5,4,9,6], k = 4
输出：[2,3,3,4]
```

提示：
```
1 <= nums.length <= 105
0 <= nums[i] <= 109
1 <= k <= nums.length
```

### 解法 单调栈
这题还挺有味道的。

首先想一想应该还是能想到通过单调栈来做。
但问题在于，由于还指定了一个最终子序列的答案长度`k`，如果在维护单调栈的整个过程中栈没有任意一个时刻的长度达到`k`，
那就意味着没有办法获得一个完美的单调递增子序列。

可这并不意味着无解。
把示例2的输入稍微变一下，变成 `[4,2,3,3,5,4,9,6]`，然后让 `k=6`。
可以发现，当`k=5`时我们还能获得一个完美的不递减子序列 `2 3 3 4 6`。
但`k=6`时，我们不得不引入9来完成子序列。

注意此处不引入5，因为按字典序 `2 3 3 5 4 6` 比 `2 3 3 4 9 6`更大。

因此，在维护单调栈的时候，我们还需要额外引入一个 "剩余数字全部入栈是否能得到长度为`k`的序列" 的判断。
以上面的例子为例，当我们扫描到9时，我们会发现此时单调栈长度是4，而我们只剩下两个数字，为达到`k=6`的要求，只能全部取用了。

不用担心 "一直到现在才全部取用，前面有一些数字还是按照单调栈规则被抛弃了，会不会导致没有扫描到所有可能"。因为此时的单调栈
就是扫描过的片段中长度为4的子序列中字典序最小的。一旦改前面的数字，只会把最终答案的字典序变大。

最后还有一个小细节，如何收割答案。
一开始我在每次 `stack.append` 之后进行一次判断，若 `len(stack) == k` 则收割一次答案。

看了官方解答后才反应过来没必要，只需要将最后stack的前`k`位返回即可。