## 题目描述
给你一个二维矩阵 matrix 和一个整数 k ，矩阵大小为 m x n 由非负整数组成。

矩阵中坐标 (a, b) 的 值 可由对所有满足 0 <= i <= a < m 且 0 <= j <= b < n 的元素 matrix[i][j]（下标从 0 开始计数）执行异或运算得到。

请你找出 matrix 的所有坐标中第 k 大的值（k 的值从 1 开始计数）。

示例 1：
```
输入：matrix = [[5,2],[1,6]], k = 1
输出：7
解释：坐标 (0,1) 的值是 5 XOR 2 = 7 ，为最大的值。
```
示例 2：
```
输入：matrix = [[5,2],[1,6]], k = 2
输出：5
解释：坐标 (0,0) 的值是 5 = 5 ，为第 2 大的值。
```
示例 3：
```
输入：matrix = [[5,2],[1,6]], k = 3
输出：4
解释：坐标 (1,0) 的值是 5 XOR 1 = 4 ，为第 3 大的值。
```
示例 4：
```
输入：matrix = [[5,2],[1,6]], k = 4
输出：0
解释：坐标 (1,1) 的值是 5 XOR 2 XOR 1 XOR 6 = 0 ，为第 4 大的值。
```

提示：
```
m == matrix.length
n == matrix[i].length
1 <= m, n <= 1000
0 <= matrix[i][j] <= 106
1 <= k <= m * n
```

### 解法 前缀和 + 堆
确定一个坐标的前缀和值，将其左上方一个个元素拿来异或显然是太费事了。
想到用前缀和，也就是DP的办法来求。

稍微观察一下后就发现，如果用`xor`表示每个坐标的题意的异或值，那么有
```python
xor[i][j] = matrix[i][j] ^ xor[i-1][j] ^ xor[i][j-1] ^ xor[i-1][j-1]
```
即，每个位置的异或值，都是上方和左方的异或完，这个过程中左上方各自的异或值因为被异或两边，归零了，所以再追加异或一次左上方的值。
最后别忘了异或`matrix`本来处于这个位置的值。

当然，以上所有坐标都得是合法范围内才行。

如此，第一版代码就得到了。
维护一个xor数组，将每个位置的异或值通过上述状态转移方程求解后填入xor矩阵。

最后，为了求第K大的，可以维护一个size不超过K的小顶堆。扫描各个异或值，若堆长小于K，直接入堆；
若堆长等于K且当前扫描到的异或值大于堆顶，则弹出堆顶后将当前值入堆。
扫描完成后堆顶就是所有异或值中第K大的了。

以上过程两个小优化点：
第一，求解所有异或值过程的xor不一定得是矩阵，由于只和上一行有关，所以可以压缩状态。
第二，求解过程中可以直接将所有异或值入堆，实时维护堆。

#### 进一步优化 结合一维、二维前缀和
上述解法的核心是异或值的推导，也就是上面那个状态转移方程。它利用了二维前缀和的特点，通过`i-1,j`,`i,j-1`,`i-1,j-1`等位置的信息求`i,j`的值。
但是，在有上一行的所有异或值的情况下，这真的是最优的解法吗？

注意到，`xor[i][j]`的定义，是包括`matrix[i][j]`在内所有左、上方元素全部异或。
那么其实，`xor[i-1][j]`就包括了这些元素的大部分，剩下的，是`matrix[i][0] ^ matrix[i][1] ^ ... ^ matrix[i][j]`。

而剩下的这个值，其实可以在扫描每一行的过程中实施维护得到。就是某一行的异或前缀和。
于是我甚至不用两个数组，可以将状态压缩至一个数组。

具体的，每开始扫描新的一行时，我有`xor`数组代表上一行的所有异或结果。
同时我维护一个`x`代表本行前缀和。开始扫描后：
```python
for j in range(n):
    x = x ^ matrix[i][j]    # 行前缀和
    xor_val = x ^ xor[j]    # 二维前缀和（也是题设的异或值）
    xor[j] = xor_val
    # 以xor_val为基准维护堆
```

通过结合行前缀和 以及 前一行的异或值，并且实时更新本行的异或值 的做法，可以进一步加快速度。并且压缩空间。

