## 题目描述
给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。

现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

示例：
```
输入：nums: [1, 1, 1, 1, 1], S: 3
输出：5
解释：

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。
```

提示：
- 数组非空，且长度不会超过 20 。
- 初始的数组的和不会超过 1000 。
- 保证返回的最终结果能被 32 位整数存下。

### 解法 带记忆的DFS
显然用DFS。
我的第一版代码是这么写的：
```python
class Solution:
    def findTargetSumWays(self, nums: List[int], S: int) -> int:
        count = [0,]
        def dfs(res: int, start: int):
            if start == len(nums):
                if res == S:
                    count[0] += 1
                return
            
            n = nums[start]
            dfs(res + n, start + 1)
            dfs(res - n, start + 1)
        
        dfs(0, 0)
        return count[0]
```
超时了。
DFS超时，改善的策略显然就是记忆化。
问题在于现在这个代码，dfs函数没有返回，记忆也不知道记忆什么东西好。

所以这里提出一个建议，dfs函数，尽量还是得有返回。
像这种统计个数的问题，虽然设置一个外部变量不断自增是一种直观的方式，但是并不是很"DFS"。

可以改变思路，另dfs函数返回整数。当探索到头时符合条件返回1，否则返回0。

这样下一层所有递归的返回加起来作为本层的返回，以这种形式写。

这样记忆化就很明确了，输入参数作为key，函数返回值作为value构建mem字典即可。

### DP（背包问题）
这题也是一个简单01背包问题。

背包问题的DP解法，其根本是构建一个二维数组。
放到这题里，数组的意义`dp[i][j]`是`nums[:i+1]`为止的所有数字可以构成和为`j`的可能数。

由于题目给出条件，数组的数字和最大不超过1000，因此可能的S在-1000到1000之间。

也正因此，dp数组第二维度的长度应该是2001。
为了适应数组部分求和为负值的情况，还需要一个小技巧，将负值转化为非负的下标。
比较简单的办法就是将所有和的可能值+1000作为下标对应。

接下来就是DP最重要的状态更新方程了。
对于DP中的某个位置`dp[i-1][j]`来说，如果其值是`count`，那么新加入`n = nums[i]`时，
会有`dp[i][j + n] += count`和`dp[i][j - n] += count`。

注意这里是+=不是=，因为可能通过其他路径已经获得了`j + n`或者`j - n`，此时其值不是0。

最终只需要取值`dp[len(nums) - 1][S]`的值即可。注意虽然题目说`nums`总和不大于1000，但是不意味着给出的参数S也在合法范围内。
所以还需要额外判断下，S是否在`-1000, 1000`之间，要不然就直接返回0。