## 题目描述
给你一个points 数组，表示 2D 平面上的一些点，其中 `points[i] = [xi, yi]` 。

连接点 `[xi, yi]` 和点 `[xj, yj]` 的费用为它们之间的 曼哈顿距离 ：`|xi - xj| + |yi - yj|` ，其中 `|val|` 表示 val 的绝对值。

请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。

示例 1：

![](https://assets.leetcode.com/uploads/2020/08/26/c.png)

```
输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
输出：20
解释：
我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。
注意到任意两个点之间只有唯一一条路径互相到达。
```
示例 2：
```
输入：points = [[3,12],[-2,5],[-4,1]]
输出：18
```
示例 3：
```
输入：points = [[0,0],[1,1],[1,0],[-1,1]]
输出：4
```
示例 4：
```
输入：points = [[-1000000,-1000000],[1000000,1000000]]
输出：4000000
```
示例 5：
```
输入：points = [[0,0]]
输出：0
```

提示：
- 1 <= points.length <= 1000
- -106 <= xi, yi <= 106
- 所有点 (xi, yi) 两两不同。

### 解法 基于并查集的Kruskal算法
这题其实就是图论的经典问题，最小生成树。

基于最小边的贪心思想的算法，是Kruskal算法。
另一种，基于DFS的算法是Prim算法。这里先介绍前者。

Kruskal算法分成下面几步。
1. 整理所有边。包括边的cost以及边的两个端点。
2. 根据边的cost从小到大排序所有边
3. 初始化无边图`G={V}`。cost从小到大扫描各个边并试图将其加入图G中。
如果这条边的两端如果在图中处于同一个连通分量中，表明已经有更小cost的边实现了其联通，因此不必加入这个边。
否则将边加入图。

前两步没有困难，第三步时，如何判断两个点是否已经在同一个连通分量中是个问题。
虽然有更加简化版的方式，但是为了方便记忆，这里借助一个外部的并查集。

按照上述算法写代码。