## 题目描述
给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。

如果子数组中所有元素都相等，则认为子数组是一个 等值子数组 。注意，空数组是 等值子数组 。

从 nums 中删除最多 k 个元素后，返回可能的最长等值子数组的长度。

子数组 是数组中一个连续且可能为空的元素序列。

示例 1：
```
输入：nums = [1,3,2,3,1,3], k = 3
输出：3
解释：最优的方案是删除下标 2 和下标 4 的元素。
删除后，nums 等于 [1, 3, 3, 3] 。
最长等值子数组从 i = 1 开始到 j = 3 结束，长度等于 3 。
可以证明无法创建更长的等值子数组。
```
示例 2：
```
输入：nums = [1,1,2,2,1,1], k = 2
输出：4
解释：最优的方案是删除下标 2 和下标 3 的元素。 
删除后，nums 等于 [1, 1, 1, 1] 。 
数组自身就是等值子数组，长度等于 4 。 
可以证明无法创建更长的等值子数组。
```

提示：
```
1 <= nums.length <= 105
1 <= nums[i] <= nums.length
0 <= k <= nums.length
```

### 解法 滑动窗口
题目意思很好理解。

这题解法的核心，是在于转变一个看问题的角度。
我们选定一个标定数 `x`（即最终等值子数组的每个值是 `x` 的情况），并设其在 `nums` 数组中的各个位置的下标为 `p0, p1, p2...`。

显然，在两个标定数之间，假设两个数的下标分别为 `pi` 和 `pj`，只要 `pj - pi` 这段长度里的非标定数小于等于`k`个，
这个片段就可以变成一个等值子数组。

这里还有一个细节，`pi`和`pj`之间可能有其他的标定数，因此还需要少减去这部分才是"非标定数的数量"。

借助上述思想，很容易想到这样的解法：
首先遍历整个数组，将每种数字的每个下标位置单独维护出来，形成一个 `defaultdict(list)`。

在此基础上，我们针对每一种可能的标定数，遍历每个 value的list。
处理每个list时，采用滑窗算法，寻找某两个标定数，使得其间所有非标定数数量小于等于`k`，并计算去除非标定数后的等值子数组片段长度。

具体的，为了计算准确的非标定数数量，我们计算 `points[r] - points[l] - (r - l)`。其中points是上述defaultdict的某个值的list，
而`l`和`r`是这个list中值的下标。

`points[r] - points[l]` 很好理解，就是算了两个标定数之间的间距。再减去 `r - l` 则是为了去除这个片段中的其他标定数。

只要上述值小于等于`k`，我们就不断拓展右边界，尽可能获取更大的区间，否则就收缩左边界。