## 题目描述
给出矩阵 matrix 和目标值 target，返回元素总和等于目标值的非空子矩阵的数量。

子矩阵 x1, y1, x2, y2 是满足 x1 <= x <= x2 且 y1 <= y <= y2 的所有单元 matrix[x][y] 的集合。

如果 (x1, y1, x2, y2) 和 (x1', y1', x2', y2') 两个子矩阵中部分坐标不同（如：x1 != x1'），那么这两个子矩阵也不同。

示例 1：

![](https://assets.leetcode.com/uploads/2020/09/02/mate1.jpg)

```
输入：matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0
输出：4
解释：四个只含 0 的 1x1 子矩阵。
```
示例 2：
```
输入：matrix = [[1,-1],[-1,1]], target = 0
输出：5
解释：两个 1x2 子矩阵，加上两个 2x1 子矩阵，再加上一个 2x2 子矩阵。
```
示例 3：
```
输入：matrix = [[904]], target = 0
输出：0
```

提示：
```
1 <= matrix.length <= 100
1 <= matrix[0].length <= 100
-1000 <= matrix[i] <= 1000
-10^8 <= target <= 10^8
```

### 解法 枚举行对套路 + 前缀和 + 哈希表
这题乍一看因为是二维的，比较复杂。
但是在很多题目比如`LC.363`，都可以通过枚举行对的套路，用乘以一个O(m^2)的代价，将二维的题目化解为一维的问题。
这题也是一样。

比如示例1中的输入
```text
0 1 0
1 1 1
0 1 0
```
列举行对，获取行对间列的总和。比如行对是`0，1`的话，就可以得到一个一维数组`1 2 1`，每列分别对应行对间相应列的数字和。

接下来，问题就变成了，在这个一维数组中，有几个和是target的连续子数组。
而这个问题也就是`LC.560`，因此直接套用那个题的做法即可。

简单来说，就是在从左到右扫描的过程中，实时维护前缀和以及前缀和数组的计数器。
新扫描到一个数字`n`时，首先更新前缀和`s += n`，而后查看`s - target`是否在计数器中出现（即计数是否大于0）。
若是，说明之前有某个位置的前缀和`s' + target = s`，自然这俩前缀和间的数组的和就是target。
若否，则说明没有符合条件的位置，将本位置的前缀和`s`维护进计数后继续遍历下一个数字。

更加详细的说明可以参考`LC.560`的题解，这里就不多说了。

一点提醒：代码虽然AC了，但是耗时并不好看。在做了一些实验之后发现，如果将计数器从`collections.Counter`换成一般的字典，就可以加速很多…
也不知道是为什么，特此提醒。