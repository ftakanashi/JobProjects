## 题目描述
给你一个下标从 0 开始的整数数组 arr 和一个 m x n 的整数 矩阵 mat 。arr 和 mat 都包含范围 [1，m * n] 内的 所有 整数。

从下标 0 开始遍历 arr 中的每个下标 i ，并将包含整数 arr[i] 的 mat 单元格涂色。

请你找出 arr 中在 mat 的某一行或某一列上都被涂色且下标最小的元素，并返回其下标 i 。

示例 1：

image explanation for example 1
![](https://assets.leetcode.com/uploads/2023/01/18/grid1.jpg)
```
输入：arr = [1,3,4,2], mat = [[1,4],[2,3]]
输出：2
解释：遍历如上图所示，arr[2] 在矩阵中的第一行或第二列上都被涂色。
```
示例 2：

image explanation for example 2
![](https://assets.leetcode.com/uploads/2023/01/18/grid2.jpg)
```
输入：arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]
输出：3
解释：遍历如上图所示，arr[3] 在矩阵中的第二列上都被涂色。
```
 

提示：
```
m == mat.length
n = mat[i].length
arr.length == m * n
1 <= m, n <= 105
1 <= m * n <= 105
1 <= arr[i], mat[r][c] <= m * n
arr 中的所有整数 互不相同
mat 中的所有整数 互不相同
```

### 解法 模拟 哈希表
本质上就是一道利用哈希表进行填表的模拟题。只要理清楚题意即可。

其实题目的意思就是给定我们一个二维矩阵 mat 。这个矩阵中填充着 0 - m*n-1 的所有数字。
然后我们按照 arr 给定的顺序依次给这些数字涂色。
直到某一次，涂色之后所涂色的这个格子所处的行或者列的所有其他格子都已经涂色，就返回这个格子在 arr 中的下标。

显然解法有很多种，我这边直接用了一个 `rows` 和 一个 `cols` 用来维护每行、每列已经涂色的格子数量。
每次涂色后查看 `rows` 以及 `cols` 对应的数字是否恰好等于`n`或者`m`。（注意这里`m`和`n`是要反过来的

是就返回，不是就继续涂色即可。