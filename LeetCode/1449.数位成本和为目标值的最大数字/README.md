## 题目描述
给你一个整数数组 cost 和一个整数 target 。请你返回满足如下规则可以得到的 最大 整数：

- 给当前结果添加一个数位（i + 1）的成本为 cost[i] （cost 数组下标从 0 开始）。
- 总成本必须恰好等于 target 。
- 添加的数位中没有数字 0 。

由于答案可能会很大，请你以字符串形式返回。

如果按照上述要求无法得到任何整数，请你返回 "0" 。

示例 1：
```
输入：cost = [4,3,2,5,6,7,2,5,5], target = 9
输出："7772"
解释：添加数位 '7' 的成本为 2 ，添加数位 '2' 的成本为 3 。所以 "7772" 的代价为 2*3+ 3*1 = 9 。 "977" 也是满足要求的数字，但 "7772" 是较大的数字。
 数字     成本
  1  ->   4
  2  ->   3
  3  ->   2
  4  ->   5
  5  ->   6
  6  ->   7
  7  ->   2
  8  ->   5
  9  ->   5
```
示例 2：
```
输入：cost = [7,6,5,5,5,6,8,7,8], target = 12
输出："85"
解释：添加数位 '8' 的成本是 7 ，添加数位 '5' 的成本是 5 。"85" 的成本为 7 + 5 = 12 。
```
示例 3：
```
输入：cost = [2,4,6,2,4,6,4,4,4], target = 5
输出："0"
解释：总成本是 target 的条件下，无法生成任何整数。
```
示例 4：
```
输入：cost = [6,10,15,40,40,40,40,40,40], target = 47
输出："32211"
```

提示：
```
cost.length == 9
1 <= cost[i] <= 5000
1 <= target <= 5000
```

### 解法 DP（完全背包问题）
先简单审个题。
这题的意思就是说，首先给出一个cost数组标明了`"1"`到`"9"`各个数字的一个cost。
然后，我们可以从中选择若干个数字拼接起来，使得其cost总和恰好是指定的target值，并且使得拼接后得到的数字是最大的。

由于候选数字没有0，所以很显然，虽然最终结果是字符串，但是没必要将其实际转化为int再进行判断。可以定义一个类似下面这个函数，用来得到两个字符串中
根据题意较大的那个：
```python
def str_max(a, b):
    if len(a) > len(b): return a
    if len(a) < len(b): return b
    return max(a, b)
```
（注意：直接比较字符串的话比较的是字典序，所以会出现`'312' < '45'`之类的情况）

在注意到上面这点之后，就可以发现，这题就是一个恰好装满的完全背包问题。
只不过最终的"价值"，从可以简单比较的数字类型数据，改成了字符串。
但是这丝毫不影响背包问题本身的解法框架，因为我们只要能判断彼此的大小就可以了。

具体的，定义DP数组:`dp[i][j]`表示前`i`个数字恰好取到成本为`j`时，能够得到的最大数字。
回顾一下恰好取满的完全背包的模板，应该是像这样的：
```python
for i in range(m + 1):
    for j in range(n + 1):
        if j - weight[i-1] >= 0 and dp[i][j - weight[i-1]] > 0:    # 恰好取满，所以追加一个条件
            dp[i][j] = max(dp[i-1][j], dp[i][j - weight[i-1]] + values[i-1])    # 完全背包
        else:
            dp[i][j] = dp[i-1][j]
```
推导过程中，由于价值从数字变成了字符串，这就导致几个比较麻烦的点。

第一，`j - cost[i-1] >= 0`时，说明我可以选择取当前数字。
一般背包问题中，需要计算取当前物品后追加的价值，即`dp[i][j - weight[i-1]] + values[i-1]`这一步。
然而本题中，这是两个字符串，这就导致了相加有谁在前谁在后，或者说这个新的字母，应该插入在前序状态的字符串的什么位置？

上面这个问题，其实仔细想想就可以解开。
由于对遍历`i`的顺序没有特别要求，因此通常是从1遍历到9的。
换言之，`dp[i][j - cost[i-1]]`这个字符串中，不可能会有比`str(i)`更大的数字存在。
此时新加这一个数字，为了保证结果尽量大，可以直接无脑将其放在最左边，即`str(i) + dp[i][j - cost[i-1]]`。

第二个问题，在恰好装满的变体背包问题中，我们需要额外的一种状态表达无法恰好装满的情况。
在价值是数字的情况中使用了-1，而这里该如何调整就是个问题了。
一般想法，是分别将空串和None对应到数字情况的0和-1。试了一下这么做也确实跑的通。大概代码如下：
```python
dp = [[None for _ in range(target + 1)] for _ in range(10)]
for i in range(10): dp[i][0] = ''    # 第一列None全改为空串
for i in range(1, 10):
    c = cost[i-1]
    ch = str(i)
    for j in range(1, target+1):
        if j - c >= 0 and dp[i][j-c] is not None:
            dp[i][j] = str_max(dp[i-1][j], ch + dp[i][j-c])
        else:
            dp[i][j] = dp[i-1][j]
```
采用这种方法时，注意`dp[i-1][j]`可以取到None，为了能比较None和任意字符串的大小（None总是更小），要修改`str_max`的定义

另一方面，其实还可以考虑这么一种做法：
初始化时仍然初始化所有状态为空串。
在`j - cost[i-1] >= 0`的时候，分成大于0和等于0两种情况。
当严格大于0并且`dp[i][j - cost[i-1]]`不为空串时 或者 上述下标等于0时，
以上情况时 取当前数字。
代码大概如下：
```python
dp = [['' for _ in range(target + 1)] for _ in range(10)]
for i in range(1, 10):
    c = cost[i-1]
    ch = str(i)
    for j in range(1, target+1):
        if (j - c > 0 and dp[i][j - c]) or j - c == 0:
            dp[i][j] = str_max(dp[i-1][j], ch + dp[i][j-c])
        else:
            dp[i][j] = dp[i-1][j]
```

最后的最后，别忘了如果`dp[-1][-1]`是空串，则别返回空串而要返回`'0'`。

按老规矩，注释里非状态压缩代码。