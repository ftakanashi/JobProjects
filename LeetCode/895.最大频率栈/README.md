## 题目描述
设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。

实现 FreqStack 类:
```
FreqStack() 构造一个空的堆栈。
void push(int val) 将一个整数 val 压入栈顶。
int pop() 删除并返回堆栈中出现频率最高的元素。
```
如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。
 

示例 1：
```
输入：
["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"],
[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]
输出：[null,null,null,null,null,null,null,5,7,5,4]
解释：
FreqStack = new FreqStack();
freqStack.push (5);//堆栈为 [5]
freqStack.push (7);//堆栈是 [5,7]
freqStack.push (5);//堆栈是 [5,7,5]
freqStack.push (7);//堆栈是 [5,7,5,7]
freqStack.push (4);//堆栈是 [5,7,5,7,4]
freqStack.push (5);//堆栈是 [5,7,5,7,4,5]
freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。
freqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。
freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。
freqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。
```

提示：
```
0 <= val <= 109
push 和 pop 的操作数不大于 2 * 104。
输入保证在调用 pop 之前堆栈中至少有一个元素。
```

### 解法 栈 哈希表
这题的解法可以说是比较奇思妙想的。

题意不难理解，第一反应是通过一个哈希表来计数，然后维护一个栈。

然而如果是这么做的话，就有两个问题。
第一，每次pop的时候如何快速地定位到当前频率最高的数字是什么。
第二，若pop的时候栈顶的数字并不是最高频率的数字，那么要如何跳过这些栈顶的数字，而把处于较低位置的数字给拿出来。

这两个虽然通过暴力都可以解，但是显然效率太低了。

这里，答案给了一个很妙的做法。
我们转换视角，为每一种出现过的频率单独维护一个栈（姑且称之为频率栈），并用哈希表把频率：频率栈的对应关系维护起来。
结合一个全局的最大频率值，和一个计数哈希表，就可以很巧妙地解开这个题目了。

在push的时候，显然计数哈希表先`+=1`，接着将最新的频率对应的栈里append上新值。同时更新最大频率值。
注意，这里不需要对对应数字原来所在的频率栈做pop或者任何删除元素的动作。

而在pop的时候，首先我们先根据最大频率值定位到对应的频率栈，pop出栈顶数字。
这个数字就是我们要给出的答案。
并且由于这个数字已经被pop，相应计数值还要`-=1`。
另外比较容易忽视的，是若最大频率值的频率栈为空了，那么就要将最大频率值`-=1`。

如此，就可以实现O(1)的push和pop操作了。

具体的，比如示例中，当前结构中已经有了`[5,7,5,7,4]`，而要新push一个5进来的时候。
频率栈当前情况是：
```python
{
    1: [5, 7, 4],
    2: [5, 7]
}
```
更新为
```python
{
    1: [5, 7, 4],
    2: [5, 7],
    3: [5,]
}
```
并且将`maxFreq`变量更新为3。

pop的时候则相应地删除`3: [5,]`中的5，并且由于栈空了，所以直接`maxFreq`更新为2（`-=1`）