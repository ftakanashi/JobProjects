## 题目描述
给你一棵二叉树的根节点 root ，返回树的 最大宽度 。

树的 最大宽度 是所有层中最大的 宽度 。

每一层的 宽度 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 null 节点，这些 null 节点也计入长度。

题目数据保证答案将会在  32 位 带符号整数范围内。

示例 1：
```
输入：root = [1,3,2,5,3,null,9]
输出：4
解释：最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9) 。
```
示例 2：
```
输入：root = [1,3,2,5,null,null,9,6,null,7]
输出：7
解释：最大宽度出现在树的第 4 层，宽度为 7 (6,null,null,null,null,null,7) 。
```
示例 3：
```
输入：root = [1,3,2,5]
输出：2
解释：最大宽度出现在树的第 2 层，宽度为 2 (3,2) 。
```

提示：
```
树中节点的数目范围是 [1, 3000]
-100 <= Node.val <= 100
```

### 解法 BFS
这题虽然一看就知道用BFS做，但是不知道是什么原因套了一下BFS模板，没发现有什么特别好的解法。

其实这题不必或者说不能套用BFS模板。
因为不论是否将null节点加入BFS队列，统计最大宽度都会是一个比较复杂的事情。

另一方面，实际上我们可以参考堆的列表实现（堆的核心是一个二叉树，但是可以用列表实现）
对一个节点，可以赋予其一个层内编号值，而其两个子节点在下一层的层内编号则是`k * 2`和`k * 2 + 1`。

出于这种考虑，实际上就会很简单了。

我们只要挨个扫描层，统计层内的编号最大差值，并且维护下一层的节点和编号即可。

值得注意的是，其实整个过程中甚至都不需要队列（因为没必要popleft），直接一个列表就能搞定。

具体看下代码，一看就明白了。