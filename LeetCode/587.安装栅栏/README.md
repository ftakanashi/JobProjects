## 题目描述
在一个二维的花园中，有一些用 (x, y) 坐标表示的树。由于安装费用十分昂贵，你的任务是先用最短的绳子围起所有的树。只有当所有的树都被绳子包围时，花园才能围好栅栏。你需要找到正好位于栅栏边界上的树的坐标。

示例 1:
```
输入: [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]
输出: [[1,1],[2,0],[4,2],[3,3],[2,4]]
解释:
```
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/erect_the_fence_1.png)

示例 2:
```
输入: [[1,2],[2,2],[4,2]]
输出: [[1,2],[2,2],[4,2]]
解释:

即使树都在一条直线上，你也需要先用绳子包围它们。
```

注意:
```
所有的树应当被围在一起。你不能剪断绳子来包围树或者把树分成一组以上。
输入的整数在 0 到 100 之间。
花园至少有一棵树。
所有树的坐标都是不同的。
输入的点没有顺序。输出顺序也没有要求。
```

### 解法 凸包 Jarvis算法
最经典的凸包问题。凸包问题也有好多种算法，有更快的可以达到O(nlogn)的，官方答案里有。
因为我还是第一次正儿八经地做凸包问题，所以一步一步来，先来看看比较容易理解但是是O(n^2)的Jarvis算法。

Jarvis算法，一句话概括，就是先找到整个凸包最靠左的一个点，然后从这个点开始逆时针地把凸包连接起来。
（当然，由于图整体没有方向，所以这里的最靠左可以改成最靠右，逆时针也可以改成顺时针）

具体怎么做呢？首先，最靠左的点很好找，就只要找到横坐标最小的点即可。
当有多个横坐标一样最小的点的话，任取其中一个即可。

接着我们开始循环。
设当前探索的点为P（最开始，即刚找到的那个最靠左的点）。循环中，我们始终保证P是凸包边缘的一个点。
然后遍历点集中其余所有点，寻找PQ，使得Q是逆时针方向凸包边缘的下一点。

而如何确定Q就是这个算法的核心所在。
具体的，我们从点集中任选一个非点P的点Q，然后用变量R遍历点集，当碰到能够让向量`P->Q`和`Q->R`的外积为负数时，就将Q更新为R。

======== 外积 ========
注意，这里我们说的是外积而不是点积。
两个向量`a`和`b`的外积记作`a x b`，而计算公式为`|a| * |b| * sin(theta)`。
由于乘以的是`sin`，所以外积是有方向性的。也就是说`a x b`和`b x a`是相反的。
从几何角度来说，`a x b`中夹角theta为从向量`a`旋转到`b`的角。当然，逆时针就是正，而顺时针就是负的了。
======== 完 ========

注意，上述遍历过程并不简单，因为Q和R两个点都是在变动的。
用语言很难说清楚，但是看下官方答案的动图，或者自己画一下就知道，这个过程有点类似于不断用更靠外的连线来取代更靠内的线。
从而，遍历完成后得到的PQ，一定是一条逆时针方向的凸包的边缘。

当得到PQ后，将Q指定为新的P点，继续遍历即可。
显然，当Q变成我们的起始点时，说明凸包已经完成，此时可以直接跳出循环返回结果。

上述算法看似OK了，但是实际上还有一些小细节需要调整。
在核心的确定P寻找合适的Q的过程中，可能会存在PQR三点共线的情况，即`PQ`和`QR`的外积为0时。
这里就有个很微妙的情况，即此时要不要把Q更新为R，反应在代码上，就是要不要取等号。

以示例1中的`(2,4), (3,3), (4,2)`三个点为例，我们分别称为x,y,z吧。
假设我们遍历到了`P`是x，`Q`是y，`R`是z，此时显然`PQ`和`QR`的外积是0，那么该不该取等号，将Q更新为R呢？

就这个例子看，似乎不该取，因为一旦取等号，那么y点实际上就被跳过，将不会被收割，虽然x和z已经形成了一条凸包的边， 但不可否认的是y点也在这条边上，按照题目要求，应当将其加入答案的。
但别忘了输入的点集的顺序是任意的。因此如果输入顺序稍作改变，很容易就会出现`P`是x，`Q`是z，`R`是y的情况。
此时如果不取等，仍然会漏掉y。

所以，在这里我们的处理办法是，不取等，但是在确定PQ后，第二遍扫描点集，将所有在PQ方向上的点也加入答案。

这样是否就完美无缺了呢？也还没有。
仍然以上面的例子为例，在将PQ确定为xy后，在扫描第二遍，将z也加入答案。
但接下来新P确定为y，而在下一轮迭代中，新Q会被确定为z。然而z已经在答案中了。
即答案列表中会有重复的点。

为了避免这一点，我们设立一个外部的哈希集。将已经被加入答案的点维护起来。
这样，只需要判断某个点是否已经在答案中，若是，那么无需将其重复加入。
（但是遍历仍要做，因为还需要将其作为跳板去寻找下条边）

以上，更多节点的注释写在代码中了。