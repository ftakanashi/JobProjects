## 题目描述
这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。

arr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。

之后再连接起来，使得连接的结果和按升序排序后的原数组相同。

我们最多能将数组分成多少块？

示例 1:
```
输入: arr = [5,4,3,2,1]
输出: 1
解释:
将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。
``` 
示例 2:
```
输入: arr = [2,1,3,4,4]
输出: 4
解释:
我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。
然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 
```
注意:
- arr的长度在[1, 2000]之间。
- arr[i]的大小在[0, 10**8]之间。

### 解法 单调栈
首先我是和`LC769`一样脑回路，用两个哈希表去维护从左到右扫描过程中原下标和排序下标的累计，当两个哈希表相同时count加一。
当然，这里排序前后下标的对应关系，还得用带下标排序一波才行。

然后看了答案有很优雅的这个单调栈解法。

和`LC769`一样，还是关注块中最大值的性质。
因为是自由的数字，所以这次最大值不一定会和下标之间有关系了。
那么退一步，最大值还有什么性质呢？
可以观察到，其实对于一个块而言，在其右边界以后所有的值都应该大于位于其中的最大值。
相反，如果后面真的出现了某个值小于其块内最大值，那么这个块就应该被扩展到那个小值，否则就不符合题意。

寻找某个值右边的比他小的值，听起来可以用单调栈。
试一下：比如`2 1 3 3 4`这个例子。
维护一个单调栈，第一步肯定`2`入栈，这里相当于我们默认`2`自成一个块，并期望其右边都比他大。

可实际上第二个元素`1`就比栈顶的`2`要小，此时先把2拿出来，然后将2之前的所有小于1的栈内元素都pop掉，说明这些块都作废了。
（实际上虽然2拿出来之后就没有元素了）
然后，再把2放回去。此时2虽然还是2，但是其意义变了，他代表的块从原来的一个2，变成了`2 1`。

依次类推，后面所有值都大于等于2，因此直接入栈，最终栈长，4，就是答案。

再来一个例子体会一下：
`5 4 6 7 3`，首先5入栈，4比5小所以将5拿出，5前所有小于4的都pop掉，5再放回。
6和7都比5大，所以直接入栈。
此时栈是5 6 7。注意到如果没有后面的3，那么答案就是3，分块就是`5 4`一组，`6`，`7`。
可惜一个3来了之后，导致前面的分块全部失效，因为3要放在最前面，所以只好重排整个数组。

此时栈的行为就是弹出7，然后栈中剩余的5和6都比3大因此都被弹出，7再放回。
此时栈只有7一个元素，而栈长1也就是答案了。