## 题目描述
给你一个 m x n 的二元矩阵 matrix ，且所有值被初始化为 0 。请你设计一个算法，随机选取一个满足 matrix[i][j] == 0 的下标 (i, j) ，并将它的值变为 1 。所有满足 matrix[i][j] == 0 的下标 (i, j) 被选取的概率应当均等。

尽量最少调用内置的随机函数，并且优化时间和空间复杂度。

实现 Solution 类：
- Solution(int m, int n) 使用二元矩阵的大小 m 和 n 初始化该对象
- int[] flip() 返回一个满足 matrix[i][j] == 0 的随机下标 [i, j] ，并将其对应格子中的值变为 1
- void reset() 将矩阵中所有的值重置为 0
 

示例：
```
输入
["Solution", "flip", "flip", "flip", "reset", "flip"]
[[3, 1], [], [], [], [], []]
输出
[null, [1, 0], [2, 0], [0, 0], null, [2, 0]]

解释
Solution solution = new Solution(3, 1);
solution.flip();  // 返回 [1, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同
solution.flip();  // 返回 [2, 0]，因为 [1,0] 已经返回过了，此时返回 [2,0] 和 [0,0] 的概率应当相同
solution.flip();  // 返回 [0, 0]，根据前面已经返回过的下标，此时只能返回 [0,0]
solution.reset(); // 所有值都重置为 0 ，并可以再次选择下标返回
solution.flip();  // 返回 [2, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同
```

提示：
```
1 <= m, n <= 104
每次调用flip 时，矩阵中至少存在一个值为 0 的格子。
最多调用 1000 次 flip 和 reset 方法。
```

### 解法 哈希表模拟swap
这题说实话有点难…

首先，显而易见的几点。
第一，不能真的在内存中创建`m*n`大小的矩阵，因为边长最大可以达到10000，一平方整个矩阵大小达到一个亿，是不现实的。
第二，因为是个规则矩阵，所以可以二维坐标转一维处理，更加方便。

而题目所谓的翻转，因为是二值化的，因此不必关心具体的0或1，只需要关心是否翻转过即可。
于是，第一个基于拒绝采样的朴素解法出来了。

我们设立一个seen用于保存那些已经被翻转过的位置（一维化的），并且调用flip的时候，随机从`range(0, m*n)`中抽取pos。
若pos未出现在seen中，那么就将其二维化后输出，并将其加入seen；
否则就拒绝采样，一直循环直到有未出现过的pos出现。

按照上面的做法，虽然可以AC，但是时间上花的有点长。
显然，拒绝采样看运气，总体上来说，当矩阵较小且已经翻转过的位置较多时，效率会很低。

有一种类似蓄水池采样的做法可以做到每次flip的时候只调用一次random相关函数，还能保证等概率采样。期大概思想如下：
比如最开始是一个`3*4`的矩阵，用`0-11`这12个数表示各个位置。
现在我在其中随机抽取一个位置，比如8，那么我将8对应的位置翻转，接着把8和11进行交换，
然后下一轮我从`0-10`中抽取。

下轮如果还是抽到8，显然不能再翻转一次8对应的位置，然而下标8和11互换过，所以此时我可以将11作为答案位置输出，即翻转11。

周而复始，我始终保持数组的前面部分是未翻转位置，后面已翻转。并且我始终只在前面的k个位置中等概率采样。
就可以做到符合题意并且尽可能少地调用random了。

按照最开始说明，真的创建数组并进行swap交换不现实，所以我们设置一个哈希表，来保存最原始下标和交换后下标的对应关系。
即按照上述例子，因为8和11位置进行了交换，就维护一个`8 -> 11`的对应关系。
当第二次随机到8的时候，因为有这个对应关系，所以实际上不输出`8//4, 8%4`而是`11//4, 11%4`。

所以，算法的思路就是，维护一个最大值bound，从0到bound间随机一个数作为初始pos。
检查pos是否在哈希表map中。
如果在，说明之前pos已经被翻转且和当时的末尾有过交换，此时就选择那个指向的位置输出。
如果不在，说明之前pos未被翻转过，则直接输出。
最后不论哪种情况，都需要将map更新，让pos指向当前末尾位置。

这里还有一个小细节，这里说的末尾位置并不一定是bound，按上面例子来说，可能有这种情况：
第一次随机到了10，翻转后map里有`10 -> 11`关系。
第二次随机到了8，翻转后，本来应该加入`8 -> 10`关系，但是因为10目前也已经被交换到了11，所以实际上应该加入的是`8 -> 11`。
这其中的逻辑稍微有点绕，建议结合代码再仔细想想…

整体的思想有点像并查集，答案中确实也有好多人用了并查集的样子。这里就不多说了…