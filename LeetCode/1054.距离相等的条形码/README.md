## 题目描述
在一个仓库里，有一排条形码，其中第 i 个条形码为 barcodes[i]。

请你重新排列这些条形码，使其中任意两个相邻的条形码不能相等。 你可以返回任何满足该要求的答案，此题保证存在答案。

示例 1：
```
输入：barcodes = [1,1,1,2,2,2]
输出：[2,1,2,1,2,1]
```
示例 2：
```
输入：barcodes = [1,1,1,1,2,2,3,3]
输出：[1,3,1,3,2,1,2,1]
```

提示：
```
1 <= barcodes.length <= 10000
1 <= barcodes[i] <= 10000
```

### 解法 贪心 哈希表
挺简单的。要求相邻的两个数字不同，显然用贪心的思想，应当优先把计数值较多的数字给间隔拜访。
当把第一轮间隔，即`range(0, n, 2)`这些下标填满之后，可以继续按照这个逻辑填充`range(1, n ,2)`。

由于题目保证肯定有答案，所以都不用想一些乱七八糟的情况，因为这个算法肯定是有效的。

具体的，可以用一个哈希表维护各个数字的计数值，然后按照计数值从大到小排列依次将各个数字填充到指定位置。