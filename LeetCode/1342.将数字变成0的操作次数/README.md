## 题目描述
给你一个非负整数 num ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。

示例 1：
```
输入：num = 14
输出：6
解释：
步骤 1) 14 是偶数，除以 2 得到 7 。
步骤 2） 7 是奇数，减 1 得到 6 。
步骤 3） 6 是偶数，除以 2 得到 3 。
步骤 4） 3 是奇数，减 1 得到 2 。
步骤 5） 2 是偶数，除以 2 得到 1 。
步骤 6） 1 是奇数，减 1 得到 0 。
```
示例 2：
```
输入：num = 8
输出：4
解释：
步骤 1） 8 是偶数，除以 2 得到 4 。
步骤 2） 4 是偶数，除以 2 得到 2 。
步骤 3） 2 是偶数，除以 2 得到 1 。
步骤 4） 1 是奇数，减 1 得到 0 。
```
示例 3：
```
输入：num = 123
输出：12
```

提示：
```
0 <= num <= 10^6
```

### 解法 位运算
这题本身不难，数据范围很小，直接暴力模拟也能做。

但是这里还是想提一下位运算的做法。

题目中提到的两种操作，减一和除以2，如果将这两者放到二进制中思考，那么很容易就发现，
奇数-1无非就是把二进制末尾的1变成0。
而除以2则是把二进制右移一位。

如此，对于任意一个输入的数，其操作的次数可以通过统计0和1的数量而直接获得。
具体的，对于每个1，由于其被移到末尾后一定会被减去1，因此要计算一次操作。
而对于0或者1变成0之后，那么就是单纯右移一位，总共的操作次数就是二进制数的长度-1。

总结起来就是，题目要求的答案等于，输入数字二进制的长度-1加上其二进制中1的个数。

官方解答中还用了很高端的技巧，将整体复杂度控制在了O(log32)。
我这边就直接线性扫描二进制表达了。