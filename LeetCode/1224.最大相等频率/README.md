## 题目描述
给你一个正整数数组 nums，请你帮忙从该数组中找出能满足下面要求的 最长 前缀，并返回该前缀的长度：

从前缀中 恰好删除一个 元素后，剩下每个数字的出现次数都相同。
如果删除这个元素后没有剩余元素存在，仍可认为每个数字都具有相同的出现次数（也就是 0 次）。

示例 1：
```
输入：nums = [2,2,1,1,5,3,3,5]
输出：7
解释：对于长度为 7 的子数组 [2,2,1,1,5,3,3]，如果我们从中删去 nums[4] = 5，就可以得到 [2,2,1,1,3,3]，里面每个数字都出现了两次。
```
示例 2：
```
输入：nums = [1,1,1,2,2,2,3,3,3,4,4,4,5]
输出：13
```

提示：
```
2 <= nums.length <= 105
1 <= nums[i] <= 105
```

### 解法 双阶哈希表计数
这题说难不难，但是说简单也不那么简单。还是有许多需要注意的细节。这里提供一个不那么高效，但是能AC的解法。

首先一个很明显的思路是从左到右扫描，然后判断截止到某个位置为止，是否符合题意要求，若是则收割ans。

问题就在于，如何判断某个位置为止，是否符合题意要求。一个比较明显的点是我们需要进行已经扫描过的值的计数。
然后这里考虑以下几个可能。

- 计数的种类有且仅有两类
- 较小的计数值等于1且只出现一次。这对应着类似于`aaabbbcccd`这样的情况，即只要去掉那个单独出现了一次的数字即可。
- 两个计数值差为1，且较大的计数值的出现次数为1。这对应着`aaabbbcccc`的情况。即去掉某个恰好多出了一个的字母，就可以了。

以上是一些基本情况，还需要考虑一些特殊case，比如全是1的数组，再比如没有任何重复的等等。
写完算法测试了一下之后，发现特殊case全是返回输入数组的长度。所以就直接在最后输出前加了个判断，倒也方便了。。

核心部分的代码则是除了一个一阶的，用于计数`num`出现频率的`counter`，
还需要有一个用于计数`counter[num]`出现次数的`count_freq`。
后者需要在扫描维护`counter`的过程中实时维护。
具体的细节参考代码和注释。