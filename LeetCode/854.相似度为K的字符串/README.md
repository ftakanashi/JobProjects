## 题目描述
对于某些非负整数 k ，如果交换 s1 中两个字母的位置恰好 k 次，能够使结果字符串等于 s2 ，则认为字符串 s1 和 s2 的 相似度为 k 。

给你两个字母异位词 s1 和 s2 ，返回 s1 和 s2 的相似度 k 的最小值。

示例 1：
```
输入：s1 = "ab", s2 = "ba"
输出：1
```
示例 2：
```
输入：s1 = "abc", s2 = "bca"
输出：2
```

提示：
```
1 <= s1.length <= 20
s2.length == s1.length
s1 和 s2  只包含集合 {'a', 'b', 'c', 'd', 'e', 'f'} 中的小写字母
s2 是 s1 的一个字母异位词
```

### 解法 BFS
题目给的数据范围不大，以为可以纯纯暴力解，没想到超时了。
然后看答案，发现这里虽然可以用BFS，但是比纯暴力还是要高级一些。

要义就是，在BFS过程中探索的所有状态，要牢牢抓住"s1向s2转换的中间状态"这个核心。

我们可以从左到右考虑所有可能的中间状态。
由于题目保证一定可以通过一定的交换次数从s1变为s2，所以所有中间状态`s`一定可以被描述为，
其前`i-1`个字符和`s2`中一样，而`s[i] != s2[i]`并且有`j in range(i+1, n)`使得`s[j] == s2[i]`。
此时我们只需要将`s[i]`和`s[j]`互换位置，然后进行下一轮搜索即可。

注意，这里的下一轮搜索可以直接从`i + 1`位置开始，因为在这个时间点上我们已经保证了前`i`个字符两头是完全一致的。

进一步提升效率，当然还可以设置一个哈希集记录已经扫描过的中间状态，避免死循环。

以上这种做法效率就高多了，比随便任意交换两个位置，暴力搜全局，加上了"中间状态"这个限制之后搜索就会快很多，因为搜索被限定在一个合理的方向。

整体上看，这题虽然是BFS的思想，但是并没有用到一些比较经典的BFS套路，比如队列（维持计算的线性结构不需要popleft，因此一般列表足矣）