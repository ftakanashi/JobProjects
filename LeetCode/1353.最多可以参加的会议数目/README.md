## 题目描述
给你一个数组 events，其中 events[i] = [startDayi, endDayi] ，表示会议 i 开始于 startDayi ，结束于 endDayi 。

你可以在满足 startDayi <= d <= endDayi 中的任意一天 d 参加会议 i 。注意，一天只能参加一个会议。

请你返回你可以参加的 最大 会议数目。

示例 1：
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/16/e1.png)
```
输入：events = [[1,2],[2,3],[3,4]]
输出：3
解释：你可以参加所有的三个会议。
安排会议的一种方案如上图。
第 1 天参加第一个会议。
第 2 天参加第二个会议。
第 3 天参加第三个会议。
```
示例 2：
```
输入：events= [[1,2],[2,3],[3,4],[1,2]]
输出：4
```
示例 3：
```
输入：events = [[1,4],[4,4],[2,2],[3,4],[1,1]]
输出：4
```
示例 4：
```
输入：events = [[1,100000]]
输出：1
```
示例 5：
```
输入：events = [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7]]
输出：7
```

提示：
- 1 <= events.length <= 10^5
- events[i].length == 2
- 1 <= events[i][0] <= events[i][1] <= 10^5

### 解法 贪心 + 堆
这题一看就知道肯定要用贪心思想来做，问题就在于贪心要怎么贪了。

我的第一直觉是，按照会议的长度排序，优先参加短的会议。
这是一种基于会议的视角，因此需要维护一个数组来表示某一天是否已经被安排了。

但随之，出现了一个问题，如果某个会议有多天可以使用，具体该选择哪天呢？
比如`[[1,3],[1,3],[1,3],[3,4]]`这组数据。
按照上面的算法描述，肯定先去参加`[3,4]`这场会，但是选择第三天去还是第四天去？

显然选择第四天去更合理，这样就不会和前三场会冲突，从而可以参加到所有会议。
但是反过来呢，比如`[[1,2],[2,4],[2,4],[2,4]]`这样的情况，又应该挑前面的第一天去参加第一场会议。

判断哪天参加某场会议可能还要判断其他会议是否在该天有安排等，感觉较为繁琐。

于是转换一个视角，我遍历每天，选择一个最应该参加的会议以此类推。这样更加自然一些。

同时，在一堆会议里我今天应该选哪个参加？
首先，要确保候选会议必须包含了今天，所以一切start比今天晚或者end比今天早的会议全都不考虑。
其次，是否还是遵循上面的标准选择最短的会议参加呢？答案是否定的。
假如今天是第五天，同时今天还剩下的可以参加的会议有`[[1,5],[5,6]]`的情况时，显然参加后一个是不合理的。

因为前一个会议今天是最后一天，如果不参加就没了。而后一个显然还有机会。

根据这种考虑，其实正确的思想就出来了。
当我们扫描到某一天的时候，应该优先选择当天还可以/需要参加的会议中，结束日期最靠前的那个。
这显然是要用堆了。

当然还有特殊情况就是会议已经结束或者还未开始。
如果某一天有多场会议今天结束，那么势必我们只能参加一场而放弃其他的，而那些被放弃的其实也都还在堆里。
所以选择会议的时候如果pop出来的会议已经结束那么直接扔掉。
另一方面，虽说还未开始的会议结束肯定在今天之后，找理由不影响堆pop出会议。
但是假如今天是第五天，而剩下的会议是`[[6,7],[7,8]]`之类的，那么显然今天没会议可参加，所以也不应该pop出东西来。

更加正确的，其实还未开始的会议根本就不应入堆。因此，会议入堆应该一天一天进行而不是最开始全整完。
在pop前还应该添加一步工序，就是将当天开始的会议入堆。
那么我怎么知道哪些会议是今天开始的呢，一个办法是事先遍历所有会议，将开始日期和会议的关系用哈希表记录下来。