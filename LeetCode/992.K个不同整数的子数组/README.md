## 题目描述

给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。

>（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）

返回 A 中好子数组的数目。

示例 1：
```
输入：A = [1,2,1,2,3], K = 2
输出：7
解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].
```
示例 2：
```
输入：A = [1,2,1,3,4], K = 3
输出：3
解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].
```

提示：
- 1 <= A.length <= 20000
- 1 <= A[i] <= A.length
- 1 <= K <= A.length

### 解法 三指针滑动窗口
因为是求子数组数目，所以可以用滑动窗口做是一目了然的。

可是初步尝试了一下，发现并没有什么好的指针移动规则。

设置一个counter维护窗口内各个数字的个数。
我最先尝试了先移动右指针让`len(counter)==K`，然后在保持`len(counter)==K`的情况下继续右移，直到大于K。
一前一后两个右指针位置相减就可以得到这个过程的总答案数。

然后再保持`len(counter) == K`的情况下让左指针右移直到小于K。这个过程也计数。

但是这样是有问题的。比如：
```text
1 2 3 1 3 2
K = 3
```
这个例子，显然左右指针在结束右指针右移过程后分别位于0和5位置。
此时左指针继续右移到3位置。

但是这个算法，`2 3 1`这个子数组是没有计入的。

被漏掉的原因，可以说对某个左边界来说，其右边界都要单独统计。
因此下面是合理的算法。
遍历每个点作为左边界。然后探索符合题目条件`len(counter) == K`的最短和最长右边界，然后相减两个右边界。
接下来，不能直接大幅度右移左边界，而是只向前一步走。（所以是遍历）

这样就不会漏掉任何子数组。
只是探索右边界的过程，其实可以从上一个左边界的情况时的最短右边界开始。因为当时最短都已经到那了，现在窗口少了一个数，因此从那开始是合理的。
这一点也是相比于暴力这个算法节省时间的出处了。

有了这个基本想法的框架之后就方便了。
接下来注意一些细节就行了。

比如其实不用遍历完所有位置作为左边界，只要遍历到`range(n - K + 1)`即可。

另外如果探索最短右边界时已经到头但是counter还是没有达到K长度，说明从当前左边界开始右边的数字总数已经没有K了，那它右边的所有数字都没必要
作为左边界继续遍历，可以直接break

按照上述方法写代码。

>上述方法是我看了答案之后收到启发自己想的算法。
>
>答案给出的算法是确定右边界然后用l1和l2两个左指针，分别确定窗口内数字种类为K的最大窗口 以及 窗口内数字种类为K-1的最大窗口。
>
>然后相减，继续遍历右边界。
>
>我的想法和答案相反，不过复杂度一致。并且实现上没用三指针。
>不过反正是我抄他的，所以这节标题写了三指针滑窗。