## 题目描述
> 注，本题也是Shopee原题，初版题解写在牛客笔试真题目录下

给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：
```
任何左括号 ( 必须有相应的右括号 )。
任何右括号 ) 必须有相应的左括号 ( 。
左括号 ( 必须在对应的右括号之前 )。
* 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。
一个空字符串也被视为有效字符串。
```
示例 1:
```
输入: "()"
输出: True
```
示例 2:
```
输入: "(*)"
输出: True
```
示例 3:
```
输入: "(*))"
输出: True
```
注意:
```
字符串大小将在 [1，100] 范围内。
```

### 解法1 DP
说用DP做，大体思路框架就出来了。用线性DP估计也能做，不过这里采用双字符串套路的DP做。

简言之，声明一个DP数组大小为`n*n`，`dp[i][j]`表示`s[i:j+1]`的合法性。然后填充对角线的初始化值，之后向右上角进行遍历，DP递推。
最后返回`dp[0][-1]`即可。

框架不难，主要难点还是在状态转移方程上。
虽说不是第一次做到这题…但是一开始还是考虑错了。

最开始，我思考的状态转移方程是这样的：首先明确，当`s[j]`是左括号时`dp[i][j]`必然是False。
另一方面，如果`s[j]`是右括号或者`*`，那么大概分三种情况。

第一，`dp[i+1][j-1] == True`并且`s[i] in '*('`。此时相当于`s[i:j+1]`是一个形如`(...)`的东西，其中`...`表示一个合法的串。

第二，`dp[i][j-2] == True`并且`s[j-1] in '*('`，此时相当于是`...()`的东西，也合法。

第三，当`s[j]`是`*`时，此时还需额外考虑`dp[i][j-1] == True`的情况，此时直接`dp[i][j] = True`。

上面的想法，体感上就觉得有些不融洽，写了代码后确实也只AC了70%左右。实在记不起来了于是看答案…

注意上面的算法，其实是没有办法正确判断如`(())(*)`这样的case的。
实际上就是说，上述第二，第三种情况还是特殊情况，更一般的，应该要遍历`for k in range(i+1, j)`，考虑`dp[i][k-1] and dp[k][j]`
的合法性。
换言之，实际上某个子串`s[i:j+1]`说不定可以分成两个更小的串`s[i:k]`和`s[k:j]`。而这俩如果都合法，那么总的串也合法。

上述第二第三种情况，分别是后面的子串`s[k:j]`长度为2和1的特殊情况，但可能有更长的情况没有考虑。

修正后代码AC。

### 解法2 计数法
若字符串中不存在`*`，只有左右括号的话，那么这题就是个类似于`LC.32`的题目。
那道题可以用计数法来做（碰到左括号计数加1，右括号-1，看最终值是否恰好为零），这题则可以延伸这种思路。

具体的，由于在扫描过程中，我们无从得知`*`的作用是左括号还是右括号还是空串，因此每扫描到一个`*`的时候，可能的计数值会出现分歧。

而诸多分歧中，必然有一个最大值和一个最小值。我们要做的，就是保证扫描完之后，最小值等于零即可。
更具体的，直接抄官方答案了：
```text
- 如果遇到左括号，则将最小值和最大值分别加1；
- 如果遇到右括号，则将最小值和最大值分别减1；
- 如果遇到星号，则将最小值减1，将最大值加1。

任何情况下，未匹配的左括号数量必须非负，因此当最大值变成负数时，说明没有左括号可以和右括号匹配，返回 False。
当最小值为0时，不应将最小值继续减少，以确保最小值非负。
遍历结束时，所有的左括号都应和右括号匹配，因此只有当最小值为0时，字符串才是有效的括号字符串。
```