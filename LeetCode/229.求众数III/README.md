## 题目描述
给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。

进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。

示例 1：
```
输入：[3,2,3]
输出：[3]
```
示例 2：
```
输入：nums = [1]
输出：[1]
```
示例 3：
```
输入：[1,1,1,3,3,2,2,2]
输出：[1,2]
```

提示：
- 1 <= nums.length <= 5 * 104
- -109 <= nums[i] <= 109

### 解法 进阶版Boyer-Moore投票算法
用哈希表counter的做法就不说了。

在`LC169.多数元素`中，我们知道了可以用Moore投票算法进行众数的抽取。

这道题同理。这主要是因为一个大前提：**符合题意的数最多只会有两个。**

因此我们维护两个众数和他们各自的`count`。
当扫描到的新数字是众数中的一个，对应`count+=1`；
如果某个count归零了，那么新数字就当做这个位置的众数并且将count置1。

比较麻烦的一点在如果新数字不是两个众数之一，且没有count为0时怎么办。
我一直在想选择哪个count减一，没想到居然是两个都减…
>这也说明了有些时候思维必须得发散，得多想想各种可能性。

至此规则已经出来了，用伪代码大概这么写：
```text
a, b, count_a, count_b = None, None, 0, 0
for n in nums:
    if n in (a, b): 对应的count += 1
    else if 0 in (count_a, count_b): 对应的数字=n且count=1
    else: count_a -= 1; count_b -= 1

return num whose count > 0
```

但是这还不算完，实际代码跑了一下之后发现比如示例`3 2 3`错了。
按照上述算法，返回的是`2,3`，但实际上只有3。

这是因为题目并没有限制可能的答案一定是两个，可能是1个或零个。

为了避免上述错误，最简单的解决办法，再针对每个结果中的数字，扫描一遍数组看其count是否真的符合要求。
由于结果最多只有两个，所以这部分后处理最多也就O(2n)。

总体的时间复杂度也就是O(n)了。