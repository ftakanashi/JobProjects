## 题目描述
给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。

你可以 任意多次交换 在 pairs 中任意一对索引处的字符。

返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。

示例 1:
>输入：s = "dcab", pairs = [[0,3],[1,2]]
>
>输出："bacd"
>
>解释： 
>
>交换 s[0] 和 s[3], s = "bcad"
>
>交换 s[1] 和 s[2], s = "bacd"

示例 2：
>输入：s = "dcab", pairs = [[0,3],[1,2],[0,2]]
>
>输出："abcd"
>
>解释：
>
>交换 s[0] 和 s[3], s = "bcad"
>
>交换 s[0] 和 s[2], s = "acbd"
>
>交换 s[1] 和 s[2], s = "abcd"

示例 3：
>输入：s = "cba", pairs = [[0,1],[1,2]]
>
>输出："abc"
>
>解释：
>
>交换 s[0] 和 s[1], s = "bca"
>
>交换 s[1] 和 s[2], s = "bac"
>
>交换 s[0] 和 s[1], s = "abc"
 

提示：
- 1 <= s.length <= 10^5
- 0 <= pairs.length <= 10^5
- 0 <= pairs[i][0], pairs[i][1] < s.length
- s 中只含有小写英文字母

### 解法1 并查集
题目看起来挺复杂，但由于题目不限操作次数，所以基本可以认为任意两个位置只要通过若干个操作可以互通，那么
这两个位置就可以做到互换。

上述命题虽然我没能严格证明，但是粗粗写了几个例子感觉都是这样。

如果确实如此，那么这题就是一个图的题目。解法也很简单，加上一点贪心思想，对于图中任意一个联通分量，其最终结果中都是最小排序即可。

比如示例1中共有两个联通分量，`0,3`的分量最小排序是`bd`，`1,2`的分量最小排序是`ac`。
然后再分别将这两者填入，得到答案`bacd`。

再比如示例2，只有一个连通分量，那么答案就是整个字符串的最小排序`abcd`。

显然，对于这种连通分量求解，并查集是一种方案。

并查集的实现在这里不多说了。

并查集构建完成后，要根据并查集的结果依次捋一捋各个分量的子串并排序再重新填回各个分量的各个位置。
这部分操作想了一会儿没找到更好的办法，一看标准答案也在这么干…