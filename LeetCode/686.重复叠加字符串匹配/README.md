## 题目描述
给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。

注意：字符串 "abc" 重复叠加 0 次是 ""，重复叠加 1 次是 "abc"，重复叠加 2 次是 "abcabc"。

示例 1：
```
输入：a = "abcd", b = "cdabcdab"
输出：3
解释：a 重复叠加三遍后为 "abcdabcdabcd", 此时 b 是其子串。
```
示例 2：
```
输入：a = "a", b = "aa"
输出：2
```
示例 3：
```
输入：a = "a", b = "a"
输出：1
```
示例 4：
```
输入：a = "abc", b = "wxyz"
输出：-1
```

提示：
```
1 <= a.length <= 104
1 <= b.length <= 104
a 和 b 由小写英文字母组成
```

### 解法 模拟
其实这道题本意是通过改造KMP算法或Rabin-Karp算法进行字符串匹配时，可以兼顾题意中的
重复N词后字符串的包含关系。

然而，KMP实在是太麻烦了…
所以这题目前我是直接借用了Python的find方法进行字符串匹配。在此基础上，在外围做了一些技巧。
虽然可以AC，但是应该认识到这样做这道题可能没什么收获…

设a和b串长度分别是la和lb，当把a串重复N遍时能包含b串，那么这个重复增广后的a串，称之为A串，长度会是多少？
换言之，N是多少呢？

考虑这个问题时发现关键在于`lb % la`这个余数。（设`lb // la`为k）
当这个余数为0，恰好整除时，那么要使得符合题意，N只能是k或者k+1。
当余数为1，则N只能是k+1。
当余数为大于等于2，则N只能是k+1或者k+2。

于是，大体的思路框架就是，我们先通过两个字符串的长度确定一种情况，确定好N的候选。
然后依次从小到大检查N的候选是不是真的符合要求即可，即`(a*N).find(b)`是否等于-1即可。

另外在进入上述算法前还可以做一些前置的判断过滤掉一些情况。
比如`la >= lb`的时候，其实只要检查`a.find(b) != -1`以及`(a*2).find(b) != -1`即可。
注意别忘了后一种情况，比如示例：
```text
aaaaaaab
ba
```
虽然`la > lb`，但是a必须重复两次才能包含b。

另外，当确定`la < lb`的时候，还可以确定一个事情就是a和b的字母成分必须完全一致，否则一定不能符合要求。
因此检查一下`set(a) != set(b)`就可以提前返回-1。

以上，就是在外围的一些优化…当然最核心的还是用了方法find，而不是自己去实现KMP了。