## 题目描述
给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

示例 1:
>输入:
>```
>[
> [ 1, 2, 3 ],
> [ 4, 5, 6 ],
> [ 7, 8, 9 ]
>]
>```
>输出: [1,2,3,6,9,8,7,4,5]

示例 2:
>输入:
>```
>[
>  [1, 2, 3, 4],
>  [5, 6, 7, 8],
>  [9,10,11,12]
>]
>```
>输出: [1,2,3,4,8,12,11,10,9,5,6,7]

### 解法1 模拟
最正常的思路。

从`[0][0]`开始往右走，碰到边界就往下，再碰到边界往左…
方向顺序是右下左上，另外还需要一个visited来记录已经访问过的元素。

顺便维护一个count看已经记录了多少个元素，当数量达标后直接结束程序即可。

### 解法2 按层扫描
这个螺旋走法有一个特点，就是可以分成几个层来处理。比如示例2的矩阵可以表示为
```text
1 1 1 1
1 2 2 1
1 1 1 1
```
每一层的遍历收割结果并不复杂。所以可以按层依次处理。

一个可能的做法是，确定当前层上下左右的边界然后扫描遍历。

处理完当前层之后，将上下左右边界各自向内收缩1，接着处理下一层。

### （2021/07/12追加）解法3 另一种按层扫描的写法
本质和上面完全一致。就是换一种写法方便记忆。

这种思路也是确定`top, bottom, left, right`四个边界。

扫描顶边自然是`range(left, right+1)`了。扫描完成后，
注意到右边的第一个元素已经入结果了，所以这里直接让`top += 1`。
这么做的另一个好处是此处可以直接检查是否`top > bottom`。
如果是，则说明当前范围内只有一行，那么下面的几个边的扫描就不用做直接break，否则会有重复数据进入结果。

同理，顶边完成后扫描右边，是`range(top, bottom+1)`。
扫描完后底边最右边元素也已经入结果，`right -= 1`。
然后检查`left > right`。

接着扫描底边`range(right, left - 1, -1)`。
`bottom -= 1`，检查`top > bottom`。

最后扫描左边的时候可能有些疑惑，看似`range(bottom, top-1, -1)`会把最开始的左上角元素给扫描进结果。
但是别忘了，执行到这里的时候，top的值已经变过，比最开始扫描的top大了。所以这里必须有减1。
最后`left += 1`，检查`left > right`。

如此，一个清晰的循环完成后，直接开始下一循环即可。