## 题目描述
给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

示例 1:
>输入: 1->2->3->4->5->NULL
>
>输出: 1->3->5->2->4->NULL

示例 2:
>输入: 2->1->3->5->6->4->7->NULL 
>
>输出: 2->3->6->7->1->5->4->NULL

说明:
- 应当保持奇数节点和偶数节点的相对顺序。
- 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。


### 解法 拆分重组
一个很直观很简单的办法。分别在第一个和第二个节点上初始化两个指针。
然后两个指针隔一个跳一个往后走。当扫描完成后，把奇数节点的子链表最后一个节点的next指向
偶数节点子链表的head即可。

唯一难度可能在于如何控制结束条件。

随便写几个奇链表和偶链表看下规律：

发现，对于奇链表会有如下情况：
```text
a -> b -> c -> d -> e -> null变成：

a -> c -> e（i） -> null(j)
b -> d -> null(j)
```

对于偶链表有如下：
```text
a -> b -> c -> d -> null变成

a -> c(i) -> d(j)
b -> d(j) -> null
```
可以看到无论哪种情况，只要把指针i的next重置到偶子链表的head，重组就完成了。