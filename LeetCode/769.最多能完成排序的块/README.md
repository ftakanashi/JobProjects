## 题目描述
数组arr是`[0, 1, ..., arr.length - 1]`的一种排列，我们将这个数组分割成几个“块”，并将这些块分别进行排序。

之后再连接起来，使得连接的结果和按升序排序后的原数组相同。

我们最多能将数组分成多少块？

示例 1:
```
输入: arr = [4,3,2,1,0]
输出: 1
解释:
将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。
```
示例 2:
```
输入: arr = [1,0,2,3,4]
输出: 4
解释:
我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。
然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。
```
注意:
- arr 的长度在 [1, 10] 之间。
- arr[i]是 [0, 1, ..., arr.length - 1]的一种排列。

### 解法1 哈希表
一道比较有意思的题目。

其实这个题目的求解过程和做span alignment很像。
任意一个区间在有序的情况下和原输入之间的对应关系，如果有min对max且max对min，那么区间min,max就是一个题目中说的"块"。

至于如何统计有几个块，就八仙过海了。
我想出来一个沙比方法是设置两个hash表，分别记录有序序列和输入序列的数字。
当扫描到某个位置时，两个哈希表相同，那么说明以这个数字结尾存在一个"块"，因此count加一。然后别忘了两个哈希表要清空。

这样的算法能AC…

### 解法2 用最值替代哈希表
以上算法，因为哈希表之间的比对操作也是O(n)的，所以整体算法变成O(n^2)。不够好。

其实，上述判断某个位置是否是输入的一个"块"的结尾，这个操作，根本没那么复杂。
对于任意一个位置`i`，其实我只要看这个位置的值是否是存在于从开头到此位置子数组中且为最大值，即`max(arr[:i+1])`是否等于`i`即可。

但如果真的代码里写`max(arr[:i+1])`的话，那还是O(n)操作，和比对哈希表没差别。

这里，其实可以用一个累计的最大值来替代这个max整个数组的操作。