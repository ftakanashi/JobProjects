## 题目描述
给你一个字符串 s，请你对 s 的子串进行检测。

每次检测，待检子串都可以表示为 queries[i] = [left, right, k]。我们可以 重新排列 子串 s[left], ..., s[right]，并从中选择 最多 k 项替换成任何小写英文字母。 

如果在上述检测过程中，子串可以变成回文形式的字符串，那么检测结果为 true，否则结果为 false。

返回答案数组 answer[]，其中 answer[i] 是第 i 个待检子串 queries[i] 的检测结果。

注意：在替换时，子串中的每个字母都必须作为 独立的 项进行计数，也就是说，如果 s[left..right] = "aaa" 且 k = 2，我们只能替换其中的两个字母。（另外，任何检测都不会修改原始字符串 s，可以认为每次检测都是独立的）

示例：
```
输入：s = "abcda", queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]
输出：[true,false,false,true,true]
解释：
queries[0] : 子串 = "d"，回文。
queries[1] : 子串 = "bc"，不是回文。
queries[2] : 子串 = "abcd"，只替换 1 个字符是变不成回文串的。
queries[3] : 子串 = "abcd"，可以变成回文的 "abba"。 也可以变成 "baab"，先重新排序变成 "bacd"，然后把 "cd" 替换为 "ab"。
queries[4] : 子串 = "abcda"，可以变成回文的 "abcba"。
```

提示：
```
1 <= s.length, queries.length <= 10^5
0 <= queries[i][0] <= queries[i][1] < s.length
0 <= queries[i][2] <= s.length
s 中只有小写英文字母
```

### 解法 异或前缀和
对于一个给出的query如`l, r, k`，首先可以确定`s[l:r+1]`之间的片段是什么。

由于构建回文串的过程中我们可以完全自由重新排列所有字母，因此可以应用贪心思想。
具体的， 对于片段中某类特定的字符，如果这个字母出现过偶数次，那么可以将其直接对称地排布在中轴两侧，从而自然形成一个回文构造。

对于奇数的，则可以将其中的一个字母替换成另一个总计数也是奇数的字母。这么一进一出，就又会有两种计数是偶数的字母了。
当然，对于奇数的情况还可以考虑将一个单独的字母放在最中心的位置，这样也可构成回文串。

这时候很容易想到前提条件是片段总长度也得是奇数，换言之还和`l`和`r`的相对关系有关。
这里其实不用思考这么多。假设总长度是偶数，某个字母的个数又是奇数的话就表明必然有另一个字母的计数也是奇数，可以适用上述替换字母逻辑。

综合来看，给出`l, r, k`之后，我们只要对`s[l:r+1]`片段中的每种字母进行计数，然后忽略其中个数为偶数的字母。
对个数为奇数的字母，总的种类数不能够超过`2 * k + 1`。只要符合这个条件，就一定可以构成回文串，反之则一定不行。

可是一看题目数据范围有点傻眼了。最大总共会有10000个query，而s长度最大也有10000，这表示如果针对每个片段都进行Counter计数，成本是很大的。

注意到，对于片段，我们其实并不关心具体的字母计数值，只关心计数值的奇偶性。
因此，这里祭出一个全新套路，当只关心某个字符串片段中字符个数的奇偶性时，可以使用 异或前缀和。

> #### 异或前缀和
> 普通前缀和已经很熟悉了。
> 而异或前缀和，顾名思义，就是将普通前缀和计算前缀和时用的加法改成异或运算即可。
> 
> 那么这种结构有什么作用呢？
> 对于一个只有小写因为字母的字符串，我们可以首先将字母转化为字母序数即`ord(ch) - ord('a')`。
> 然后扫描时计算累计异或结果。
> 显然，扫描过的片段中，如果某个字母出现次数为奇数，则对应的`1 << (ord(ch) - ord('a'))`位置是1，否则就是0。
> 而计算`presum[r+1] ^ presum[l]`就可以计算出`l, r`片段内各个字母出现次数的奇偶性了。

总结总的算法如下。

首先对`s`求异或前缀和：
```python
presum = [0, ]
for ch in s:
    val = 1 << (ord(ch) - ord('a'))
    presum.append(presum[-1] ^ val)
```

然后，针对每个query的`l, r, k`。先计算片段内字母个数的奇偶性情况：
```python
num = presum[r + 1] ^ presum[l]
```

要统计片段内出现次数是奇数的字母个数，只需要看`num`在二进制中有几个1就行了，这个就是经典套路：
```python
cnt = 0
while num > 0:
    num = num & (num - 1)
    cnt += 1
```

最后，判断`cnt`和`2 * k + 1`之间的大小关系即可。