## 题目描述
给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。

如果不存在满足条件的子数组，则返回 0 。

示例 2：
```
输入：nums = [10,1,2,4,7,2], limit = 5
输出：4 
解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 <= 5 。
```
示例 3：
```
输入：nums = [4,2,2,2,4,4,2,2], limit = 0
输出：3
```

提示：
- 1 <= nums.length <= 10^5
- 1 <= nums[i] <= 10^9
- 0 <= limit <= 10^9

### 解法 双堆 + 滑窗
思路是很明显的，滑窗并且设置一个最大堆一个最小堆，分别维护窗口内的数据。

当两个堆顶的差不到limit的时候，可以不断右移右指针。

当堆顶差超过limit的时候，需要开始移动左指针。
此时有点小问题。即某个元素`nums[l]`出窗口之后如何将其从堆中移除。

方案就是堆的延迟删除。这也是一个常见套路了。
为了做到延迟删除，通常会在堆中除了元素的值本身再维护一个标志量，当堆顶不符合标志量要求时直接
弹出堆顶。

这题里，因为左指针也是不断向右滑动的，所以可以用各个元素的下标作为标志。
当堆顶的下标小于左指针时那就直接pop。

更详细的，移动左指针的时候，如果`nums[l]`不是两个堆里任意一个的堆顶，那么这个元素就是待延迟删除的元素，直接跳过不管。
否则，就pop相应堆堆顶。同时也要pop掉所有后补上来但是标志量表明其已经失效（由于下标小于等于l，所以不再窗口内的值）的元素。

这里再多嘴说一句，使用延迟删除机制时，不能拖泥带水。
一旦要开始pop了，就直接将原本的pop条件以及延迟删除的条件一起写进一个while语句。
这样才不会夜长梦多。否则留着被延迟删除的值在堆里，说不定后面就会引起什么神奇的错误。