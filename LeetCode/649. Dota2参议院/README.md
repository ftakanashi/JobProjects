## 题目描述

Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)

Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。

他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：

- 禁止一名参议员的权利：
>参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。

- 宣布胜利：
>如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。

 

给定一个字符串代表每个参议员的阵营。

字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。

以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。

这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。

假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。

输出应该是 Radiant 或 Dire。

 

示例 1：
>输入："RD"
>
>输出："Radiant"
>
>解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人

示例 2：
>输入："RDD"
>
>输出："Dire"
>
>解释：
>
>第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利
>
>第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止
>
>第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利
>
>因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利
 

提示：
- 给定字符串的长度在 [1, 10,000] 之间.

### 审题
题干一大堆。精简一下。

给出一个只含有R或者D的字符串代表一些议员。从左到右扫描。

扫描到每一个议员时，他可以禁言任意一个议员。被禁言的议员轮到他时就无法使用禁言别人的能力。

如果扫描到头时没被禁言的议员不属于同一个党派，那么就继续从头开始扫描。

直到某一天，没被禁言的隶属于同一个党派，此时宣布该党派胜利。

### 策略
直觉上来说，显然，某个议员的最佳策略是禁言排在他后面的第一个异党。
如果他身后已经没有异党了，那么为了下一轮的利益考虑，就去禁言从左边开始的第一个异党。

总的来说就是要禁言"我"之后第一个能投票的异党。如果禁言的是那之后的异党，那么无论如何第一个能投票的异党，他就能禁言一个我方队友了。

虽然没有严格证明，但是这就是一个简单的贪心思想。

### 解法1 计数法模拟
最简单的模拟，就是比如扫描到一个R之后，找到其之后的第一个D，然后将其剔除出序列。

但是变化的序列不方便扫描进行，所以考虑建立一个"新序列"用于下一轮，那些被剔除的不加入新序列即可。

另一方面，扫描本身是O(n)的，而寻找下一个异党如果使用简单的再加一层循环，那要O(n^2)。
关键就在于如何优化"寻找下一个异党"的过程。

我想过用双指针分别指向第一个还可以发言的R和D；或者维护一个额外的valid列表来说明当前序列中还可以发言的人。
不过都不太好使。比如没办法做到传递两轮之间的关系。

于是瞄了一眼答案。。

答案大体有两种优化的方案。计数法和用双队列。这里先说技术法。

由于被禁言的是尽量靠前的人。所以例如扫描到一个R之后，我知道要禁言一个D，但是没必要找出来，只要计数上一个我要禁言D的变量+=1。

这样继续往下扫描，一旦碰到的D，那这自然就是我要找的那个D。直接跳过他的处理，并且让上述变量-=1即可。

另一方面，保持跨轮时这个变量不重置，那么上一轮末尾那些R的动作仍然有效，可以用来禁言本轮开始的那些D。

这样一来，只要一个指针不断地从头到尾扫描，就可以完成整个工作。

**这种，在贪心的前提下，不必找出具体对象而只是记上一笔，直到扫描到符合要求对象再减去一笔的思想还是挺有意思的。**

### 解法2 双队列
待补充。。。