## 题目描述
给定一个排序的整数数组 nums ，其中元素的范围在 闭区间 [lower, upper] 当中，返回不包含在数组中的缺失区间。

示例：
```
输入: nums = [0, 1, 3, 50, 75], lower = 0 和 upper = 99,
输出: ["2", "4->49", "51->74", "76->99"]
```

### 解法 双指针
最无脑的解法，当然就是`for i in range(lower, upper+1)`扫描然后做了。
当然，如果`nums`很稀疏，那么这么遍历会浪费很多计算。

所以这里用双指针来做。
具体来说，设置一个数字指针`i`以及一个位置指针`p`。
数字指针用于表示尚未扫描过的区间的最左边是多少。显然初始化为lower。
位置指针指向`nums`中的某个位置。显然初始化为0。

接着，进行这样的计算：
判断当前`i`是否小于`nums[p]`，

若是，说明尚有一段区间没有被扫描，因此将`i->nums[p]-1`这段区间加入答案，
接着`i = nums[p] + 1; p += 1`。

若否，其实根据上面的递推逻辑，此时只可能`i == nums[p]`。
当然即便不思考这么细，直接`i = nums[p] + 1; p += 1`往下递推即可。

如此，遍历的跳出条件应当是`p < len(nums)`，然而若`nums[-1] < upper`，则此时无法获取最后一段区间。
所以可以在最开始，append一个upper + 1当做特殊情况处理。
除此之外还有空数组之类的特殊情况处理等等。