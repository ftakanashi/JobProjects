## 题目描述
给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。

请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1 。

子数组 定义为原数组中连续的一组元素。

示例 1：
```
输入：nums = [3,1,4,2], p = 6
输出：1
解释：nums 中元素和为 10，不能被 p 整除。我们可以移除子数组 [4] ，剩余元素的和为 6 。
```
示例 2：
```
输入：nums = [6,3,5,2], p = 9
输出：2
解释：我们无法移除任何一个元素使得和被 9 整除，最优方案是移除子数组 [5,2] ，剩余元素为 [6,3]，和为 9 。
```
示例 3：
```
输入：nums = [1,2,3], p = 3
输出：0
解释：和恰好为 6 ，已经能被 3 整除了。所以我们不需要移除任何元素。
```
示例  4：
```
输入：nums = [1,2,3], p = 7
输出：-1
解释：没有任何方案使得移除子数组后剩余元素的和被 7 整除。
```
示例 5：
```
输入：nums = [1000000000,1000000000,1000000000], p = 3
输出：0
```

提示：
```
1 <= nums.length <= 105
1 <= nums[i] <= 109
1 <= p <= 109
```

### 解法 前缀和 哈希表
题意不难理解。
并且因为涉及到了子数组，所以很容易想到要构建前缀和。

第一层比较容易想到的，要让最终剩余数组的和能够被P整除，那么其实反过来也是要求了被去除的子数组的和，对P取余的余数等于`sum(nums) % p`。
由于这是一个定值，不妨设其为`x`。

换句话说，假设我们现在已经构建了前缀和数组`presum`。
此时我们就要找的，是`i > j`，满足`presum[i] - presum[j]`对`p`取余等于`x`，并且`i - j`最小。

这个问题看起来似乎还是很难以非朴素的方式去做。
这里就要引出第二层逻辑，`(presum[i] - presum[j]) % p = x`等价于`presum[j] % p = (presum[i] - x) % p`。
这个等价符号的证明可以看官方答案。

在有这个结论之后，就简单多了。
遍历`presum`数组，碰到`presum[i]`时，由于`x`是定值，所以上面式子等号右边是好算的。
而左边呢，由于`j`始终是小于`i`的，所以`presum[j] % p`在之前的遍历中其实也是可以求出来的。
为了能记录这个结果，我们这里就用一个哈希表保存这部分信息。

哈希表保存的，是前缀和中每个`presum[j] % p -> j`的映射。

由于遍历是从左到右进行的，所以如果是采取把所有前缀和都预处理出来再遍历计算的话，定位`i`之前的`j`且`presum[j] % p`为指定值比较麻烦。
所以不如把遍历和前缀和计算以及哈希表的维护都在一个循环中进行。
这样可以保证遍历到`i`时，哈希表中所有信息都是`i`左边的，找起`j`来方便多了。

另外注意题目要求最小的子数组，所以如果有相同的余数值时，应当取最靠右的，也就是说哈希表要update而不是不变。

以上。更多细节请看代码。