## 题目描述

给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。

返回 s 所有可能的分割方案。

示例:
```
输入: "aab"
输出:
[
  ["aa","b"],
  ["a","a","b"]
]
```

### 解法1 带记忆的回溯（DFS）
很典型的用回溯法的题目。
最朴素的想法自然是dfs函数指定开始位置，然后`for end in range(start, n)`寻找当前限定下的某个子串。
如果`subs = s[start:end+1]`是个回文串，就进行递归+回溯如下：
```python
res.append(subs)
dfs(end+1, res)
res.pop()
```

显然朴素的想法中存在大量重复计算。
一般这种情况下通常套路都是通过一个缓存记忆dfs的结果，这样第二次碰到同样参数的dfs函数运算时可以直接取记忆化结果而不用重复计算。

但是这道题因为求的不是分类总数，而且dfs参数中还带有部分结果的列表，不太方便直接用mem进行缓存读写。

这里需要稍稍跳出固有思维，注意到dfs函数的for循环中真正花时间的，是判断某个子串是不是回文串的部分。而针对判断是不是回文串这个过程做个缓存并
不困难。

按照上述思路写代码即可。

### 解法2 利用functools.cache进行记忆化函数的定义
思路和解法1完全一致。

只是在以往的记忆化DFS中，我都是用一个`mem = {}`来进行缓存。
虽然思路不复杂，函数体内先检查输入是否在mem中，如果有直接返回，没有则进行计算并将输入和计算结果以键值对形式保存在mem中。
但是终归比较麻烦。

其实Python的`functools`模块中有`cache`这个装饰器，自动实现了上述功能。
在这个装饰器下定义的函数，我们只需要专注于当某些输入还没出现在缓存时计算的流程，
对于已经出现在缓存中的输入，他会自动返回已经缓存的计算结果。
>在Python3.8以及之前的版本中，这个装饰器被称为 functools.lru_cache 。

解法2的代码改动了`isPalin`函数的实现，利用这个cache装饰器实现了缓存机制。
