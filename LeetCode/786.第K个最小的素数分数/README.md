## 题目描述
给你一个按递增顺序排序的数组 arr 和一个整数 k 。数组 arr 由 1 和若干 素数  组成，且其中所有整数互不相同。

对于每对满足 `0 < i < j < arr.length` 的 i 和 j ，可以得到分数 `arr[i] / arr[j]`。

那么第 k 个最小的分数是多少呢?  以长度为 2 的整数数组返回你的答案, 这里 `answer[0] == arr[i]` 且 `answer[1] == arr[j]` 。

示例 1：
```
输入：arr = [1,2,3,5], k = 3
输出：[2,5]
解释：已构造好的分数,排序后如下所示: 
1/5, 1/3, 2/5, 1/2, 3/5, 2/3
很明显第三个最小的分数是 2/5
```
示例 2：
```
输入：arr = [1,7], k = 1
输出：[1,7]
```

提示：
```
2 <= arr.length <= 1000
1 <= arr[i] <= 3 * 104
arr[0] == 1
arr[i] 是一个 素数 ，i > 0
arr 中的所有数字 互不相同 ，且按 严格递增 排序
1 <= k <= arr.length * (arr.length - 1) / 2
```

### 解法 堆
首先先说明，这道题的数据限制并不太苛刻，因为arr最大长度也就1000。
因此一个冲击事实就是，即使将所有分数都算出来放到一个列表里然后排序列表取第k位，也就是暴力，也能AC…

接下来说明解法。
看到第K小，第一个就想到了堆。但是没法直接沿用那种用堆求第k大数据的直接思路，因为用于排序的分数并未直接提供。如果要将这些分数全算出来，那又要O(n^2)了。
观察数据后不难发现，最小的分数总是`1/arr[-1]`。而第二小的，会在`1/arr[-2]`和`arr[1]/arr[-1]`中选择。
第三小的则是`1/arr[-3], arr[1]/arr[-2], arr[2]/arr[-1]`以及第二小中被淘汰的那个数中选择。

从这番观察中，可以察觉到一个事实，当分母固定时，最小的总是`1/n`。
所以，即便不计算出所有分数，也可以将所有分数按照分母进行分类，并且每个分类都可以有序地排列。

于是这道题就变成了一个隐式的，合并K个有序链表的题目。
而这个题是可以用堆做的。

具体来说，我们初始化堆为`1/arr[i]`。并且从堆中pop出k-1次堆顶。
最开始pop出的肯定是`1/arr[-1]`，pop出之后，就将`arr[1]/arr[-1]`入堆。
因为堆会维持堆序，所以自动就可以决策出当前最小值。pop了k-1次之后的堆顶，就是所求值了。

这里还有一个细节，就是有可能前一个pop出来的`arr[i]/arr[j]`中`i == j-1`，此时说明以`arr[j]`为分母的分数已经全部扫描过了，此时就可以无需入堆新东西。

另外，因为返回的要求是`arr[i], arr[j]`而不是`arr[i]/arr[j]`，因此堆中还需要有分子分母分别是多少的信息。
好在题目保证了元素无重复且都是素数（说明没有`arr[i]/arr[j]`会相同），因此堆的元素可以这样设计：
```python
(arr[i]/arr[j], arr[i], arr[j], i, j)
```
其中第一个就是用来当做排序依据的分数，接着是分子分母各自是多少，而最后则是两者的下标，用于进行上述`i == j-1`的判断。

根据官方题解，这道题也可以通过threshold二分的方式来做，今天没啥时间了，就不多说了。