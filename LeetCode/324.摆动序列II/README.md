## 题目描述
给你一个整数数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。

你可以假设所有输入数组都可以得到满足题目要求的结果。

示例 1：
```
输入：nums = [1,5,1,1,6,4]
输出：[1,6,1,5,1,4]
解释：[1,4,1,5,1,6] 同样是符合题目要求的结果，可以被判题程序接受。
```
示例 2：
```
输入：nums = [1,3,2,2,3,1]
输出：[2,3,1,3,1,2]
```

提示：
```
1 <= nums.length <= 5 * 104
0 <= nums[i] <= 5000
题目数据保证，对于给定的输入 nums ，总能产生满足题目要求的结果
```

进阶：你能用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？

### 解法 排序模拟
首先声明，这个解法是暴力解法…完全无视进阶要求。

既然要构造一个 一小一大一小一大 样子的数组，那么只要保证选取放在小的位置上的数字尽量小，放在大的位置的数字尽量大，就很稳妥。

在这个总思想的指导下，先对原数组进行一次排序。
接着一个很自然的思路就是，设置两个指针，一个`i`从头开始，一个`j`从尾开始扫描，逐渐填充。

不过尝试了之后发现有问题。比如`[4,5,5,6]`这样一个case，发现最终排出的数组是`4,6,5,5`，最后两个5不符合要求。

于是看答案，一个更合理的做法是`i`从中间`j`从尾巴开始，两个指针都向前扫描。
这样可以保证答案尽可能地合理正确。（当然前提是题目保证了，确实存在符合要求的结果。