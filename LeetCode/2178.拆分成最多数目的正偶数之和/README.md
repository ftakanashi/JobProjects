## 题目描述
给你一个整数 finalSum 。请你将它拆分成若干个 互不相同 的正偶数之和，且拆分出来的正偶数数目 最多 。

比方说，给你 finalSum = 12 ，那么这些拆分是 符合要求 的（互不相同的正偶数且和为 finalSum）：(2 + 10) ，(2 + 4 + 6) 和 (4 + 8) 。它们中，(2 + 4 + 6) 包含最多数目的整数。注意 finalSum 不能拆分成 (2 + 2 + 4 + 4) ，因为拆分出来的整数必须互不相同。
请你返回一个整数数组，表示将整数拆分成 最多 数目的正偶数数组。如果没有办法将 finalSum 进行拆分，请你返回一个 空 数组。你可以按 任意 顺序返回这些整数。

示例 1：
```
输入：finalSum = 12
输出：[2,4,6]
解释：以下是一些符合要求的拆分：(2 + 10)，(2 + 4 + 6) 和 (4 + 8) 。
(2 + 4 + 6) 为最多数目的整数，数目为 3 ，所以我们返回 [2,4,6] 。
[2,6,4] ，[6,2,4] 等等也都是可行的解。
```
示例 2：
```
输入：finalSum = 7
输出：[]
解释：没有办法将 finalSum 进行拆分。
所以返回空数组。
```
示例 3：
```
输入：finalSum = 28
输出：[6,8,2,12]
解释：以下是一些符合要求的拆分：(2 + 26)，(6 + 8 + 2 + 12) 和 (4 + 24) 。
(6 + 8 + 2 + 12) 有最多数目的整数，数目为 4 ，所以我们返回 [6,8,2,12] 。
[10,2,4,12] ，[6,2,4,16] 等等也都是可行的解。
```

提示：
```
1 <= finalSum <= 10^10
```

### 解法 贪心
这道题基于这样的一个贪心思路：
直觉上，既然要最终数量尽量多，显然应该尽可能用上小的数字如`2 4 6 8 ...`。所以我们优先从小的偶数开始考虑加和。

然而你会发现，对于任意的`finalSum`，似乎在加和到一定量的数字之后，一定会发生，剩余需要加上去的部分，无法再被拆分成两个从未出现过的偶数的和。
可以证明，这个"剩余的量"，一定是出现在余量小于等于最后一个加和过的偶数时发生。

比如示例3中的28，我们可以加`2 + 4 + 6 + 8`，此时剩余`8`，而这个`8`无法拆成更小的了。
只有当`finalSum`大于等于30时，才可能选取下一个偶数10。

此时还可以多想一想，是否有可能放弃使用一些小数字，转用一些大数字呢。其实是不可能的。
比如放弃用2，那么我们可以多用一个10，从而变成`4 + 6 + 8 + 10`，但是选用数字总数不变。
事实上，总数只会不变或者更小，因为总和上限是固定的，选用更大的数字必然意味着选用数字数量的减少。

于是算法就比较清晰了。
我们可以从小到大遍历所有偶数，并尝试将他们加和。并将这部分和从`finalSum`中扣除。
此时剩余部分如果比当前遍历到的偶数更大，那么继续遍历。
否则，就停止遍历，并将剩余部分加到已经存在的那个等差数列的某个数上。
由于要求最终答案中没有重复数字，所以保险的方法是加到最后一个最大的偶数上去。

这样就可以凑出一个符合要求的答案了。


更进一步的思考一下。
以上遍历过程中，我们维护的其实是一个从`2`开始的差为`2`的等差数列。而这个等差数列和的规律其实是`n * (n+1)`，`n`为项数。
这些数就是整个自然数数列上的"节点值"。

换句话说，任意一个`finalSum`，其实可以表示为`n * (n+1) + x`的形式，其中`x`也是一个偶数且小于等于数列中的最大值`2*n`。

如果这题要求的不是某个具体的数列，而是最终`finalSum`最多可以拆成多少个偶数的和的话， 那么不用具体遍历数字，
直接一个二分查找找到最接近的`n`，就可以了。