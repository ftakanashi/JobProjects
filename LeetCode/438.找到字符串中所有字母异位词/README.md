## 题目描述
给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。

示例 1:
```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```
示例 2:
```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

提示:
```
1 <= s.length, p.length <= 3 * 104
s 和 p 仅包含小写字母
```

### 解法1 哈希表 + 滑窗
说是滑窗，其实只是借用了这个形式。

很简单，单纯地从左到右用一个`len(p)`长度的窗口扫描。
当窗口内的字母计数情况和p中一致，就将左端点加入答案，否则就继续向右扫描。

加入一个优化点，当某次向右移动时新来的字母并不存在于p中，此时可以直接将扫描位置定位在这个字母的右边，从而节省一定时间。

### 解法2 解法1优化 只计数不同字母的数量
解法1中，每次都要针对两个哈希表进行判相等操作，这个过程是线性的。
实际上，因为我们只关心哈希表是否相等而不关心具体内容，所以在扫描过程中，可以维护s中窗口内字母情况与p字母情况的差分，
并且通过这个差分进行差分数量的计数，对于有差分计数为0时就可以收割进结果。

具体的，我们设置一个diff哈希表，用来保存当前窗口中每个字母的差分情况。
即比如`a: 1`，表示当前s中窗口中的字母a比p中字母a多一个；相反如果值是负数，就是少。
当diff中的所有值都是0的时候说明窗口是p的字母异位词。否则不是。

当然，如果每次都检查diff的所有值是否是0，那么和解法1并无本质区别。
这里我们事先设置一个`diff_cnt`，用来在扫描过程中实时维护值不为0的键值对数量。