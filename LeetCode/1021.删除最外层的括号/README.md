## 题目描述
有效括号字符串为空 ""、"(" + A + ")" 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。

例如，""，"()"，"(())()" 和 "(()(()))" 都是有效的括号字符串。
如果有效字符串 s 非空，且不存在将其拆分为 s = A + B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。

给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。

对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 s 。

示例 1：
```
输入：s = "(()())(())"
输出："()()()"
解释：
输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，
删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。
```
示例 2：
```
输入：s = "(()())(())(()(()))"
输出："()()()()(())"
解释：
输入字符串为 "(()())(())(()(()))"，原语化分解得到 "(()())" + "(())" + "(()(()))"，
删除每个部分中的最外层括号后得到 "()()" + "()" + "()(())" = "()()()()(())"。
```
示例 3：
```
输入：s = "()()"
输出：""
解释：
输入字符串为 "()()"，原语化分解得到 "()" + "()"，
删除每个部分中的最外层括号后得到 "" + "" = ""。
```

提示：
```
1 <= s.length <= 105
s[i] 为 '(' 或 ')'
s 是一个有效括号字符串
```

### 解法 栈
稍微解释一下题意。 就是给你一串合法的嵌套括号串。
这个字符串可能包含了多个并列的一级子括号。答案要求给出去掉这些一级子括号的情况。
比如`(xxx)(yyy)(zzz)`就要求给出答案是`xxxyyyzzz`。
至于`xxx, yyy, zzz`分别是什么不关心，他们都是合法的嵌套括号串。

看到括号下意识的知道用栈。
但其实题的本意更加简单。

用栈遍历字符串，碰到左括号入栈，右括号pop，于是每遍历完一个一级子括号单元后，栈会空。
因此可以遍历开始和当前时间点分别记录两个下标，两个下标之间的就是一个一级子括号单元，去掉start和end，自然就是要求的东西了。

怎么说呢，如果执着与遍历时将每个字符遍历出来后放到某个缓存里，然后用缓存拼凑答案也可以，
但是不如以记录下标，然后用下标二次访问s的片段来的方便快捷。