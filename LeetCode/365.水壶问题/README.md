## 题目描述

有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？

如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。

你允许：
- 装满任意一个水壶
- 清空任意一个水壶
- 从一个水壶向另外一个水壶倒水，直到装满或者倒空

示例 1: (From the famous "Die Hard" example)
```
输入: x = 3, y = 5, z = 4
输出: True
```
示例 2:
```
输入: x = 2, y = 6, z = 5
输出: False
```

### 解法1 DFS
这道题看起来没有什么计算机味道比较浓的办法来做，很难搞。

这种时候，往往需要暴力，比如DFS之类的办法。
具体的，dfs函数很显然是当前两个壶中保有水的量。

针对任意一个状态，其实我可以做的操作只包括如下这些：
```text
将x壶灌满
将y壶灌满
将x壶倒空
将y壶倒空
将x壶中的水倒入y壶
将y壶中的水倒入x壶
```
将以上操作视为路径，两个壶的各自保有水量`a,b`作为节点，对这个图进行dfs搜索即可。

边界条件，显然当某个壶的容量不在合法范围`（0 <= a,b <= x,y）`，就无需继续探索；
另一方面，当`a == z or b == z or a + b == z`时则可直接返回True。

另外，上面提到的六种路径，前四种比较好处理。后两种还需要考虑某个壶剩余的空间与另一壶保有水量之间的大小关系。
比如将x壶水倒入y的情况，如果此时`y - b >= a`，说明x壶的水全倒光也无法填满y壶，此时状态会变成`0, a+b`；
另一方面，如果`y - b < a`，则y壶被到满后x壶仍有剩余，此时状态是`a - y + b, y`。

按照以上思路写dfs即可。

这里还需要注意，单纯dfs会将所有可能的`a,b`组合全尝试一遍，时间复杂度是O(xy)的。
实际尝试后发现超过了Python对递归层数的限制。
因此这题需要自己手动维护一个栈，来模拟dfs过程。

### 解法2 数学
>参考 https://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/ 的方法2

上面有DFS方法，虽说有种这特么也能dfs的味道，但是终究还是比较复杂。
其实这种题一看就知道肯定有巧妙的数学方法。

将两个壶中的水看做一个总体，根据题目，只要这个总体量能够到达z，就可以返回True。
而所有的加水倒水互相倒的操作，每一次操作对于整体的影响实际上就是 增加或者减少 x或者y 的水量。

>注意，当某一个壶水处于不满的状态时，将其加满或者倒掉时发生的水量变化固然不是整的x或者y。
>
>但是需要意识到，这样的操作是没有意义的。因为在这个题目中，中途半端的那些水量才是"精华"所在，是难得到的。
>
>如果你选择将中途半端的水量给加满或者倒掉，相当于把这些难得到的回归成容易得到的"整数"了。

在有以上认识之后，问题就可以抽象成，能否找到整数`m, n`使得如下等式成立：
```text
mx + ny = z
```
其中，`m, n`分别标识增加水量x和增加水量y的次数，如果其是负数，则表示减少水量。

分析到这里，如果直接写代码做，还是dfs，只不过因为建模，思路会清晰很多。
然而，这里其实可以用到一个叫做"贝祖定理"的数学定理。

具体的不说了，仅需记住结论，当上面的`m, n`有整数解的时候，当且仅当`z`是`x,y`最大公约数的整数倍。
所以这题可以在O(log( min(x, y) ))的时间内找到答案。这个时间复杂度是求最大公约数的算法的复杂度。

求最大公约数可以用`math.gcd`这个库函数。