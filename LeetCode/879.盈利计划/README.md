## 题目描述

集团里有 n 名员工，他们可以完成各种各样的工作创造利润。

第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。

工作的任何至少产生 minProfit 利润的子集称为 盈利计划 。并且工作的成员总数最多为 n 。

有多少种计划可以选择？因为答案很大，所以 返回结果模 10^9 + 7 的值。

示例 1：
```
输入：n = 5, minProfit = 3, group = [2,2], profit = [2,3]
输出：2
解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。
总的来说，有两种计划。
```
示例 2：
```
输入：n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]
输出：7
解释：至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。
有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。
```

提示：
```
1 <= n <= 100
0 <= minProfit <= 100
1 <= group.length <= 100
1 <= group[i] <= 100
profit.length == group.length
0 <= profit[i] <= 100
```

### 解法 DP（01背包问题）
一看就知道这是一个 求方案数的01背包问题。
将每个任务看做一个物品。则n是背包的重量上限，group是各个物品的重量，profit则是各个物品的价值。
只是麻烦的是，还设定了一个`minProfit`作为下限。即只有最终价值大于给定下限的方案才算有效的方案数。

暂且不管下限的事，求方案数的01背包问题，一般需要定义`dp[i][j]`为前`i`个物品恰好装满容量是`j`背包时的方案数。

现在多引入了一个下限之后，通常最好别考虑在DP数组推导的体系外进行下限的处理和判断。
相反的，应该尽量选择将其并入DP的推导过程（就像`LC.1473`和它相关的更简单的题目之间的关系那样）。

这道题，我们多定义一个维度`k`，使`dp[i][j][k]`表示：前`i`个物品恰好装满`j`容量时，其总价值至少达到`k`的方案数。
显然，第三个维度的长度应该是`minProfit + 1`。

根据求方案数的背包问题的套路，首先关注到初始化`dp[0][0][0] = 1`。
接着开始扫描填充DP数组。

关键在于状态转移方程。按照一般的背包问题思路来思考，
对于扫描到的第`i`个任务，首先，如果其重量`group[i-1]`大于当前的容量上限`j`，那么这个任务不能选，因此有
`dp[i][j][k] = dp[i-1][j][k]`。

另一方面，如果`j - group[i-1] >= 0`，则说明，我们决定取第`i`个任务时，前面已经有了合法的情况，我们需要将这部分情况的方案数也加上。
那么前面合法情况的方案数是多少呢。

观察`dp[i][j]`，这是一个长度为`minProfit + 1`的数组。
针对其中任意一个值，在取第`i`个任务后，由于总价值增加了`profit[i-1]`，
为了满足 "至少总价值达到k" 的要求，前序的要求可以放宽到`k - profit[i-1]`。
当然因为这里要求的是"至少"，所以`k - profit[i-1]`可能会是负数，此时不应该取负数而取最小的`0`。

换言之，当`j - group[i-1] >= 0`时，状态转移方程应该如下所示：
```python
dp[i][j][k] = dp[i-1][j][k] \    # 不取第i个任务的情况
+ dp[i-1][j - group[i-1]][max(0, k - profit[i-1])]    # 取第i个任务的情况
```

至此，最核心的问题已经解决了。
剩下的无非就是要注意大数对`10**9 + 7`的取余，以及最终DP数组全填完之后，
因为第二个维度定义是 "容量恰好为`j`时"，而题意的`n`其实是只要不超过`n`就行，所以应该将这个维度给聚合起来。
即答案应该是`sum(dp[-1][j][-1] for j in range(n+1))`。

这道题，基本框架是 求方案数的01背包 。
但是由于引入了下限，导致DP数组的定义以及转移方程需要进行相应的调整。
这个调整的过程还是比较难想的（尤其是要顾及第三维度）。
总体来说，挺难的。