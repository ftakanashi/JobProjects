## 题目描述

给你一个数组 routes ，表示一系列公交线路，其中每个 routes[i] 表示一条公交线路，第 i 辆公交车将会在上面循环行驶。

例如，路线 routes[0] = [1, 5, 7] 表示第 0 辆公交车会一直按序列 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... 这样的车站路线行驶。
现在从 source 车站出发（初始时不在公交车上），要前往 target 车站。 期间仅可乘坐公交车。

求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 -1 。

示例 1：
```
输入：routes = [[1,2,7],[3,6,7]], source = 1, target = 6
输出：2
解释：最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。 
```
示例 2：
```
输入：routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12
输出：-1
```

提示：
```
1 <= routes.length <= 500.
1 <= routes[i].length <= 105
routes[i] 中的所有值 互不相同
sum(routes[i].length) <= 105
0 <= routes[i][j] < 106
0 <= source, target < 106
```

### 解法 BFS
乍一看以为要用并查集。
但是并查集中如何将"不同线路"这个信息维护进去比较困难。

看了答案才直呼np。
原来是用一般的图即可。而且巧妙的地方在于，并不是将各个公交站作为节点，而是将各个公交路线作为节点。
若两条线路中间有交集，则表示两个节点之间有一条边。

有了这个图之后，就可以发现，这题其实就是一个求图中最短路径的问题。
只不过根据题目进行图遍历时的"出发点"和"结束点"不是单一，而各是一个集合。

采用BFS来做这道题。注意上面构建的图中，并没有边的权重。
不过这题本身要求的也只是"乘坐的公交线路数量"，所以可以默认每条边权重是1，统计最终结果即可。

也因为累计cost就是向外移动的层数，因此cost是稳固增长的。
因此，原本BFS探索最短路径时需要的优先队列在这里可以换成普通队列，因为后入队的节点，总是更远的节点。

#### 2021/06/28追加笔记
最近几天的题目一直是BFS，做出点心得来了。上次第一次看到这题，觉得将公交路线本身视为节点而不是站点视为节点这个思路很异想天开。
但是这次第一次看到后，可以说觉得没那么神奇了。

另外BFS探索图中最短路径的范式也大概找到了：
```text
queue.append((start, 根据题目要求为1或者0))
seen = set()
while queue:
    node, times = queue.popleft()
    if node符合要求:
        return 或者 记录结果并break
    if node in seen:
        为了防止循环探索 continue
    seen.add(node)
    for nxt in node.next_nodes_in_graph:
        if nxt符合要求:
            queue.append((nxt, times + 1))

return 默认值如-1
```