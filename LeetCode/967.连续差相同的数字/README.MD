## 题目描述
返回所有长度为 n 且满足其每两个连续位上的数字之间的差的绝对值为 k 的 非负整数 。

请注意，除了 数字 0 本身之外，答案中的每个数字都 不能 有前导零。例如，01 有一个前导零，所以是无效的；但 0 是有效的。

你可以按 任何顺序 返回答案。

示例 1：
```
输入：n = 3, k = 7
输出：[181,292,707,818,929]
解释：注意，070 不是一个有效的数字，因为它有前导零。
```
示例 2：
```
输入：n = 2, k = 1
输出：[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]
```
示例 3：
```
输入：n = 2, k = 0
输出：[11,22,33,44,55,66,77,88,99]
```
示例 4：
```
输入：n = 2, k = 2
输出：[13,20,24,31,35,42,46,53,57,64,68,75,79,86,97]
```

提示：
```
2 <= n <= 9
0 <= k <= 9
```

### 解法 DFS
没啥可说的，就是一个用DFS或者BFS可以做的题。
而且尝试了下发现，如果用外部维护一个`digits`数组，然后用回溯的方式来做的话，dfs函数本身甚至都不需要参数。

简单来说，进入dfs函数后，首先判断`digits`是否为空。
若为空，则考虑将1-9各个数字尝试放进去（因为没有前导零）。

对非空的情况，则取出`digits[-1]`，看其`+=k`或者`-=k`后是否仍是一个一位数，然后将这个数字append进`digits`即可。

当`digits`的长度到达`n`时自然就可以收割结果了。

还有一个小细节，当`k`等于0时，实际上`+=k`和`-=k`的结果一样，所以只能计算一遍，否则会有重复答案。

以上。