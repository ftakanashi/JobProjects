## 题目描述
给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在两个下标 i 和 j，使得 abs(nums[i] - nums[j]) <= t ，同时又满足 abs(i - j) <= k 。

如果存在则返回 true，不存在返回 false。

示例 1：
```
输入：nums = [1,2,3,1], k = 3, t = 0
输出：true
```
示例 2：
```
输入：nums = [1,0,1,1], k = 1, t = 2
输出：true
```
示例 3：
```
输入：nums = [1,5,9,1,5,9], k = 2, t = 3
输出：false
```

提示：
```
0 <= nums.length <= 2 * 104
-231 <= nums[i] <= 231 - 1
0 <= k <= 104
0 <= t <= 231 - 1
```

### 解法1 有序窗口的二分查找
这题和`LC.219`的区别在于寻找的不是相等的，而是差值小于t的两个数。
`LC.219`的基本套路还是可以套用，只是细节上需要注意。

当滑动窗口滑动，新进来一个数字之后，我该如何判断其是否和当前窗口中某个数字的差值小于t。
最朴素的想法是遍历一次窗口，查找符合条件的值。但是这样显然效率很低。

换一个视角，如果窗口能有序，那么就可以用二分查找定位新元素的插入位置。
此时，插入位置的左右两边如果某一边和新元素的差值小于t，就可以返回True了。

>因为Python的list的insert方法是O(n)的，所以上述算法其实并没有优化多少复杂度。
>
>事实上，因为每滑动一次窗口，要首先二分查找删除元素、删除之、再二分查找新元素插入点、插入之，这一套下来应该是O(klogk)了。
>
>这么一来总体复杂度难道不是O(nklogk)么……

上述做法其实和`LC.480`有点像。

### 解法2 滑窗+桶思想
这是一个更有趣的解法，而且可以时间O(n)搞定。

先不考虑下标的要求，只考虑检查有没有任意两个值的差小于t。
这个问题有一个巧妙的解法，就是将各个数字给存放到相应的桶中。桶的编号为`n // (t+1)`。

为什么这么做呢？其实按这样处理，存放到同一个桶里的数字必然是差值小于等于t的。
>注意，除数使用t+1而不是t是很巧妙的。如果用t，那么差值等于t的情况可能会被分到两个桶。比如t是3，两个数字0和3分别被分到0号桶和1号桶。

这样完了吗？其实还没有。还是以t=3举例。7和9两个数字分别分到1号桶和2号桶，但是两者差值也是小于3的。
所以除了检查桶里是否有多于一个元素，还需要检查相邻的桶的情况。

好在在每个桶只有一个元素的前提下，检查相邻桶也就只需要检查一个元素而已。

接下来再引入下标的要求。这其实还是滑窗。当滑动时先将左边界的数字处于的那个桶这个删掉（还是注意，桶里只有一个元素所以直接删没关系）。

而后讲新元素的桶编号算出来，加入桶的集合中。此时检查是否已经有同编号的桶存在或者相邻两桶的数字和新数字的差值也符合要求。

最后具体实现上，因为有可能存在数据`1 5 9 1000000`之类的，`1000000`的桶编号很大，所以不应该用数组来实现桶，最好用字典。

