## 题目描述
给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。

你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。

示例 1：
```
输入：n = 13
输出：[1,10,11,12,13,2,3,4,5,6,7,8,9]
```
示例 2：
```
输入：n = 2
输出：[1,2]
```

提示：
```
1 <= n <= 5 * 10^4
```

### 解法 （虚拟地）N叉树遍历
这题说难不难，但是说简单也不简单。
看到题目第一时间就想到了，这其实是一个N叉树的前序遍历问题。
如果不是题目要求O(1)的额外空间，那么完全可以构建一个10叉树然后显式地DFS前序遍历。

当然，那样的话一方面树本身需要空间，另一方面dfs的递归也需要空间。
换言之，我们这里需要用到隐式的遍历树并且是采用迭代而非递归的方法来遍历。
(总之，想到这是一个虚拟的遍历树的问题很重要，一开始我尝试用栈之类的方法来模拟，结果越写越麻烦。。

我们设置一个指针`num`，用于表示当前扫描到的虚拟的树节点代表的十进制数。
于是，将指针`num *= 10`就是往节点的子节点走，`num //= 10`就是往节点的父节点走，`num += 1`就是往节点的下一个兄弟节点走。
其实可以发现，这棵虚拟的树比一般的N叉树更好用，因为他除了父节点指向子节点的指针，甚至还有反过来的指针以及同辈节点之间的指针。

在有了上述基础操作后，只要稍微脑补一下就能大概想出算法了。
其整体流程，大概如下：
从根节点开始（注意这里的根节点是1，因为题目明确了整个序列从1开始），优先不断地往子节点走直至超标（`num > n`）。
接着往当前节点的右边的兄弟节点走，直至走完。注意这里还是需要注意，如何判断走完所有兄弟节点。
其实只要判断当前`num`的末位是不是9即可。是9，就说明兄弟节点的遍历到头了。
兄弟节点也走完后，反向回到父节点，接着再向父节点的右边的兄弟节点走。
（注意父节点可能是兄弟节点中的最后一个，此时可能需要向上回溯多层，比如`1999`之类的情况。

做完这题，可以说感觉思想框架很重要。
在我没有有意识地将这个过程抽象为一个遍历树的过程的时候，虽然大概逻辑能够摸清，但是代码总是写不完美，
总会因为各种各样的细节无法写出AC代码。

这题整体思维框架和`LC.440`有点像，当然比那题要简单。