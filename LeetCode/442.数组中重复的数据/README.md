## 题目描述
给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。

找到所有出现两次的元素。

你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？

示例：
```
输入:
[4,3,2,7,8,2,3,1]

输出:
[2,3]
```

### 解法1 互换标记法
不用额外空间的话，大体思路很明确，就是要用输入数组本身作为标记的辅助。因为输入规定了每个值都在1到n之间，所以可以将
数组的下标和数组的值联系起来，从而起到标记的作用。
而具体的做法有好几种。先来说说我最先 想到的互换标记法。

这种方法的思路就是期望下标`i`时`nums[i]`能够是`i+1`，我们称这种case为符合要求的。
如果不是，那么就将其置换到`nums[i] - 1`处。
显然，如果置换前`nums[nums[i] - 1]`已经符合要求，那么说明这个数组中存在两个`nums[i]`值，所以就可以记录到结果中。

按照上述思路一步一步走，示例的数组会这样变化：
```text
4 3 2 7 8 2 3 1
-> 经过4次互换后，收割3进结果
3 2 3 4 8 2 7 1
-> 经过两次互换，收割3进结果
1 2 3 4 3 2 7 8
-> 收割2进结果
```
而由于指针扫描过后并不保证其左边的所有位置都是符合要求的，因此可能存在好几次重复收割一个数字进结果。
所以这种算法下，结果应该是一个哈希集，最后转成列表返回。

### 解法2 取反标记法
上面解法的互换的目的，无非是希望在后面扫描到某个数字的时候，能够知道这个数字在前面是否已经被扫描到过。

而同样的办法，可以通过取反来实现。取反比互换更快。

具体的，扫描到下标`i`时，将`nums[abs(nums[i]) - 1]`取反。
这样，如果后续再次扫描到`abs(nums[i])`时，只要看`nums[abs(nums[i]) - 1]`是否是负数就可以知道之前是不是扫描到过，从而判断出重复的元素。
由于后面的元素可能因为前面元素的扫描被取反了，所以其作为下标使用的时候要套上绝对值，
这也是上面式子都带abs的原因。

话不多说，看代码最快了。

这类需要互换标记的题目，通常都可以想想用取反标记来做。

#### 2022/5/8 追加笔记
取反标记法的每次操作都只要O(1)，且不涉及互换操作耗费的时间。
因此效率比第一种下标互换的方法高很多。