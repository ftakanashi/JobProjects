## 题目描述
你还记得那条风靡全球的贪吃蛇吗？

我们在一个 n*n 的网格上构建了新的迷宫地图，蛇的长度为 2，也就是说它会占去两个单元格。蛇会从左上角（(0, 0) 和 (0, 1)）开始移动。我们用 0 表示空单元格，用 1 表示障碍物。蛇需要移动到迷宫的右下角（(n-1, n-2) 和 (n-1, n-1)）。

每次移动，蛇可以这样走：

- 如果没有障碍，则向右移动一个单元格。并仍然保持身体的水平／竖直状态。

- 如果没有障碍，则向下移动一个单元格。并仍然保持身体的水平／竖直状态。

- 如果它处于水平状态并且其下面的两个单元都是空的，就顺时针旋转 90 度。蛇从（(r, c)、(r, c+1)）移动到 （(r, c)、(r+1, c)）。
- ![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image-2.png)

- 如果它处于竖直状态并且其右面的两个单元都是空的，就逆时针旋转 90 度。蛇从（(r, c)、(r+1, c)）移动到（(r, c)、(r, c+1)）。
- ![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image-1.png)

返回蛇抵达目的地所需的最少移动次数。

如果无法到达目的地，请返回 -1。

示例 1：

```
输入：grid = [[0,0,0,0,0,1],
               [1,1,0,0,1,0],
               [0,0,0,0,1,1],
               [0,0,1,0,1,0],
               [0,1,1,0,0,0],
               [0,1,1,0,0,0]]
输出：11
解释：
一种可能的解决方案是 [右, 右, 顺时针旋转, 右, 下, 下, 下, 下, 逆时针旋转, 右, 下]。
```
示例 2：
```
输入：grid = [[0,0,1,1,1,1],
               [0,0,0,0,1,1],
               [1,1,0,0,0,1],
               [1,1,1,0,0,1],
               [1,1,1,0,0,1],
               [1,1,1,0,0,0]]
输出：9
```

提示：
```
2 <= n <= 100
0 <= grid[i][j] <= 1
蛇保证从空单元格开始出发。
```

### 解法 BFS
这题还是挺有意思的，而且虽然被打了hard，但是也没有想象中那么难。

不考虑旋转这种特殊操作，只是通过平移到达指定位置的最小步数，显然就是一个BFS或者DP能做的简单的走迷宫问题。这里以BFS为例。
现在考虑了旋转操作，也只不过是把BFS的各种判断条件稍微整复杂了一下。

这里还有个小技巧，我们使用"蛇尾"作为蛇的基准点来考虑。至于理由，在讲完判断条件后会说。

假设当前蛇尾处于`x, y`处，由于蛇有横着，即占据`(x, y)`和`(x, y+1)`的状态，以及竖着，即占据`(x, y)`和`(x+1, y)`的状态。
由于这两种状态接下来的动作是不同的，所以我们还需要再BFS过程中识别，我们以`0`表示第一种状态，`1`表示第二种状态。

显然BFS的起点是`(0, 0, 0, 0)`，四个0分别表示`x, y, status, step`。

对于`status == 0`的情况，可以讨论的下一步动作是
若`x, y+2`未越界且是0，则向右前进一步。
若蛇身下方两个格子未越界且都是0，则平移向下，或者顺时针旋转90度。

对于`status == 1`的情况，则是对称的，
若`x+2, y`未越界且是0，则向下前进一步
若蛇身右方的两个格子未越界都是0，则平移向右，或者逆时针旋转90度。

核心算法思想就是上面这些规则了。实现为代码即可。
实现中，也有一些技巧。比如我给出的代码中自己实现了一个HashQueue类，这样就不用额外再主代码中维护一个`seen`哈希集了。

然后回到刚才那个问题，为什么要以蛇尾作为蛇的基准点？
因为旋转操作的轴心是蛇尾，如果以蛇头作为基准点，每次旋转操作后还要转换一下坐标，显然蛇尾更加方便。
当然最后别忘了因为蛇尾是基准点，所以最终目的地是`m-1, n-2`。