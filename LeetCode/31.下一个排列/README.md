## 题目描述

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
```text
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
```

### 解法 寻找规律后模拟规律
字典序是什么就不说了。

按题意，给出一个排列让我写按字典序的下一个排列，没什么难度。

但是突然你说让我编程实现，一下子还真有点蒙蔽。因为感觉写出下一个排列这种操作理所当然，从来没有仔细想过为什么下一个排列是这样的。

没办法，再看了两眼答案，然后自己又写了很多例子后，从中提炼出了规律。比如看这个序列：
```text
2 3 4 1 6 5
```
显然他的下一个排列是`2 3 4 5 1 6`。怎么会变成这样？最关键的其实是在`1`这个位置。

感觉上来说，1后面的排列已经"饱和"了。这个子序列已经达到了所能达到的最大字典序，因此就要考虑把1包括进来，整体后三个数字组成子序列的下一个排列

而这个子序列的下一个排列的开头，显然是这个序列中比1大但是又尽量小的那个值。具体来说就是5。
确定了开头，剩余排列部分怎么办？其实，因为"开头"变了，所以剩余排列的最小值就是剩余排列部分升序排列。
所以最终，这个子序列的排列变成了`5 1 6`。

用更加算法的语言来重新组织一下上述思路。

首先，所谓的"饱和"序列无非就是逆序序列。所以从后往前扫描找到逆序序列的边界。例子中就是6。
然后再往前一个就是当前饱和序列前面的"开头"，称其为pivot。把这个开头囊括进来，形成集合`{1, 5, 6}`。

现在，从中找到比1大但尽量小的数字。直接模拟这么做也可以，但是实际上还可以这么干：
不用构建这个集合，只需要再扫描一遍"饱和"序列，找到相应的数字之后，将它和pivot互换位置即可。

最后，pivot以后的子序列，这例中是`6 1`，重新升序排序，得到新pivot开头时最小的排列。

再来验证一下，比如上例得到的`2 3 4 5 1 6`再来一次。此时pivot位置是1的位置，pivot后子序列中符合要求的数字是6（也只有一个6）

将两者互换后，新pivot值是6，而pivot后序列就一个1，也就谈不上重新排序了。

得到`2 3 4 5 6 1`，正确答案！

按照这个思路，

1. 确定pivot位置

2. 确定pivot后的逆序排列中比当前pivot值大且尽量小的值

3. 互换pivot和那个值

4. 重置pivot后子序列为升序排列

写代码即可。