## 题目描述
给定一个单链表，随机选择链表的一个节点，并返回相应的节点值。保证每个节点被选的概率一样。

进阶:
如果链表十分大且长度未知，如何解决这个问题？你能否使用常数级空间复杂度实现？

示例:
```
// 初始化一个单链表 [1,2,3].
ListNode head = new ListNode(1);
head.next = new ListNode(2);
head.next.next = new ListNode(3);
Solution solution = new Solution(head);

// getRandom()方法应随机返回1,2,3中的一个，保证每个元素被返回的概率相等。
solution.getRandom();
```

### 解法1 链表入连续表后随机选择
不解释…

### 解法2 蓄水池随机采样算法
如果按照进阶的要求，那么在不先求出整体链表长度的前提下，如何做到让每个链表都等概率地被随机到是个问题。

考虑这样一个算法：
维护一个动态的长度count，表示已经扫描过的节点个数。
然后在已经扫描过count个节点的情况下，以1/count的概率选择记录当前节点作为输出节点。

注意，这里只是记录并不是真的输出，前面的记录有可能会被后面的记录覆盖。

以`3 -> 4 -> 5`这个简单的链表为例。

扫描到3时，count是1，所以100%记录3作为输出节点。

扫描到4时，count是2，所以50%概率用4覆盖3作为输出，50%保留3。

扫描到5时，count是3，所以33.3%概率用5覆盖之前的输出。那么此时输出是4的概率呢？
这就是个 2/3 * 1/2，前面的2/3是指保留之前的记录，而后面的1/2表示count是2时我选择用4覆盖了3。
所以，输出是4的概率也是1/3。
同理count更大的时候，只要遵循这个规律，可以做到每个节点输出概率保持在1 / count。

这个算法像是在容量不断增加的蓄水池中，始终等概率地取出新水和旧水。

同时这个算法也有很多实用性，比如某份大数据，我想从中随机抽样几个，但是又无法将其整个放进内存，
此时就可以使用这个算法。