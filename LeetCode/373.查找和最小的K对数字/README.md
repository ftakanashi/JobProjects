## 题目描述
给定两个以升序排列的整数数组 nums1 和 nums2 , 以及一个整数 k 。

定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。

请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  ...  (uk,vk) 。

示例 1:
```
输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
输出: [1,2],[1,4],[1,6]
解释: 返回序列中的前 3 对数：
     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
```
示例 2:
```
输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
输出: [1,1],[1,1]
解释: 返回序列中的前 2 对数：
     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
```
示例 3:
```
输入: nums1 = [1,2], nums2 = [3], k = 3 
输出: [1,3],[2,3]
解释: 也可能序列中所有的数对都被返回:[1,3],[2,3]
```

提示:
```
1 <= nums1.length, nums2.length <= 104
-109 <= nums1[i], nums2[i] <= 109
nums1, nums2 均为升序排列
1 <= k <= 1000
```

### 解法 小顶堆 + 哈希表
这题其实不怎么难。

一个最简单的办法是暴力枚举出所有数字对，然后排序取前k个。
当然那样的话复杂度会很大。
一个类似求数组中第k大元素的思路是用一个小顶堆一边扫描一边记录。
当记录够k个元素后就可以停止了。

基于这样的思路，具体到这道题里，由于两个数组都是排好序的，
因此我们可以直接设置两个指针i,j分别指向两个数组。

扫描过程中，对于数字对`nums1[i], nums2[j]`，可以根据其和为依据入小顶堆。
这样，我们只要pop一次堆就可以得到当前和最小的数字对了。
pop出一个数字对后，下一步要找的是可能稍大一些的数字对并将其入堆。

此时选择的策略是找`i, j+1`和`i+1, j`这两种。
当然，以上策略可能会引起数字对的重复，因此再额外设置一个seen哈希集用于杜绝重复情况。

详情见代码吧。