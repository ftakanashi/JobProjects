## 题目描述
给你一个以字符串形式表述的 布尔表达式（boolean） expression，返回该式的运算结果。

有效的表达式需遵循以下约定：
```
"t"，运算结果为 True
"f"，运算结果为 False
"!(expr)"，运算过程为对内部表达式 expr 进行逻辑 非的运算（NOT）
"&(expr1,expr2,...)"，运算过程为对 2 个或以上内部表达式 expr1, expr2, ... 进行逻辑 与的运算（AND）
"|(expr1,expr2,...)"，运算过程为对 2 个或以上内部表达式 expr1, expr2, ... 进行逻辑 或的运算（OR）
```
 

示例 1：
```
输入：expression = "!(f)"
输出：true
```
示例 2：
```
输入：expression = "|(f,t)"
输出：true
```
示例 3：
```
输入：expression = "&(t,f)"
输出：false
```
示例 4：
```
输入：expression = "|(&(t,f,t),!(t))"
输出：false
```

提示：
```
1 <= expression.length <= 20000
expression[i] 由 {'(', ')', '&', '|', '!', 't', 'f', ','} 中的字符组成。
expression 是以上述形式给出的有效表达式，表示一个布尔值。
```

### 解法 栈
因为涉及到括号逻辑的解析，一看就知道可以用栈写，只要注意一点规则就可以了。

从左到右扫描expression，当字符是t或者f时，直接将其转化为对应的bool值入栈。
如果是运算符，就直接入栈。
如果是左括号，就跳过
右括号，就从栈顶pop出所有bool值直到碰到栈顶是运算符。
期间pop出来的所有bool值都是本次需要运算的对象，而运算操作根据运算符决定。

如果题目不能保证输入字符串的合法性，那么上面这个过程中还有很多要检查的地方。
比如操作符是`!`的时候运算对象只能是一元，比如括号嵌套不合法时等。

不过好在题目保证了表达式的合法，就不用管这么多了。