## 题目描述
给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。

当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

注意：不允许旋转信封
 
示例 1：
```
输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出：3
解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。
```
示例 2：
```
输入：envelopes = [[1,1],[1,1],[1,1]]
输出：1
```

提示：
```
1 <= envelopes.length <= 5000
envelopes[i].length == 2
1 <= wi, hi <= 104
```

### 解法 排序 + 单调栈（变体）
这其实是一个二维的LIS问题。

基本的LIS问题参考`LC300`的做法。

首先需要意识到，这道题各个信封的选取顺序没有严格限制，所以为了方便，应该将输入的数组排序后处理。

接下来，如果傻傻地套用LC300的做法，设置dp数组后用两层循环遍历各个信封，当前面某个信封的长宽均小于本信封时状态转移：
```text
if e[j][0] < e[i][0] and e[j][1] < e[i][1]:
    dp[i] = max(dp[i], dp[j]+1)
```
是会超时的。

其实对于这个问题，因为排序了，所以对于扫描位置`i`时，其实已经有保证：
`e[j][0] <= e[i][0]`，即宽是完全有序的。

这样的话，其实只要找到`e[j][0] == e[i][0]`之前所有的高，这些数字组成数组后加上当前信封的高`e[i][1]`，这个数组的最长递增子序列就是所求答案。
求一个数组的最长递增子序列的长度，那就和`LC300`一模一样了。

问题就在于，如何定位第一个符合条件`e[j][0] == e[i][0]`的位置j。

这里给出一种很聪明的办法，最初排序时，高的顺序以逆序排列。

如此，所有上述所求位置到本位置之间，高一直不递增，从而不会影响最长递增子序列的判断。