## 题目描述
序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。
```
     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #
```
例如，上面的二叉树可以被序列化为字符串 "9,3,4,#,#,1,#,#,2,#,6,#,#"，其中 # 代表一个空节点。

给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。

每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 '#' 。

你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 "1,,3" 。

示例 1:
```
输入: "9,3,4,#,#,1,#,#,2,#,6,#,#"
输出: true
```
示例 2:
```
输入: "1,#"
输出: false
```
示例 3:
```
输入: "9,#,#,1"
输出: false
```

### 解法 栈
这道题虽说背景是树，但是因为题目要求不要建树，所以并非归类的树分类下。

既然不能建树，而遍历序列似乎又是不可避免的，于是联想到非递归地树遍历方法，也就是说要用到栈来模拟。

在初期的写写画画中注意到，对于任意一个类似于`a # #`的序列，这其实就是一个合法的树了。
而这个序列也很有可能就是某棵更大树的子树。
在碰到一个上述序列之后，显然这个子树算是遍历完成了，但是如何告知上层的树，我这个子树已经遍历完成则是难点。

一个思路是将一个额外的`#`入栈，用它来表示这个子树的整体，即我这个子树已经处理完了。
依次递归地类推。

比如示例1，栈的变化规律如下：
```text
9 3 4 # #       初期入栈五个元素，当栈末尾出现了a # #序列时，弹出这个序列并入栈一个额外的#，于是得到：
9 3 #           此时栈顶的#表示的，就是之前的4 # #子树遍历完成了，即3这个树的左子树遍历完成了
9 3 # 1 # #     再次出现a # #，弹出后入栈额外的#
9 3 # #         这次不用再加入新元素直接出现a # #
9 #
9 # 2 # 6 # #   以此类推…之后就不写了
```

剩下的问题就是如何通过这个栈的情况判断序列是否合法了。
一个极端的例子，加入序列中元素全是数字或者全是#，那么最终栈很满，肯定不行。
所以判断条件应该是遍历完成后栈是否是空的。

但是还有些例外情况，比如`1 # 2 # # 3 # #`这个例子。
如果只有前五个，那是合法的。最后的`3 # #`则是多余的。

但是按照上述算法，模拟后发现遍历完前五个后虽然栈空了，但是如果不加任何处理，会接下去遍历后面的元素。
而后面的`3 # #`本身是一个合法的树，因此最终出来的栈还是空的，也不会报错。

所以完整的判断条件应该是，当栈空的时候查看是否完整遍历了所有元素，如果栈空时恰好所有元素也都遍历过了，那么才是合法。
否则就是这个例子这样的非法情况。