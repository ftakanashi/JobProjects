## 题目描述
给你一个整数数组 nums​​​ 和一个整数 k​​​​​ 。区间 [left, right]（left <= right）的 异或结果 是对下标位于 left 和 right（包括 left 和 right ）之间所有元素进行 XOR 运算的结果：nums[left] XOR nums[left+1] XOR ... XOR nums[right] 。

返回数组中 要更改的最小元素数 ，以使所有长度为 k 的区间异或结果等于零。

示例 1：
```
输入：nums = [1,2,0,3,0], k = 1
输出：3
解释：将数组 [1,2,0,3,0] 修改为 [0,0,0,0,0]
```
示例 2：
```
输入：nums = [3,4,5,2,1,7,3,4,7], k = 3
输出：3
解释：将数组 [3,4,5,2,1,7,3,4,7] 修改为 [3,4,7,3,4,7,3,4,7]
```
示例 3：
```
输入：nums = [1,2,4,1,2,5,1,2,6], k = 3
输出：3
解释：将数组[1,2,4,1,2,5,1,2,6] 修改为 [1,2,3,1,2,3,1,2,3]
```

提示：
```
1 <= k <= nums.length <= 2000
​​​​​​0 <= nums[i] < 2^10
```

### 解法 DFS
首先声明，这道题可以用DP做。具体可以参考官方题解或者其他人的答案。
但是DP其实挺奇怪的，尤其是还需要`2^10`量级的时间/空间（因为每个数字都可以自由改变为1-2^10中的任意一个数字，DP的时候需要对其进行枚举。
而如果用DFS就稍微好一点。

接下来，先来简单分析一下题目意思。
任意长度为k的区间异或结果是0，稍微写一下就明白了，其实最终得到的数组是一个长度为k且异或结果为零的单元数组重复了若干遍。
如`3 4 7 3 4 7 3 4 7`。

于是，问题就变成了如何用最小次数改变数组后，使得每个`nums[i]`和`nums[i+k]`相等，并且还有`nums[:k]`的异或结果是0。

这其实也是两个互相联系的小问题。
第一，如何用尽量少的次数，将每个`nums[i]`和`nums[i+k]`相等化？
第二，如何在上述相等化的前提下，确保`nums[:k]`的异或结果是0？

DFS的思路，是这样的：
针对第一个问题，首先将所有子区间竖过来写，比如示例2输入，写成：
```text
3 4 5
2 1 7
3 4 7
```
显然只要每列相同就行了。因为要变更次数尽可能少，显然将每列都改成列内的众数即可。上例中众数分别是`3 4 7`。

注意，在这个时间点上，其实我们已经有了一些累计的操作次数。因此已经有了一个最小操作次数的"基准值"。

但是改成众数之后并不一定会有子区间的异或结果是0。上面只是例子特殊，如果我改成
```text
3 4 5
2 1 7
3 1 7
```
又该怎么办？

此时按照上面改成众数的思路，第一步得到的应该是`3 1 7`，因为其异或结果不是0，现在我们考虑将其中的某些数字进一步修改，使得其异或结果为0。
这就用DFS来搜索了。

具体的，设计dfs函数为`dfs(start, cur_xor)`，表示上面矩阵从左到右处理到第`start`列时，前面所有列的异或结果是`cur_xor`的情况
(注意，"列的异或结果"这个表达，因为默认前面列都处理完成，即列方向上数字全都统一了，这词指这些统一了的数字在行方向上的异或结果)。
函数的返回定义为，在特定`start`和`cur_xor`时，修改本列数字后使得最终行方向总异或为零的最小额外代价。
之所以称之为额外的，是因为之前已经有了"基准值"。最后基准值加上最小额外代价就可以得到最后的答案。

在dfs函数内部，考虑本列时，无非是两种可能。
第一，将本列数字都改成列中存在的某个数字；
第二，将本列数字都改成列中不存在的某个数字；

前者，显然我可以枚举列中每个数字`num`，并以此为基准开启下一层的DFS:`dfs(start+1, cur_xor^num)`。
而将本列数字全都改成列中某个数字`num`时可能会引起额外的代价。
这个值是`众数的频数 - counter[num]`
(体会一下这个式子，一开始很难理解…因为求的是额外的代价，而已经消耗的代价是总元素数 - 众数的频数：将那些非众数修改为众数的操作次数。
换言之，如果num本身就是众数，那么并没有发生额外的代价；若其不是，那么额外的代价就是将其从众数还原的操作次数以及将众数变成它的操作次数，相当于其计数与众数计数的差值。)

对于后者，一开始我想不知道目标数字是什么的话似乎没办法做。
但其实由于异或计算的可交换性，假设除了本列其他列都已经决定了用什么数字，此时只要将本列全部数字改成其他列的异或结果，由于`a^a=0`，最终就可以达成目的。

换言之，虽无严格证明，但是任意一列的最大的操作次数，就是这一列元素的个数。

最后还有个小优化点。
为了使尽量小的额外代价尽早出现，遍历列中数字时可以按其频数的降序为顺序遍历。并且如果遍历到某数字时，
其引发的额外代价已经大于当前记录过的最小的额外代价，那么就没必要针对这种情况继续探索。

>说实话，这道题给我做吐了…自己尝试做了1个小时，看答案分析又花了快3个小时，还没有太高明白。
>
>就这样吧 我不想再碰这题了……