## 题目描述
给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。

返回执行此操作后，grid 中最大的岛屿面积是多少？

岛屿 由一组上、下、左、右四个方向相连的 1 形成。

示例 1:
```
输入: grid = [[1, 0], [0, 1]]
输出: 3
解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。
```
示例 2:
```
输入: grid = [[1, 1], [1, 0]]
输出: 4
解释: 将一格0变成1，岛屿的面积扩大为 4。
```
示例 3:
```
输入: grid = [[1, 1], [1, 1]]
输出: 4
解释: 没有0可以让我们变成1，面积依然为 4。
```

提示：
```
n == grid.length
n == grid[i].length
1 <= n <= 500
grid[i][j] 为 0 或 1
```

### 解法 并查集
提供一种比较不是那么优雅，但是思路很直接，也能AC的做法。

这题一看就知道可以用并查集，不过记得区分并查集实现中rank和size的区别。
即，这题我们想要的是每个连通分量的size，即节点个数，而不是rank（最高高度）

明确这一点后首先先手撸一个带size的并查集。

然后做题目。
第一步，显然我们需要遍历一遍地图，将地图中的所有1和四周相连的情况维护到并查集中。
这个过程并不复杂。

接着我们需要将某个0变成1，此时选择第二次遍历地图，这次我们碰到0时才停下。
我们检查这个0四周有多少1，并且这些1是否处于哪些连通分量中。如果这些1从属于不同的联通分量，
那么通过把当前0转换为1，就可以获得一个更大的联通分量。
注意这个计算过程应当是在循环中动态进行，而不要真的去修改并查集中的数据。

遍历过程中随时收割最大联通分量的size即可。