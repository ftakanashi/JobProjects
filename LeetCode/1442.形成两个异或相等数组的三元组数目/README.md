## 题目描述
给你一个整数数组 arr 。
现需要从数组中取三个下标 i、j 和 k ，其中 (0 <= i < j <= k < arr.length) 。

a 和 b 定义如下：
```
a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]
注意：^ 表示 按位异或 操作。
```

请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。

示例 1：
```
输入：arr = [2,3,1,6,7]
输出：4
解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)
```
示例 2：
```
输入：arr = [1,1,1,1,1]
输出：10
```

提示：
```
1 <= arr.length <= 300
1 <= arr[i] <= 10^8
```

### 审题
先来捋一捋题目。
`i,j,k`三个下标，`j`和`k`可以相等但是大于`i`。
因为a和b的定义是连续的元素的异或运算，所以题目可以理解为寻找一片区间，并且在区间内找到一个中间点（可包括右端点），
使得前半部分的异或结果等于后半部分的运算结果。

乍一眼想用滑窗做，但是仔细想了一下，`a == b`的话，不就意味着`a^b == 0`么。
换言之，我可以从输入数组中定位一片区域，其异或结果是0，然后从中找中间点`j`即可。

### 解法 前缀和 + 哈希
按照上述想法，第一个要解决的问题就是，如何定位一片异或结果是0的区域？

因为异或运算的自反性和其他性质，很快可以想到用前缀和。
同时为了考虑区间开头在数组下标为0处的情况，在前缀和数组的开头加上一个0作为哨兵。

举个例子，如示例1，其前缀和数组应该是
```text
0 2 1 0 6 1  （分别对应到原数组的数字：
  2 3 1 6 7
```
观察前缀和数组，我们知道了，异或结果为0的区域有两片：`2 3 1`（两个前缀和是0的配对），以及`1 6 7`（两个前缀和是1的配对）。
换言之，有了前缀和数组，扫描其中前缀和相同的两两配对，即可找出所有要求的区域。

有了区域之后，相当于确定了`i`和`k`，接下来要确定`j`。
通过实验性地写了一下，发现一个狠不戳的现象，即从`j=i+1`到`j=k`，所有`j`在一般情况下都是满足题设条件。即`a_i^...^a_j-1 == a_j^...^a_k`。

这样，只要确定了`i`和`k`，答案的计数就可以直接加上`k - i - 1`。
用上面这个例子验算，一对0下标分别是0和3，`ans += (3 - 0 - 1)`。一对1，下标分别是2和5，`ans += (5 - 2 - 1)`。
最终得到`ans = 4`，对了。

至此，代码已经不难了。
一个简单的实现思路就是，先统计出所有前缀和以及其出现的所有位置。对于出现次数超过1次的前缀和，统计其所有出现位置之间两两的下标差，并将这些差
全部加起来，得到的就是答案。

当然，上述思路在碰到一些极端例子，比如输入数字全是0的数组时，由于前缀和也全是0，时间上是O(n^2)的。
下面用哈希表对其进行优化。

注意到，此时问题已经转变成这样：给定一个数组，数组元素之间两两都有差。求这些差的总和。
当这个数组长度为2时，很显然直接求差即可。
如果此时又来一个更大的数，比如`1 3`后面来了一个`5`。此时，要新补上的差包括了`5-1`和`5-3`，可以写成`5*2 - (1+3)`。

换言之，只要我知道某个时刻前面所有元素的个数以及其总和，就可以通过上述公式求出需要补充的差的部分，加上去即可。

上面说的"一个数组"只是前缀和是特定的一个值的情况。为了可以应对各种各样的前缀和的值，用两个哈希表分别维护起来，这些前缀和与各自已经出现的"下标个数"以及"下标之和"。

比如示例2，得到的前缀和数组是`0 1 0 1 0 1`。
从左到右扫描过程中，当扫描到最后一个1时，此时的前缀和下标个数哈希和下标和哈希应该是：
```python
s_count = {
    0: 3, 
    1: 2
}
s_sum = {
    0: 6    # 0 + 2 + 4
    1: 4    # 1 + 3 
}
```
此时首先因为`s_count[1]`不是0，说明前缀和1在之前出现过，因此要计算新增加的差分数。
而这个值是`(5-1 - 1) + (5-1 - 3)`（别忘了k不能等于i，因此要减去1），也就是`(s_count[1] * (5-1)) - s_sum[1] = 4`。
因此答案再追加4。

以上，通过利用哈希表，可以做到在O(n)时间内实时维护增加答案，最终返回即可。

上述描述如果看不懂，建议直接看代码。