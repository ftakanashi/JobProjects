## 题目描述
你正在参与祖玛游戏的一个变种。

在这个祖玛游戏变体中，桌面上有 一排 彩球，每个球的颜色可能是：红色 'R'、黄色 'Y'、蓝色 'B'、绿色 'G' 或白色 'W' 。你的手中也有一些彩球。

你的目标是 清空 桌面上所有的球。每一回合：

从你手上的彩球中选出 任意一颗 ，然后将其插入桌面上那一排球中：两球之间或这一排球的任一端。
接着，如果有出现 三个或者三个以上 且 颜色相同 的球相连的话，就把它们移除掉。
如果这种移除操作同样导致出现三个或者三个以上且颜色相同的球相连，则可以继续移除这些球，直到不再满足移除条件。
如果桌面上所有球都被移除，则认为你赢得本场游戏。
重复这个过程，直到你赢了游戏或者手中没有更多的球。
给你一个字符串 board ，表示桌面上最开始的那排球。另给你一个字符串 hand ，表示手里的彩球。请你按上述操作步骤移除掉桌上所有球，计算并返回所需的 最少 球数。如果不能移除桌上所有的球，返回 -1 。

示例 1：
```
输入：board = "WRRBBW", hand = "RB"
输出：-1
解释：无法移除桌面上的所有球。可以得到的最好局面是：
- 插入一个 'R' ，使桌面变为 WRRRBBW 。WRRRBBW -> WBBW
- 插入一个 'B' ，使桌面变为 WBBBW 。WBBBW -> WW
桌面上还剩着球，没有其他球可以插入。
```
示例 2：
```
输入：board = "WWRRBBWW", hand = "WRBRW"
输出：2
解释：要想清空桌面上的球，可以按下述步骤：
- 插入一个 'R' ，使桌面变为 WWRRRBBWW 。WWRRRBBWW -> WWBBWW
- 插入一个 'B' ，使桌面变为 WWBBBWW 。WWBBBWW -> WWWW -> empty
只需从手中出 2 个球就可以清空桌面。
```
示例 3：
```
输入：board = "G", hand = "GGGGG"
输出：2
解释：要想清空桌面上的球，可以按下述步骤：
- 插入一个 'G' ，使桌面变为 GG 。
- 插入一个 'G' ，使桌面变为 GGG 。GGG -> empty
只需从手中出 2 个球就可以清空桌面。
```
示例 4：
```
输入：board = "RBYYBBRRB", hand = "YRBGB"
输出：3
解释：要想清空桌面上的球，可以按下述步骤：
- 插入一个 'Y' ，使桌面变为 RBYYYBBRRB 。RBYYYBBRRB -> RBBBRRB -> RRRB -> B
- 插入一个 'B' ，使桌面变为 BB 。
- 插入一个 'B' ，使桌面变为 BBB 。BBB -> empty
只需从手中出 3 个球就可以清空桌面。
```

提示：
```
1 <= board.length <= 16
1 <= hand.length <= 5
board 和 hand 由字符 'R'、'Y'、'B'、'G' 和 'W' 组成
桌面上一开始的球中，不会有三个及三个以上颜色相同且连着的球
```

### 解法 记忆化DFS
题目比较长，先来理解一下题意。
其实这题就是一个消消乐的游戏。board是当前游戏面板的一个序列，而hand是手上有的球。
现在要做的，是从hand中 任意 拿出一个球插入到序列中的任意一个位置。

当插入操作发生后，board会自动消去一些球。
这个消去的过程是，递归地寻找序列中所有连续长度大于等于3的子序列并且将其消去。

这里需要注意，第一是递归的，所以消消乐高手都会布局，然后连锁地消去一大堆球。
第二，是大于等于3。
比如，`WWGGWW`这个序列，我可以再最中间插入一个`G`，序列变成了`WWGGGWW`，显然中间的3个G可以消去。消去后变成了`WWWW`，
此时连续的4个W仍然符合消去序列要求，因此继续消去，序列就变空了。

最后确认一下，题目要求的，是最少用几个球。

初步想了一下，感觉并没有什么好的投机取巧的办法，因此就尝试暴力搜。
暴力搜的DFS函数本身倒不难写。基本可以想象，是`dfs(curr_board, curr_hand)`。
即根据当前面板的序列情况以及当前手里剩余球的情况进行搜索，返回当前情况为起点时最少耗费几个球。
这里为了实现方便，我改成了能剩下几个球，最后的答案用最初的球数量减去返回值即可。

于是，dfs的递归终止条件就很好写了：
```python
if curr_board == '': return len(curr_hand)
if curr_hand == '': return -1
```
由于输入都是字符串，所以还可以加上记忆化，不用白不用。

函数体中的过程也不难写，既然是暴力搜，我们就遍历`curr_board`中所有位置与`curr_hand`中所有球的组合。在选定一个组合，进行一次插入操作后，
我们还需要一个`erase`函数来进行可能的消去。将消去后的新序列以及用掉刚才那个求后的手里球的情况作为下一层dfs的输入，进行搜索。

由于我们定义dfs函数返回的，是手里求的剩余数量，因此在多个分叉探索完成后应该选取其中的max值。

根据上述思路，dfs函数就写完了。
然而问题还没有解决，我们还需要实现`erase`函数。
事实表明，这个`erase`函数虽然逻辑不复杂（如上所述就是消消乐游戏最简单的逻辑），但是仍然花了不少功夫…
问题就在于如何实现上面提到的 两个注意点。第一，递归消除；第二，大于等于3的都可消除。

最终通过不断的调试代码，终于写出了正确的代码…具体的代码解释写在注释里了。