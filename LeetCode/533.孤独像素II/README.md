## 题目描述
给定一幅由黑色像素和白色像素组成的图像， 与一个正整数N, 找到位于某行 R 和某列 C 中且符合下列规则的黑色像素的数量:

- 行R 和列C都恰好包括N个黑色像素。
- 列C中所有黑色像素所在的行必须和行R完全相同。

图像由一个由‘B’和‘W’组成二维字符数组表示, ‘B’和‘W’分别代表黑色像素和白色像素。

示例:
```
输入:                                            
[['W', 'B', 'W', 'B', 'B', 'W'],    
 ['W', 'B', 'W', 'B', 'B', 'W'],    
 ['W', 'B', 'W', 'B', 'B', 'W'],    
 ['W', 'W', 'B', 'W', 'B', 'W']] 

N = 3
输出: 6
解析: 所有粗体的'B'都是我们所求的像素(第1列和第3列的所有'B').
        0    1    2    3    4    5         列号                                          
0    [['W', 'B', 'W', 'B', 'B', 'W'],    
1     ['W', 'B', 'W', 'B', 'B', 'W'],    
2     ['W', 'B', 'W', 'B', 'B', 'W'],    
3     ['W', 'W', 'B', 'W', 'B', 'W']]    
行号

以R = 0行和C = 1列的'B'为例:
规则 1，R = 0行和C = 1列都恰好有N = 3个黑色像素. 
规则 2，在C = 1列的黑色像素分别位于0，1和2行。它们都和R = 0行完全相同。
```
 

注意:
- 输入二维数组行和列的范围是 [1,200]。

### 审题
不得不说，这题题干的语言描述跟屎一样…

解释一下，题目要找的是符合条件的B像素数量。
条件具体有两个。

第一，该像素所在行、列（包括其本身在内）都具有N个B像素。这个条件只是上一题`LC.531`的条件的一个简单拓展。

第二，该像素所在列不是有N个B像素嘛，除了其本身之外剩余的N-1个B像素，其所在行的内容，必须全部完全一致并且与该像素所在的当前行内容也完全一致。
比如，示例中`[0,1], [1,1], [2,1]`三个B像素是符合要求的。
一方面这三个像素所在行的B像素数也都是3个，另一方面他们所在的第0，1，2三行也都是完全一致的。

换言之，如果我将比如`[0,2]`的W像素改成B。对于上述三个B像素虽然第一个条件还是成立，但第二个条件，因为第0行和后两行不同了，所以这三个就
不再算是符合题意的像素了。

### 解法 哈希预处理
整体的套路框架还是不变的，使用哈希预处理的办法。只不过这次预处理的内容发生了变化。

既然行内容是否完全一致那么重要，很自然的想到，可以先预处理一波所有行，看是否恰好有target个行一致。
若没有（少了不行多了也不行），那么无论如何都不会有满足第二个条件的答案出现了。
而行种类的统计，因为每行每个元素都是一个字符，所以可以采用字符串的方式。我们称之为行的pattern。

除此之外，还是和`LC.531`一样，按行列统计B的个数就好了。
值得注意的是，因为上面用了行的pattern进行统计，其实我们并不需要真的统计每行B的个数，只要统计每个patternB的个数即可。

有了这些信息之后，开始过滤答案。

显然，对于行pattern，只有那些出现次数恰好是target次，并且此pattern内部恰好有target个B像素的情况才符合条件。
而对于这样的pattern，其实那些B像素的列还需要检查一下，除了这个pattern外，是否还有其他行有B。若有那么B数量超标，不予考虑，如示例的第4列。

有了以上思路，慢慢写代码即可。