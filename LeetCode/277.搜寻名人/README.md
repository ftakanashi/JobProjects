## 题目描述
假设你是一个专业的狗仔，参加了一个 n 人派对，其中每个人被从 0 到 n - 1 标号。在这个派对人群当中可能存在一位 “名人”。所谓 “名人” 的定义是：其他所有 n - 1 个人都认识他/她，而他/她并不认识其他任何人。

现在你想要确认这个 “名人” 是谁，或者确定这里没有 “名人”。而你唯一能做的就是问诸如 “A 你好呀，请问你认不认识 B呀？” 的问题，以确定 A 是否认识 B。你需要在（渐近意义上）尽可能少的问题内来确定这位 “名人” 是谁（或者确定这里没有 “名人”）。

在本题中，你可以使用辅助函数 bool knows(a, b) 获取到 A 是否认识 B。请你来实现一个函数 int findCelebrity(n)。

派对最多只会有一个 “名人” 参加。若 “名人” 存在，请返回他/她的编号；若 “名人” 不存在，请返回 -1。

示例 1:

![](https://assets.leetcode.com/uploads/2019/02/02/277_example_1_bold.PNG)
```
输入: graph = [
  [1,1,0],
  [0,1,0],
  [1,1,1]
]
输出: 1
解释: 有编号分别为 0、1 和 2 的三个人。graph[i][j] = 1 代表编号为 i 的人认识编号为 j 的人，而 graph[i][j] = 0 则代表编号为 i 的人不认识编号为 j 的人。“名人” 是编号 1 的人，因为 0 和 2 均认识他/她，但 1 不认识任何人。
```
示例 2:

![](https://assets.leetcode.com/uploads/2019/02/02/277_example_2.PNG)
```
输入: graph = [
  [1,0,1],
  [1,1,0],
  [0,1,1]
]
输出: -1
解释: 没有 “名人”
```

提示：
```
n == graph.length
n == graph[i].length
2 <= n <= 100
graph[i][j] 是 0 或 1.
graph[i][i] == 1
```
 
```
进阶：如果允许调用 API knows 的最大次数为 3 * n ，你可以设计一个不超过最大调用次数的解决方案吗？
```

### 解法 初选+验证模拟 双指针
这道题挺有意思的。

首先，最朴素的暴力思路，就是调用`n * (n-1)`次`knows`函数，搞清楚所有人之间互相认识的情况。
这相当于是把这个有向图给完整构建出来。
接着就可以借鉴`LC.997`那样的思路，统计每个节点的入度数得到答案。

当然，试了一下果然超时，更不用说达到进阶的要求了。
实际上，这道题可以充分利用
- 只要我认识别人，我就不是名人
- 只要有人不认识我，我就不是名人
这两个逻辑点，进行一个非常巧妙的做法（当然我是抄答案的…

用具体一点的语言来说，
当`knows(a, b)`是True，那么铁定的结论是a不是名人。
当`knows(a, b)`是False，那么铁定的结论是b不是名人。
如何在关系梳理中利用好这种逻辑关系是关键。

这题，在不构建完整图的情况下，一口气导出完整关系很难。
所以我们不妨先从遍历一遍，尝试找出可能的名人候选人开始。
扫描过程中，遵循如下逻辑
```python
if knows(cand, i):    # cand 不可能是名人了，为了不错过任何一种可能，名人换成i
    cand = i
elif not knows(i, cand):  # 步入此分支，表示cand和i互不认识，此时他俩都不可能是名人，所以直接让cand变成i+1
    cand = i + 1
# 对于其他情况，可以维持cand的候选人地位
```

如此扫描一遍后，我们当然可以得到一个候选人cand。（若`cand == n`，则直接返回-1
当然，上面这样一遍扫描的逻辑判断是有很多漏洞的，所以接着我们需要对cand进行第二次验证性的扫描。

即是否对于所有`i in range(n)`且`i != cand`，都成立
`knows(i, cand) and not knows(cand, i)`。
只有符合这样要求的cand才是最终符合条件的名人。

再回过头来看，上面第一次扫描的代码，第二个分支条件其实是通过检查`i`是否认识cand来进行进一步的结果过滤。
但是实际上这个检查后面第二次扫描也会做，因此可以省去。
因此，最终的代码大概长这样：
```python
for i in range(n):
    if knows(cand, i):
        cand = i

for i in range(n):
    if i == cand: continue
    if knows(i, cand) and not knows(cand, i): continue
    return -1
```
可以看到，第一次扫描调用了n次knows，
第二次扫描调用了2n次knows（严格来说还要减去`i==cand`的两次
所以总共调用次数没有超过3n次。

#### 一点担心
看完上面的思路后，第一时间想到的一定是有一点担心：
第一遍扫描真的不会漏掉最终是正确答案的候选人吗？

其实不必担心。如果将cand和i看做两个在`range(n)`上扫描的指针。
那么，`i`是始终以稳定的速度向前进。
而`cand`始终落后与`i`的。

假设`cand`和`i`之间存在一个`k`。按照上述逻辑，`k`不可能再次被选为cand因为扫描过了。
但是不用担心因为`k`不可能是cand了。
如果`k`是cand，那么当初在`knows(cand, k)`的判断时，一定会返回True，从而cand值变成了`k`。
现在cand值既然不是`k`，说明就没有这种可能。

所以如果输入中确实存在名人，那么名人一定是上述第一次扫描最终选出的cand。
反过来，也有可能不存在名人的情况，此时仍然可以选出cand，因为第一次扫描只是check了一部分名人符合的要求。
也正是因为如此，才需要第二次扫描针对cand进行验证。