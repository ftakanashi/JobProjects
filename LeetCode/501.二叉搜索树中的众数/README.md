## 题目描述
给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。

如果树中有不止一个众数，可以按 任意顺序 返回。

假定 BST 满足如下定义：
结点左子树中所含节点的值 小于等于 当前节点的值
结点右子树中所含节点的值 大于等于 当前节点的值
左子树和右子树都是二叉搜索树

示例 1：
```
输入：root = [1,null,2,2]
输出：[2]
```
示例 2：
```
输入：root = [0]
输出：[0]
```
提示：
```
树中节点的数目在范围 [1, 104] 内
-105 <= Node.val <= 105
进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）
```

### 解法 DFS
这题倒不难。第一反应就是，既然是BST，那么自然要中序遍历。
这其实就是一个在有序（不递减）序列中求众数的问题。

哈希表的方法就不说了，直接看进阶的解法。
第一个想到的是摩尔投票，但是仔细看了下摩尔投票的题设，一般都是求唯一值，且要求比众数更严格，像`LC.169`那样是直接要求超过一半的数。

退一步想想，在一个不递减的数组里，求众数，不用哈希表，似乎直接一遍扫描然后动态维护当前的众数以及其count，
因为数字总是连成一片的出现，当发现当前数字的计数已经达到了之前众数的水平，就新加一个答案，
当超过了，那么说明之前的众数都不是众数，直接清空答案列表，然后重新加一个新的答案，这样不就行了。

以这样的思路，具体化一下算法就可以了。

具体的，从左到右（当然是树的中序遍历，而这和直接从左到右扫描也没什么差别…）扫描过程中，
维护`cand`，`count`分别表示当前正在扫描的众数候选，以及其计数值，另设一个`max_count`表示当前计数值最大的众数的计数值是多少。
扫描到一个数是，先对其进行计数判断，若和cand相同，则count加1；若不同，则count重置成1。
接着判断count和max count的关系，若count更小，则无事发生；若相等，则答案数组里加上cand；若count更大，那么情况答案数组再加上cand，同时更新max count。