## 题目描述
给定一个二叉树

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

 

进阶：

你只能使用常量级额外空间。
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。
 

示例：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png)
```
输入：root = [1,2,3,4,5,null,7]
输出：[1,#,2,3,#,4,5,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。
```

提示：
```
树中的节点数小于 6000
-100 <= node.val <= 100
```

### 解法 分层链表连接
这道题其实最简单的一个思路就是进行一个层序遍历，然后将每个层的各节点的next按照顺序连接起来就好了。
当然，层序遍历会用到一个队列，从这个意义上说并不符合题目要求常数额外空间。

注意到，要确定一层内所有节点的顺序，其实只要知道上一层的各个节点顺序就可以了。
而上一层的各个节点的顺序，其实如果是从上到下依次处理的话，已经知道了（以链表的形式保存了下来。

因此这里就可以衍生出一种常数空间的解法。
在确保上一层的各个节点已经通过next指针，以链表的形式互相串联起来了的前提下，可以维护一个上层节点遍历指针与一个本层及节点遍历指针。
上层遍历的过程中，依次检查其左、右子节点是否为空，若不是则将其与本层节点串联并继续往后维护本层指针。

在本层都串联完成后，只需要将两个指针分别往下移动一层即可。

这里可能需要稍微注意一下的是，由于可能不知道下层开头在哪里，所以更新后的本层指针可以以dummy形式出现，然后将上层指针指向的第一个节点串联进来就行。

更多请看代码注释。