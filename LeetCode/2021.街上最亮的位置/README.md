## 题目描述
一条街上有很多的路灯，路灯的坐标由数组 lights 的形式给出。 每个 lights[i] = [positioni, rangei] 代表坐标为 positioni 的路灯照亮的范围为 [positioni - rangei, positioni + rangei] （包括顶点）。

位置 p 的亮度由能够照到 p的路灯的数量来决定的。

给出 lights, 返回最亮的位置 。如果有很多，返回坐标最小的。

示例 1:
![](https://assets.leetcode.com/uploads/2021/09/28/image-20210928155140-1.png)
```
输入: lights = [[-3,2],[1,2],[3,3]]
输出: -1
解释:
第一个路灯照亮的范围是[(-3) - 2, (-3) + 2] = [-5, -1].
第二个路灯照亮的范围是 [1 - 2, 1 + 2] = [-1, 3].
第三个路灯照亮的范围是 [3 - 3, 3 + 3] = [0, 6].

坐标-1被第一个和第二个路灯照亮，亮度为2
坐标0，1，2都被第二个和第三个路灯照亮，亮度为2.
对于以上坐标，-1最小，所以返回-1
```
示例 2：
```
输入: lights = [[1,0],[0,1]]
输出: 1
```
示例 3：
```
输入: lights = [[1,2]]
输出: -1
```

提示:
```
1 <= lights.length <= 10^5
lights[i].length == 2
-108 <= position_i <= 10^8
0 <= range_i <= 10^8
```

### 解法 差分思想
连续区间的值的累计，一看就知道可以用差分数组做。
当然，这题没有明确给出数组，
或者说，如果真的构建差分数组，那么可能长度达到10^8级别。
所以，采用哈希表来代替差分数组。但是差分思想不变。

具体的，我们先遍历所有输入的路灯`[c, r]`。
将`c-r`位置对应的值+1，`c+r+1`位置对应的值-1。
接着按照差分思想，从小到大遍历所有处于哈希表中的值，并以此累加其对应的值。

如此，在这个过程中碰到的最大的累计值，所对应的位置便是所求位置。

你可能会疑惑会不会有些处于中间的位置，因为不在哈希表中而被漏掉。
我也是AC完之后才意识到这个问题…
仔细一想这不是问题，因为题目明确要求如果有相同的亮度的位置，取最左。
因此，所求位置必然是一个路灯照亮范围的左边界，因此一定在哈希表中

2021年结束啦！2022年新年快乐，终于可以回国了！