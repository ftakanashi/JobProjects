## 题目描述
在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）

现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。

返回必须翻转的 0 的最小数目。（可以保证答案至少是 1 。）

示例 1：
```
输入：A = [[0,1],[1,0]]
输出：1
```
示例 2：
```
输入：A = [[0,1,0],[0,0,0],[0,0,1]]
输出：2
```
示例 3：
```
输入：A = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]
输出：1
```

提示：
```
2 <= A.length == A[0].length <= 100
A[i][j] == 0 或 A[i][j] == 1
```

### 解法 DFS + BFS
一道少见的可以结合两种搜索模式的题。

先来理解一下题意。简单来说，地图中有两个全是1的联通分量且彼此不连通。
题目就是问，将一定数量的0改为1后可以将两个联通分量联通成一个分量，问最少改变几个0。

一开始以为用并查集做呢。还想了半天，但是其实并没有要求将一个岛上的1和另一个岛上任意一个1的连通情况。
所以没必要。

另一种思路是多源BFS。从一个岛上的所有1出发进行BFS，当BFS搜索第一次碰到了另一个岛的1，那么此时就可以直接返回最短路径了。

现在问题就是，如何辨别1是来自第一个岛还是第二个岛的。
那简单啊，用DFS预处理一波，将一个岛改成全是2就行了。

所以，整体的做法，是先用DFS将两个岛区分开，然后从其中一个多源BFS出发探索，探索最短路径到第二个岛。即可。

### 解法2 两次BFS
后半的BFS同上，而前半的实际上就是通过BFS去把第一个岛的所有位置都遍历出来。

注意需要有手段将第一个岛的位置标记一下，避免第二次BFS的时候死循环。
这个可以通过直接修改地图，将相关位置的值设置为-1来实现。

