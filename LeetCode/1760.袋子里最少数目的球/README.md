## 题目描述
给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。

你可以进行如下操作至多 maxOperations 次：

选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。
比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。
你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。

请你返回进行上述操作后的最小开销。

示例 1：
```
输入：nums = [9], maxOperations = 2
输出：3
解释：
- 将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -> [6,3] 。
- 将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -> [3,3,3] 。
装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。
```
示例 2：
```
输入：nums = [2,4,8,2], maxOperations = 4
输出：2
解释：
- 将装有 8 个球的袋子分成装有 4 个和 4 个球的袋子。[2,4,8,2] -> [2,4,4,4,2] 。
- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,4,4,4,2] -> [2,2,2,4,4,2] 。
- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,4,4,2] -> [2,2,2,2,2,4,2] 。
- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,2,2,4,2] -> [2,2,2,2,2,2,2,2] 。
装有最多球的袋子里装有 2 个球，所以开销为 2 并返回 2 。
```
示例 3：
```
输入：nums = [7,17], maxOperations = 2
输出：7
```

提示：
```
1 <= nums.length <= 105
1 <= maxOperations, nums[i] <= 109
```

### 解法 threshold二分
这题的题意稍微有点绕。
可以想象一些极端的情况。比如maxOperation给出的限制值很大很大，这就意味着我们会有足够的操作次数，来将所有球的分布情况优化到最优。
也就是说把所有球都分成1个球1个袋子的情况。

相反，如果maxOperation是0，那么我们只能返回最开始数组中的最大值。

当maxOperation适中时，就需要思考，一个什么样的标准值 可以恰好满足这个maxOperation的限制。

以示例3为例，若中间值是9，显然7不用再分，17可以分为9 + 8，也就是一次操作就可以满足要求。
类似的，如果是8，,17则需要两次操作。

在脑补一通后可以感觉到，其实可以用threshold二分来解决这个问题。

具体的，我们定义初始的left和right为`1`和`max(nums)`。
然后进行二分，check每一个mid值。check的具体逻辑是遍历所有nums，计算`(num - 1) // mid`。
之所以要减去1，是因为如果恰好整除时，比如9要分成3，操作次数并非`9 / 3 = 3`，而是两次就够了。

遍历完之后所有数的操作次数总和如果小于等于maxOperation的限制，那么就说明mid值是可行的，就说明我们可以让`r = mid - 1`。
以此类推。

一个小优化是可以事先将nums逆序排序。然后从大到小地遍历计算。一旦累计值超过了maxOperation，也就无需继续遍历，直接break即可。

不过神奇的是我这个优化完了之后还不如官方答案代码中无脑用sum来得快…
可能是Python3对于对整个数组的sum操作有所优化吧。