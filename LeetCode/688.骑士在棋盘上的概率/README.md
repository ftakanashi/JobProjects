## 题目描述
在一个 n x n 的国际象棋棋盘上，一个骑士从单元格 (row, column) 开始，并尝试进行 k 次移动。行和列是 从 0 开始 的，所以左上单元格是 (0,0) ，右下单元格是 (n - 1, n - 1) 。

象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/knight.png)

每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。

骑士继续移动，直到它走了 k 步或离开了棋盘。

返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。

示例 1：
```
输入: n = 3, k = 2, row = 0, column = 0
输出: 0.0625
解释: 有两步(到(1,2)，(2,1))可以让骑士留在棋盘上。
在每一个位置上，也有两种移动可以让骑士留在棋盘上。
骑士留在棋盘上的总概率是0.0625。
```
示例 2：
```
输入: n = 1, k = 0, row = 0, column = 0
输出: 1.00000
```
 
提示:
```
1 <= n <= 25
0 <= k <= 100
0 <= row, column <= n
```

### 解法 记忆化DFS
很明显可以用记忆化DFS做。
具体的，定义函数`dfs(step, pos)`。表示还剩下`step`步要走且骑士处于`pos`坐标位置时，其最终留在棋盘上的概率。

显然，若`pos`越界不在棋盘上，那么直接返回0即可。
另一方面，若`pos`不越界，且`step`归零，那么说明此时已经不需要再走，而骑士在棋盘上，所以返回1。

对于其他情况，则只需要依次遍历骑士下一步可能走的位置`new_pos`，然后依次调用`dfs(step - 1, new_pos)`即可。
由于此时骑士往八个方向走是等概率的，所以这每一步得到的概率都还要乘以`1/8`的权重才行。
因此，本层dfs的返回应该是`sum(dfs(step - 1, new_pos)) / 8`。

整体复杂度，由于可能会遍历到每个格子且总共要走k步，每步内部还要遍历8个方向，所以总体复杂度是`O(k * n^2 * 8)`。
若直接暴力搜会超时。
而这里没有用到任何外部的信息，因此可以直接加个记忆化。

以上思路还可以转化为DP，即声明一个`k * n * n`的DP数组，`dp[k][i][j]`表示第k步处于`i,j`位置时最终留在棋盘上的概率。
本质是一样的，就不多说了。