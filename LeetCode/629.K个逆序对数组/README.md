## 题目描述
给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。

逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对；否则不是。

由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。

示例 1:
```
输入: n = 3, k = 0
输出: 1
解释: 
只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。
```
示例 2:
```
输入: n = 3, k = 1
输出: 2
解释: 
数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。
```
说明:
```
 n 的范围是 [1, 1000] 并且 k 的范围是 [0, 1000]。
```

### 解法 DP + 优化
说实话这题就算是刷题巅峰也不一定能自己做出来…
主要难点在于如何想到一个合理的状态转移方程，以及如何将其进行优化。
这里就直接CV答案了…

首先我们将这个问题抽象化。DP数组的定义倒是不难想到。既然给出了`n`和`k`两个参数，
很明显，定义`dp[n][k]`为`1,2,...,n`范围内，恰好有`k`个逆序对的时的排列数量。
注意，这里为了处理方便，故意多加以一行`n`是0以及`k`是0的情况。
显然`dp[i][0]`都是1，而`dp[0][j>0]`都是0。

接着来看如何求任意的`dp[i][j]`。
将问题抽象化一下，也就是说现在其实我们要求的，是`1, 2, ..., i`这个范围内，恰好有`j`个逆序对的情况。
下面是重点：

我们任意从`1~i`之间选取一个数字`k`，将其放在排列的末尾。
此时，前`i-1`个数字将会是`1~k-1`以及`k+1~i`的一个排列。
那么这个排列会有几个逆序对呢？我们将其逆序对分成两类。
第一类，是有最后的数字`k`和前面的`k+1~i`个数字形成的`i - k`个逆序对。
第二类，是`1~k-1`以及`k+1~i`这些数字内部在排列中形成的逆序对。根据dp值定义，这部分的个数一定是`j - (i-k)`。

讲到这里，感觉好像还是什么问题都没有解决。第二类逆序对的个数仍然是个谜，没有办法和dp值结合起来。
接下来就是一个神来之笔：逆序对的个数，其实和数的绝对大小无关而只和相对大小有关。
也就是说，上述`1~k-1`和`k+1~i`个数形成的排列恰好有`j - (i - k)`个逆序对的情况，与`1~i-1`间形成这么多逆序对的排列的情况，完全一致。
这么一来，就对上了。选出特定的`k`之后，
```python
dp[i][j] = dp[i-1][j-(i-k)]
```

以上是选出特定`k`的情况。当然我们需要遍历`1~i`间所有数，依次将其作为`k`安排到最后。因此可以得到
```python
dp[i][j] = sum(dp[i-1][j-(i-k)] for k in range(1, i+1))
```
因为加法的交换性，可以将`m = i-k`代入上述式子，改写为
```python
dp[i][j] = sum(dp[i-1][j-m] for m in range(i))
```

这里还需要回过头关注一个问题。那就是，
`j - m`可能小于0。此时的实际意义就是，`k`是一个较小的数或者`j`是一个较小的数，一旦将`k`安排到最后，可能仅仅是第一类的个数，
就超过了限定的上限`j`。此时我们不能将其作为一种合法的可能计算进来。在代码处理上来说，直接将其当成0即可。

于是式子变成了：
```python
dp[i][j] = sum(dp[i-1][j-m] if j >= m else 0 for m in range(i))
```

到此为止，似乎一切 结束了。实际上建立DP数组后从上到下从左到右依次按照上述式子填充dp值，对于小一点的case也确实都过了。
然而稍微大一点，就gg了。
于是出现了这题的第二个神来之笔，优化。

按照常规的DP推导，我们希望`dp[i][j]`可以在`dp[i-1][j], dp[i][j-1]`之类这些周边的有限个数的值上直接推导出来，而不是像上面一样做一个`O(n)`的计算。
此时我们简单地来看下`dp[i][j]`和`dp[i][j-1]`之间的区别。
拆开上面式子后发现，
```text
dp[i][j]    = dp[i-1][j] + dp[i-1][j-1] + ... + dp[i-1][j-(i-1)]
dp[i][j-1]  = dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-1-(i-2)] + dp[i-1][j-1-(i-1)]
```
化简一下下式中的一些表达后可以发现，其实两个累加式子是刚好错开了一位。
换言之，有如下关系：
```text
dp[i][j] - dp[i-1][j] = dp[i][j-1] - dp[i-1][j-i]
```
移项：
```text
dp[i][j] = dp[i][j-1] - dp[i-1][j-i] + dp[i-1][j]
```
最后，由于`i`和`j`分别范围是`range(1, n+1)`和`range(1, k+1)`，所以下标基本没问题，唯一需要保证的是`j-i >= 0`。
如上说过的，若其小于0，就直接将dp值视为0处理即可。

至此这道题算是正式做完了。

这题，不仅是脑补出DP推导方程有着比较高的难度，而且还需要结合一些数学技巧对推导过程进行优化。
可以说是比较难的一个题了。
但是做（抄）完后神清气爽！