## 题目描述
已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 `nums = [0,1,4,4,5,6,7]` 在变化后可能得到：

若旋转 4 次，则可以得到 `[4,5,6,7,0,1,4]`

若旋转 7 次，则可以得到 `[0,1,4,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`。

给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

示例 1：
```
输入：nums = [1,3,5]
输出：1
```
示例 2：
```
输入：nums = [2,2,2,0,1]
输出：0
```

提示：
```
n == nums.length
1 <= n <= 5000
-5000 <= nums[i] <= 5000
nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转
```

进阶：
- 这道题是 寻找旋转排序数组中的最小值 的延伸题目。
- 允许重复会影响算法的时间复杂度吗？会如何影响，为什么？

### 解法 二分查找
和`LC153`挺像的。
同时也注意这两题的组合和`LC33`&`LC81`的组合很像。那边是给出target值去搜索，而这两题是搜索最小值。
本质是一样的，就是要确定在旋转之后，如何在二分查找的时候通过分类讨论确定搜索范围。

先按照常规思路考虑，当然还是考虑mid和right之间的大小关系。
若大于，则最小值肯定在右边，`left = mid + 1`。
若小于，则最小值肯定在左边，`right = mid - 1`。
若等于，考虑到`10111`和`11101`的情况，不能一概而言断定在左右哪边，因此就采用`right -= 1`的办法退化成普通遍历搜索。

按照上述思路写完之后，发现大部分test case都行，但是`10111`有点问题。
按照上述思路，搜索范围的`left, right`分别如下变化：
```text
0 4
0 3
0 0
```
问题就出在`0 3`的时候，此时mid是1，即`nums[mid]`是0的情况。
此时显然mid小于right，按照上述思路，right要等于mid - 1。这么一来正确答案的0的位置就被跳过了。

因此改良算法，考虑缩小范围的时候不使用绝对的+1-1，而是等于mid本身。即
```text
left = mid
right = mid
```
而这样做带来的一个问题是当`left == right - 1`的时候会死循环。
所以循环条件改成`while left < right - 1`。

这样最终left和right会缩小成`right == left + 1`的时候跳出循环。
此时找最小的就看两个谁更小就是谁了。