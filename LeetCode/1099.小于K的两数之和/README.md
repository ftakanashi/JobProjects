## 题目描述
给你一个整数数组 nums 和整数 k ，返回最大和 sum ，满足存在 i < j 使得 nums[i] + nums[j] = sum 且 sum < k 。如果没有满足此等式的 i,j 存在，则返回 -1 。

示例 1：
```
输入：nums = [34,23,1,24,75,33,54,8], k = 60
输出：58
解释：
34 和 24 相加得到 58，58 小于 60，满足题意。
```
示例 2：
```
输入：nums = [10,20,30], k = 15
输出：-1
解释：
我们无法找到和小于 15 的两个元素。
```

提示：
- 1 <= nums.length <= 100
- 1 <= nums[i] <= 1000
- 1 <= k <= 2000

### 解法 排序 + 双指针
和towSum一个意思。不解释。

### 解法 排序 + 二分查找
二分查找比双指针稍微复杂一些。姑且算是bisect库的练习题吧…

排序之后，遍历各个数字作为左边界并在其右边找一个合适的数。
由于要求`nums[i] + nums[j] < k`。
移项之后可知，右边界的要求应该是`nums[j] < k - nums[i]`。
不等号右边是定值，所以是求数组中一个小于定值的最大的数。

>bisect的使用注意点
>
>我们知道bisect主要有bisect_left和bisect两个二分查找方法。
>两个方法分别找的是lower bound和higher bound。
>
>分成两种情况讨论。
>若原数组中本来就存在target
>- bisect_left返回第一个target的下标
>- bisect返回最后一个target的下标+1
>
>若原数组中没有target（设target本应该位于下标是i-1和i的两个元素之间）
>- bisect_left和bisect都返回比target大的第一个数的下标即i
>
>边界情况：上述前者的bisect和后者的两方法，都可能会面临返回值等于len(nums)的情况，需要注意。

根据上述bisect的文档，应该采用`bisect_left(nums, target) - 1`作为要求的`j`。
另外由于可能`bisect_left`返回0，此时要是-1就不对了。其实返回0就代表数组中所有数都大于等于目标值，因此不成立，可以不记录答案。

最后，由于题目明确要求是两个不同下标，因此二分查找的过程中如果找到的`j`等于`i`，也不能记录答案。
