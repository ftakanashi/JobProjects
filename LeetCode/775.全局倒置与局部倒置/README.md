## 题目描述
给你一个长度为 n 的整数数组 nums ，表示由范围 [0, n - 1] 内所有整数组成的一个排列。

全局倒置 的数目等于满足下述条件不同下标对 (i, j) 的数目：
```
0 <= i < j < n
nums[i] > nums[j]
```
局部倒置 的数目等于满足下述条件的下标 i 的数目：
```
0 <= i < n - 1
nums[i] > nums[i + 1]
```
当数组 nums 中 全局倒置 的数量等于 局部倒置 的数量时，返回 true ；否则，返回 false 。

示例 1：
```
输入：nums = [1,0,2]
输出：true
解释：有 1 个全局倒置，和 1 个局部倒置。
```
示例 2：
```
输入：nums = [1,2,0]
输出：false
解释：有 2 个全局倒置，和 1 个局部倒置。
```
 
提示：
```
n == nums.length
1 <= n <= 5000
0 <= nums[i] < n
nums 中的所有整数 互不相同
nums 是范围 [0, n - 1] 内所有数字组成的一个排列
```

### 解法 一次遍历
不难发现，若存在一个全局倒置，则至少存在一个局部倒置。
也就是说全局倒置的数量绝对不小于局部倒置。

这种情况下要让两者相等，只有一种情况，就是在从小到大有序排列的基础上，只允许相邻的两个位置交换。
比如`0 1 2 3 4`作为基础，
`0 2 1 4 3`是符合要求的。但是`0 1 4 3 2`不符合要求。

于是就简单了。一次遍历过去，当碰到某个位置`i`的数值不等于`i`时，就检查`i+1`位置是不是`i`，以及`i`位置是不是`i+1`。
仅当这两个条件都符合时，才能继续向下遍历。