## 题目描述
给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。

注意：1 ≤ k ≤ n ≤ 109。

示例 :
```
输入:
n: 13   k: 2

输出:
10

解释:
字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
```

### 解法 字典树(思想) + 二分查找
听说这题是字节常考题。

首先最朴素暴力思想，是将1到n所有数字转换成字符串形式然后排序。这种做法首先肯定会用到大量空间，其次排序整体也还需要O(nlogn)的时间。

然后，这类字典序的题目其实可以联想到字典树，具体到数字这就是一个十叉树。
具体的，每个节点代表一位，而其最多可以有十个子节点，每个子节点分别代表其后加上一个0,1,2...,9的数字。

如此，当建立起这个树之后，很容易就发现，其实要求字典序第k小的数，其实就是找这棵树的前序遍历中第k个值。
（当然根节点不算，参考这个图：![](https://pic.leetcode-cn.com/8bb3eab39d780d4bb3f4962ca805a3311f3acc46d3bbd0a7e3f7e057a706cb19-image-20200314171628883.png))

于是第二个想法：通过前序遍历获得答案。
但是显然，为了前序遍历，你肯定要构建起整棵树，这导致仍然需要使用O(n)的空间。

观察构建起的这棵十叉树你会发现，这是一个完全十叉树，因此其中还有规律可循。
具体的，只要n确定，就可以只通过O(1)的确定某个节点和其右边的兄弟节点，在前序遍历序列中中间隔了多少个节点。
换言之，只要求出以这个节点为根的这棵子树的总结点数即可。

这个信息有用在哪呢？
以示例和上面的图为例，当我来到1时，接下来我还要走`rest = k-1`步就会到达要求的位置。
此时，计算得，从1走到2要走5步，如果`rest > 5`，说明要求的节点不可能是1下面的某个节点，此时可以将指针直接指向2，
同时别忘了更新`rest -= 5`。
相反如果`rest < 5`，则说明要求的节点没有走到2，而是在1下面。此时首先可以排除1，然后走到10这个节点继续上述检查。此过程中`rest -= 1`。
如果恰好此时`rest == 5`，那么不用说，要求的节点就是2，所以直接返回即可。

以上规律某种意义上是在不断缩小可探索范围，算是一种二分吧，可以以O(logk)的速度找到第k小的节点。

接下来的问题就是，如何在O(1)时间内计算根节点为节点x的子树的节点总数了。
这里我们不用树的递归性质，而是按层一层一层递推计数。(递归超时了)
注意到，对于这个子树中任意一层最左边的节点，当`x * 10 <= n`即当前节点还有子节点，说明x右边有足够的`10^m`个兄弟节点，m从第一层的取值0，随后逐渐增长。
相反，如果某一层的`x * 10 > n`了，说明这是最后一层，同时也说明其右边已经没有完整的`10^m`个兄弟节点。
此时其右边总共的节点数是`n - num + 1`。但是还需要考虑一个特殊情况，就是x节点所在层本身就不完整时，此时不应该返回`n - num + 1`，
而是只返回1，为了和上面描述能统一，这里写成`min(10^m, n-num+1)`的形式。

至此，所有思路都可以了。写代码。