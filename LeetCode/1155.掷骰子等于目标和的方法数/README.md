## 题目描述
这里有 n 个一样的骰子，每个骰子上都有 k 个面，分别标号为 1 到 k 。

给定三个整数 n ,  k 和 target ，返回可能的方式(从总共 kn 种方式中)滚动骰子的数量，使正面朝上的数字之和等于 target 。

答案可能很大，你需要对 109 + 7 取模 。

示例 1：
```
输入：n = 1, k = 6, target = 3
输出：1
解释：你扔一个有 6 个面的骰子。
得到 3 的和只有一种方法。
```
示例 2：
```
输入：n = 2, k = 6, target = 7
输出：6
解释：你扔两个骰子，每个骰子有 6 个面。
得到 7 的和有 6 种方法：1+6 2+5 3+4 4+3 5+2 6+1。
```
示例 3：
```
输入：n = 30, k = 30, target = 500
输出：222616187
解释：返回的结果必须是对 109 + 7 取模。
```

提示：
```
1 <= n, k <= 30
1 <= target <= 1000
```

### 解法 DP
一个典型的背包问题。
构建DP数组，size为 `k * target`，其中`dp[i][j]` 表示使用`i`个骰子得到目标和为`j`的方法数。
初始化为`dp[0][0] = 1`。

递推过程中，面对`dp[i][j]`，我们可以使用来自`dp[i-1]`的信息。
遍历所有单个骰子贡献值的可能性为 `num` ，我们只需找 `j - num` 对应的方案数即可。

换言之 `dp[i][j] = sum(dp[i-1][j-num] for num in range(1, k+1))`。

当然前提条件是 `j - num >= 0`。

按照上述思路DP即可。
别忘了取余。
另外由于只需要`dp[i-1]`信息，所以实际上还可以做状态压缩优化。不过今天没啥时间就不写了。