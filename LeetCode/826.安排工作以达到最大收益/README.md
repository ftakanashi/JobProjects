## 题目描述

你有 n 个工作和 m 个工人。给定三个数组： difficulty, profit 和 worker ，其中:
```
difficulty[i] 表示第 i 个工作的难度，profit[i] 表示第 i 个工作的收益。
worker[i] 是第 i 个工人的能力，即该工人只能完成难度小于等于 worker[i] 的工作。
```
每个工人 最多 只能安排 一个 工作，但是一个工作可以 完成多次 。

举个例子，如果 3 个工人都尝试完成一份报酬为 $1 的同样工作，那么总收益为 $3 。如果一个工人不能完成任何工作，他的收益为 $0 。
返回 在把工人分配到工作岗位后，我们所能获得的最大利润 。

示例 1：
```
输入: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]
输出: 100 
解释: 工人被分配的工作难度是 [4,4,6,6] ，分别获得 [20,20,30,30] 的收益。
```
示例 2:
```
输入: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]
输出: 0
```

提示:
```
n == difficulty.length
n == profit.length
m == worker.length
1 <= n, m <= 104
1 <= difficulty[i], profit[i], worker[i] <= 105
```


### 解法1 贪心 二分查找
题目意思挺好理解的。一句话，就是找到每个工人在可承担范围内收益最大的job即可。

第一个想到的思路，是优先找出某个工人能承担的最大难度的Job是什么。显然我们只需要将difficulty和profit联合排序后，用二分查找就可以找到。

找到某个job后，需要注意其并不一定是最优解，因为可能有难度更低但是收益更大的job。

而在难度有序的情况下，实际上找到：某个难度以下的最大收益，是可以提前通过一次遍历获取的。因此我们额外维护一个`max_profit`数组，
`max_profit[i]`就表示了下标为前`i`的job能够收获到的最大收益值。

于是第一个解法就完成了。能AC，效率不是很高。

### 解法2 贪心 双指针
注意到上述解法1，本质上还是把每个worker单独拆分开来看的。而实际上对worker本身的顺序也是可以利用的。
比如我们将worker也从小到大进行排序后：

分别维护两个指针`i, j`，扫描worker和job（difficulty和profit的结合）。

对于`worker[i]`来说，只要当前的`job[j].difficulty`还小于他的能力，我们就可以尝试向右扩展`j`的边界，探索其能承受的最大难度。
同时这个过程也可以记录下当前能收获到的最大profit。

然后`i`也右移。此时，更大能力的`worker[i]`无需将`j`向左移动，因为之前对job的所有扫描操作也都还是有效的。

于是这个做法就可以在线性时间内完成扫描了（当然由于对两个数组的预先排序，整体的复杂度还是  `O(mlgm) + O(nlgn)`
