## 题目描述
给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。

规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。

请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。

提示：
- 输出坐标的顺序不重要
- m 和 n 都小于150
 

示例：
```
给定下面的 5x5 矩阵:

  太平洋 ~   ~   ~   ~   ~ 
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * 大西洋

返回:

[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).
```

### 解法 DFS
基本可以想到用BFS或者DFS来做。这里我们用DFS。
此外，我们的DFS并不是顺着水流方向探索，而是从入海口逆着探索。
换言之，我们从每个太平洋入海口出发开始DFS，严格按照逆着水流的方向探索，把每一个能够达到的位置，都打上"可以达到太平洋"这样一个标记。
同理，从大西洋入海口也做类似探索。
最终所有探索做完后，扫描整个数组，找出那些同时有两个标记的位置即可。

具体的，我们用两个位表示流入大西洋和太平洋的状态。
即，若两个大洋都流不到，为0，能流到太平洋为1，流到大西洋为2(b10)，两个都流得到为3(b11)。
构建一个flags数组表示每个位置的状态，初始化全是0。

接着构建dfs函数，由于要区别两个大洋，搞清当前我们在为哪个大洋探索，
因此涉及函数时加上一个参数flag，1表示太平洋，2表示大西洋。
在函数中，我们针对当前位置`i,j`，进行`flags[i][j] |= flag`，接着向四周探索。
只有下标合法，且height大于等于当前位置时才能dfs进去。

因为有等于的情况，为了避免循环探索，还需要给dfs函数加上一个seen。
此外，若下一个位置的flag位置已经是1，即`flags[x][y] & flag > 0`，此时可以不用再探索，因为之前已经探过了。

按照以上思路，写代码。
在外围，我们针对所有太平洋入海口进行`dfs(x, y, 1)`，针对所有大西洋入海口进行`dfs(x, y, 2)`。
最后统计所有位置，看那些位置的flag是3即可。