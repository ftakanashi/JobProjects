## 题目描述
给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，
找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。
 

示例 1：
![](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)
```
输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。
```
示例 2：
```
输入：board = [["X"]]
输出：[["X"]]
```

提示：
```
m == board.length
n == board[i].length
1 <= m, n <= 200
board[i][j] 为 'X' 或 'O'
```

### 解法 BFS
显然可以用DFS或者BFS做。这里采用BFS。

一个最简单的想法，就是依次遍历矩阵中各个位置。当碰到一个O时，就从此地开始BFS探索和其相连的所有位置，也就是找到这个位置所处的区域。
注意为了不把一块区域从不同的位置出发探索好几遍，需要在整个循环外面设置一个seen，并且BFS过程中将已经访问过的位置入seen。
这样，一个区域就只会被探索一遍。

针对一个区域，探索过程中看是否有任意一格处于边缘（即其上下左右任意一格越界），如果越界了，那么说明这个区域中的O是不能被改变的。
用一个全局通用的数据结构比如哈希集记录这些位置的结果。

BFS全部完成后，将哈希集中记录到的那些位置的除外，其余O改成X就行了。


其实还可以更加直接一点的思路。
那些没有被包围的区域，其实就是指从边缘上一格可以探索到的区域。
那就很简单了，遍历所有边缘上的O，并从其开始BFS探索所有不被改变的区域。
进一步节省空间，可以不要用额外的哈希集什么的，直接将这些位置改成一个除了OX外的值，比如T。

从所有可能的边缘格出发的探索都结束后，最后遍历一遍矩阵，把所有O改成X，所有T改回O即可。