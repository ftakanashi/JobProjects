## 题目描述
Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3  种类型的边：

- 类型 1：只能由 Alice 遍历。
- 类型 2：只能由 Bob 遍历。
- 类型 3：Alice 和 Bob 都可以遍历。

给你一个数组 edges ，其中 `edges[i] = [typei, ui, vi]` 表示节点 ui 和 vi 之间存在类型为 typei 的双向边。

请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。

如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。

返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1 。

示例 1：

```
输入：n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]
输出：2
解释：如果删除 [1,1,2] 和 [1,1,3] 这两条边，Alice 和 Bob 仍然可以完全遍历这个图。再删除任何其他的边都无法保证图可以完全遍历。所以可以删除的最大边数是 2 。
```
示例 2：

```
输入：n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]
输出：0
解释：注意，删除任何一条边都会使 Alice 和 Bob 无法完全遍历这个图。
```
示例 3：

```
输入：n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]
输出：-1
解释：在当前图中，Alice 无法从其他节点到达节点 4 。类似地，Bob 也不能达到节点 1 。因此，图无法完全遍历。
```

提示：
- 1 <= n <= 10^5
- 1 <= edges.length <= min(10^5, 3 * n * (n-1) / 2)
- edges[i].length == 3
- 1 <= edges[i][0] <= 3
- 1 <= edges[i][1] < edges[i][2] <= n
- 所有元组 (typei, ui, vi) 互不相同

### 解法 并查集
这题有点意思。解题的核心算法或者说数据结构，显然是并查集。
只是第一个问题在于，如何利用并查集找出一个连通图最多可以删去几条边。

这个问题是这样的：构建并查集的过程中，每发生一次union操作，如果这次操作目标的两个节点本来就已经在一个连通分量中，
那么说明这条边是多余的，因此也就可以删除这条边。
换句话说，并查集中可以维护一个remove_edge的计数，每发生上述情况一次，就加1。

等并查集构建完成后，这个计数就是我们想要知道的，最多可以删除几条边了。

解决以上问题后，再来看题目本身。

当某两个节点之间既有公用边，也有Alice (or 或者 and) Bob的独占边，那么此时必然要删除一条。但显然，删除独占边带来的风险更小，因此应该优先删除独占边。

反过来说，在构建并查集的时候，应该优先构建基于公用边的图。这一点十分关键。
当基于公用边的图构建完成后，再分别构建基于Alice独占边和Bob独占边的图。
注意由于一个人的边不能被另一个人所用，为了避免混淆，这里可能需要两个并查集副本。

最终构建完的Alice图和Bob图，必须分别都是连通的才不返回-1。返回的，应该是Alice并查集的remove_edge数加上
Bob并查集的remove_edge数，注意如果公用边并查集的remove_edge已经不为0，说明仅靠公用边，两者就已经都可以遍历全图了，
这种情况下公用边并查集的remove_edge会被算两边，因此还要减去他。