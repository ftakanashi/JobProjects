## 题目描述
你正在参加一个多角色游戏，每个角色都有两个主要属性：攻击 和 防御 。给你一个二维整数数组 properties ，其中 properties[i] = [attacki, defensei] 表示游戏中第 i 个角色的属性。

如果存在一个其他角色的攻击和防御等级 都严格高于 该角色的攻击和防御等级，
则认为该角色为 弱角色 。

更正式地，如果认为角色 i 弱于 存在的另一个角色 j ，那么 attackj > attacki 且 defensej > defensei 。

返回 弱角色 的数量。

示例 1：
```
输入：properties = [[5,5],[6,3],[3,6]]
输出：0
解释：不存在攻击和防御都严格高于其他角色的角色。
```
示例 2：
```
输入：properties = [[2,2],[3,3]]
输出：1
解释：第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。
```
示例 3：
```
输入：properties = [[1,5],[10,4],[4,3]]
输出：1
解释：第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。
```

提示：
```
2 <= properties.length <= 105
properties[i].length == 2
1 <= attacki, defensei <= 105
```

### 解法1 排序 + 单调栈
这题本质上是一道花式排序的题目，和`LC.354`有点像。

因为要判断输入数组元素间大小关系，所以一个很自然的想法是先排个序再一次扫描做判断。
由于每个元素有两个维度，参考`LC.354`的想法，尝试着按第一个维度正序，第二个维度逆序排序。

扩充一下示例3，我们写出下面这样一个排完序的例子：
```text
1,5
1,3
1,2
1,1
4,5
4,3
10,4
```
根据题意，这个例子的答案是4，弱角色包括了`1,3`,`1,2`,`1,1`,`4,3`这四个。
显然，在从上往下扫描这个排好序的序列时可以发现，攻击力这个维度始终是不递减的。
按照攻击力把角色分成不同的组的话，那么只要在遍历过程中，发现换组了（攻击力发生变化了），此时这个角色的防御力是其组中最大的，
只要去看这个防御力值再上一个组中的位置，上一个组中那些防御力比当前角色小的，都是弱角色。
比如扫描到`4,5`时，就可确认`1,3`,`1,2`,`1,1`都是弱角色。

这个机制，第一时间很容易想到二分，但是二分还要维护某个角色是否已经被统计过，因此换想到了单调栈。

具体的，算法就是扫描上述排序好的序列，并且维护一个单调栈。
当扫描到某个角色`a,d`时，只要栈顶角色`a0, d0`的攻击力和防御力都严格小于当前角色即`a0 < a and d0 < d`，那么就持续pop出栈顶。
而pop出来的每个角色都是一个弱角色。
正如上面所说，由于攻击力是不递减的，事实上若`d0 < d`成立，则必然有`a0 < a`，因此条件可以进一步简化。
最后别忘了把当前角色入栈。

按照上述想法就可以写出AC代码了。

### 解法2 排序 + 一次扫描
上面的算法，有种先将角色记录下来以观后效，当后面发现了有更强的角色，可以实锤记录下来的角色是弱角色时再将他们作为答案记录下来，
有种"反悔"的意思。
这也是我们用了栈这种可以pop的数据结构的原因。

那么有没有什么不反悔的办法呢？
既然后面的角色可以实锤前面的角色是弱角色，那么反过来遍历不就行了。

具体的，解法1中的那个排序完的序列，我们从下往上进行遍历。
在这样的过程中，攻击力是不递增的。同时由于防御力是不递减的，因此只要确定之前扫描过程中防御力的最大值，
若其大于当前角色防御力，那么就可以确定当前角色是个弱角色。