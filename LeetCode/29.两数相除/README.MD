## 题目描述
给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 dividend 除以除数 divisor 得到的商。

整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2

示例 1:
>输入: dividend = 10, divisor = 3
>
>输出: 3
>
>解释: 10/3 = truncate(3.33333..) = truncate(3) = 3

示例 2:
>输入: dividend = 7, divisor = -3
>
>输出: -2
>
>解释: 7/-3 = truncate(-2.33333..) = -2
 

提示：
- 被除数和除数均为 32 位有符号整数。
- 除数不为 0。
- 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。

### 解法 递归+logn查找
首先确定一个大前提，正负号在这里处理不复杂。完全可以事先预判两个数是否异号从而得知最终结果的正负性。
因此为了处理方便，下面说明都默认两个数都是正数。

既然不能用乘除法，那么只能考虑用加法了。

一个很朴素的思想就是，我不断地`divisor += divisor`，并且计数。相当于用加法实现乘法。

不过这样，假设最终结果是n的话那么显然复杂度是O(n)的。于是想到了和`LC50.pow(x,y)`类似的思路，可以通过用已经算出的结果来指数级地逼近被除数。

比如示例1中的10和3。
我先算出3+3=6，然后不是6+3=9而是6+6=12。之后12+12=24，以此类推。可以写出一个类似下面的表：
```text
n   i
3   1
6   2
12  4
24  8
...
```
那么这个表有什么用呢。别忘了我们的目的是逼近dividend。所以如果被除数是10的话，显然在n=12,i=4的时候已经过站了。

此时，答案必然是小于等于当前i=4并大于上一个i=2。

这里刚好i只有一个答案3了，如果区间再宽一点，那么我们就需要确定区间中到底是哪个值。
如果这里又线性扫描了那和最开始的O(n)想法就没什么区别了。

其实继续使用这种"叠加"的思想，既然答案肯定大于上一个i=2，那么就把10减去上一个n=6，剩余的（4）递归地再计算商，然后加到i=2上。

如此递归直到剩余的值比除数小，自然就返回0了。

按照此思路写代码即可。最后别忘了越界处理。