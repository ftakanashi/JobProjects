## 题目描述
给定一个以字符串表示的任意嵌套的三元表达式，计算表达式的值。你可以假定给定的表达式始终都是有效的并且只包含数字 0-9, ?, :, T 和 F (T 和 F 分别表示真和假）。

注意：
```
给定的字符串长度 ≤ 10000。
所包含的数字都只有一位数。
条件表达式从右至左结合（和大多数程序设计语言类似）。
条件是 T 和 F其一，即条件永远不会是数字。
表达式的结果是数字 0-9, T 或者 F。
```

示例 1：
```
输入： "T?2:3"

输出： "2"

解释： 如果条件为真，结果为 2；否则，结果为 3。
```

示例 2：
```
输入： "F?1:T?4:5"

输出： "4"

解释： 条件表达式自右向左结合。使用括号的话，相当于：

             "(F ? 1 : (T ? 4 : 5))"                   "(F ? 1 : (T ? 4 : 5))"
          -> "(F ? 1 : 4)"                 或者     -> "(T ? 4 : 5)"
          -> "4"                                    -> "4"
 
```
示例 3：
```
输入： "T?T?F:5:3"

输出： "F"

解释： 条件表达式自右向左结合。使用括号的话，相当于：

             "(T ? (T ? F : 5) : 3)"                   "(T ? (T ? F : 5) : 3)"
          -> "(T ? F : 3)"                 或者       -> "(T ? F : 5)"
          -> "F"                                     -> "F"
```

### 解法 栈
很明显的用栈的题目，示例3是一个很好的用来设计算法的例子。

由于三元表达式从右到左结合，所以输入字符串从右到左扫描。
扫描过程中，碰到冒号当然是直接跳过，碰到数字当然是直接入栈（由于保证数字只有一位，所以还简化了扫描的逻辑）。

对于碰到T和F的情况，由于其可能是第一元，所以不能急着判断。
事实上，对于第一元，不用看元本身，而是看问号。
扫描到问号时，可以确定下一个必然是第一元。

而确定了第一元之后就简单了。由于题目明确了第一元只可能是T或者F，
若是T就选择栈顶的第二元，若是F就选择栈次顶的第三元。
选择完后将栈连续pop两次，然后将刚才选择的结果再次入栈。

依次类推不断进行扫描，直到输入字符串扫描完成，此时栈内必然只剩下一个字符，将其返回即可。