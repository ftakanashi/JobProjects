## 题目描述

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1:
>输入: [1,2,3,4,5,6,7] 和 k = 3
>
>输出: [5,6,7,1,2,3,4]
>
>解释:
>
>向右旋转 1 步: [7,1,2,3,4,5,6]
>
>向右旋转 2 步: [6,7,1,2,3,4,5]
>
>向右旋转 3 步: [5,6,7,1,2,3,4]

示例 2:
>输入: [-1,-100,3,99] 和 k = 2
>
>输出: [3,99,-1,-100]
>
>解释: 
>
>向右旋转 1 步: [99,-1,-100,3]
>
>向右旋转 2 步: [3,99,-1,-100]

说明:
>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
>
>要求使用空间复杂度为 O(1) 的 原地 算法。

### 前言
有两点很明显的点。

1. 如果原数组为空，则直接返回
2. 如果k大于原数组长，那么移动步数与`k % len(nums)`等效。

这两点可以在任何一种解法的前面都写上。

### 解法1 使用了少数额外空间的办法
第一个想到的解法，既然要求O(1)空间，开一个和原数组等长的缓存显然不靠谱，但一开始觉得k这个数字是个常数。

于是，想法是，开一个长k的数组用于保存原数组后k位要前移的内容。然后把前面部分后移。
后移通过从末尾开始扫描的双指针实现。

最后把缓存中最开始保存下来的那个片段，给塞到原数组最开始的地方。这样就完成了。

但是写完代码之后一想才发现，娘希匹的，k不是常数啊。

因为k最大可以是`len(nums) - 1`，所以本质上还是一个O(n)的空间。

不过反过来说，case里大概k都是比较小的吧，所以严格来说O(k)空间还比O(n)空间稍微好那么一点。。

### 解法2 环形替换
最开始的时候想过这个办法，因为先写了上面解法的代码就没深入想。

其实，写一组数据比如`[1,2,3,4,5], 3`，按照最朴素的旋转思路去模拟。
1放到4的位置，4放到2的位置（越界就从头来），2放到5的位置……以此类推，可以直接
获得旋转完的数组。按照这个思路也可以来。

不过，这里要考虑一点特殊情况。
比如`[1,2,3,4,5,6]`和`k=2, 3, 4`的情况，都会发生
数字被分成了几组。比如`k=2`时，从1出发的替换流程是，1替换到3，3替换到5，5替换到1，发生了头咬尾巴的情况。
此时如果跳出则不是所有数字都完成了处理。

这种情况，只能按组依次处理。比如从1开始的替换完成一轮之后，接下来开始从2开始的替换流程。

那么怎么才能判断所有元素都已经完成了替换呢。最开始能想到的办法就是事先求出有"几组"数据了。
但是有点困难。因为比如对于6个元素的上面数组，k=4也是可以的。

另一方面，可以简单粗暴地记录每个数字是否经历过替换。第一想到的是整一个checked数组。但是不能用额外空间。

**注意到，每个元素是否经历过替换就是一个0/1 flag，这种情况，只要count，就可以了！**

因此，大体结构出来了。

外层循环从第一个元素开始依次向后（为了找"组"的开头）

内层循环，根据+k+k的规则不断向后替换，直到"头咬尾巴"现象出现。同时每进行一次向后替换，
维护count++。

当某次内存循环结束后，count刚好等于全数字个数，那就跳出外层循环。

### 解法3 使用反转的脑筋急转弯
其实有想到一点反转原数组然后干点什么事。但是没有往后想。

这个办法挺聪明的，不解释：
```text
1 2 3 4 5 6 7
-> 反转
7 6 5 4 3 2 1
-> 前k个反转
5 6 7 4 3 2 1
-> 后n - k个反转
5 6 7 1 2 3 4
```

