## 题目描述
使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：
- 如果字符串的长度为 1 ，算法停止
- 如果字符串的长度 > 1 ，执行下述步骤：
>
>在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。
>
>随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。
>
>在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。
>
>给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。

示例 1：
```
输入：s1 = "great", s2 = "rgeat"
输出：true
解释：s1 上可能发生的一种情形是：
"great" --> "gr/eat" // 在一个随机下标处分割得到两个子字符串
"gr/eat" --> "gr/eat" // 随机决定：「保持这两个子字符串的顺序不变」
"gr/eat" --> "g/r / e/at" // 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割
"g/r / e/at" --> "r/g / e/at" // 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」
"r/g / e/at" --> "r/g / e/ a/t" // 继续递归执行此算法，将 "at" 分割得到 "a/t"
"r/g / e/ a/t" --> "r/g / e/ a/t" // 随机决定：「保持这两个子字符串的顺序不变」
算法终止，结果字符串和 s2 相同，都是 "rgeat"
这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true
```
示例 2：
```
输入：s1 = "abcde", s2 = "caebd"
输出：false
```
示例 3：
```
输入：s1 = "a", s2 = "a"
输出：true
```

提示：
```
s1.length == s2.length
1 <= s1.length <= 30
s1 和 s2 由小写英文字母组成
```

### 解法 记忆化DFS
这题看着很复杂，题目分组也是困难级别的，但是其实没那么难。
就是一个简单的记忆化dfs的套路，就看能不能想到并且大胆地用代码实现了。

在对示例进行初步考察后发现，其实`s2`要是`s1`的扰乱字符串的话，那么最基本的一个条件就是，
可以在`s1`中找到某个分割点`p`，使得其符合下列两个条件中的任意一个：
1. `s1[:p]`和`s2[:p]`互为对方一个排列 且 `s1[p:]`和`s2[p:]`互为对方的一个排列
2. `s1[:p]`和`s2[-p:]`互为对方的一个排列 且 `s1[p:]`和`s2[:-p]`互为对方的一个排列。

这里两种情况分别对应了题目的算法描述中的"不交换"和"交换"两种情况。
只要符合两个条件中的任意一个，就可以递归地判断分出来的`s1`和`s2`的两个子串。

而互为对方的一个排列这个判断也不用想得太复杂，直接一个`Counter(a) == Counter(b)`就完事了。

有了以上想法之后，写DFS就容易多了。
注意DFS的递归终止条件是什么.
当递归分割进行到很后期，当`s1`和`s2`的长度都是1时，只要返回`s1 == s2`即可。这就是终止条件。

最后，当然因为字符串一长，会重复进行很多分割点的判断，果然就超时了。
用记忆化来解决这方面的问题即可。

以上

>一个编码的小技巧，用`from functools import lru_cache as cache`。
>而后用`@cache`装饰器即可自动实现记忆化机制，不用手动写mem了。
>我给出的答案代码中虽然还是手动写了…

>另一个编码小技巧，慎用elif。
>
>最开始我完全按照上述文字的思路，在dfs函数中写了类似以下逻辑：
>```text
>if s1左和s2左相似 and s1右和s2右相似:
>    if dfs(s1左, s2左) and dfs(s1右, s2右):
>        return True
>elif s1左和s2右相似 and s1右和s2左相似:
>    if dfs(s1左, s2右) and dfs(s1右, s2左):
>        return True
>```
>然后在某些case上出现问题，还看不出bug在哪因为这题逻辑复杂很难用输入脑补。
>
>后来发现问题在第二个分支的elif上。其实这块代码的上下两个分支应该是完全并列的关系，
>但是如果用了elif就导致进入第一个分支后，分支内部的dfs判断没通过。此时应该进入大的第二个分支，但是因为是
>elif，不会进入，就gg了。
>
>elif修改成普通if后代码通过。
>我给出的答案代码中没有按上述模式写，而是将判相似的过程写在了寻找切分点之前。
>更加清晰好懂。