## 题目描述
有台奇怪的打印机有以下两个特殊要求：

打印机每次只能打印由 同一个字符 组成的序列。

每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。
给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。

示例 1：
```
输入：s = "aaabbb"
输出：2
解释：首先打印 "aaa" 然后打印 "bbb"。
```
示例 2：
```
输入：s = "aba"
输出：2
解释：首先打印 "aaa" 然后在第二个位置打印 "b" 覆盖掉原来的字符 'a'。
```

提示：
```
1 <= s.length <= 100
s 由小写英文字母组成
```

### 解法 DP
一开始看到这题，知道要用DP。
但是我死抓着"`s[i] == s[i-1]`时`dp[i] = dp[i-1]`这一点不放，一直在想一维的DP。
最终当然是没有找到什么好的办法。
主要问题还是在于状态转移方程中，上述`s[i] == s[i-1]`时虽然很方便，但是`s[i] != s[i-1]`时情况过于复杂。

于是看答案……
然后察觉到这道题原来和判最长回文有千丝万缕的联系。说到这其实DP数组已经不难构造了。
构造二维DP数组，`dp[i][j]`表示字符串`s[i:j+1]`这个子串最少需要打印几次。

接下来是状态转移方程。
这题状态转移方程稍微有点tricky。可以感觉到这个方程要根据`s[i] == s[j]`这个条件分类讨论。

在`s[i] == s[j]`时，受到回文串那题的思路影响，很容易下意识地将`dp[i][j]`与`dp[i+1][j-1]`联系起来。
实际上，如果将`s[i]`和`s[j]`同时排除在考虑范围之外的话，那还得看期间夹的那些字母是否和这两个相同等，复杂得很。
其实如果`s[i] == s[j]`，例如其值是a吧，那么说明至少我可以一口气从`i`全打印a到`j`。
换言之，这个前提下`dp[i][j]`其实就等于`dp[i][j-1]`，因为一旦`s[i] == s[j]`成立，有了`s[i]`后顺便就可以打印`s[j]`，
不会产生任何的额外打印次数。

另一方面，如果`s[i] != s[j]`，首先可以明确的一点是`i:j+1`子串至少需要打印两次，而这和打印的分割点有关系。
比如`aaabbb`在中间切开则只需要打印两次，否则更多；而如果是`aaaaab`的话则又不一样。
于是，我们可以枚举分割点，将子串分割成两个更小的子串并且将更小子串的dp值相加。取所有组合中的最小值。
即
```text
dp[i][j] = min(dp[i][k] + dp[k+1][j] for k in range(i,j))
```

综上，状态转移方程如下：
```python
if s[i] == s[j]:
    dp[i][j] = dp[i][j-1]
else:
    dp[i][j] = min(dp[i][k] + dp[k+1][j] for k in range(i,j))
```
显然，初始状态是所有的`dp[i][i] = 1`。

有了以上方程后，还需要注意，遍历不能按部就班地从上到下从左到右。
注意到，只需要关心dp矩阵的右上半个矩阵，并且初始值是对角线全是1，自然就想到，这是个斜向遍历的过程。
写了一下发现，确实以上状态转移方程中确定`dp[i][j]`可能用到的东西在斜向遍历时是没问题的。

最后注意返回的不是`dp[-1][-1]`，而是`dp[0][-1]`