## 题目描述
给你一个大小为 m x n 的二进制网格 grid 。网格表示一个地图，其中，0 表示水，1 表示陆地。最初，grid 中的所有单元格都是水单元格（即，所有单元格都是 0）。

可以通过执行 addLand 操作，将某个位置的水转换成陆地。给你一个数组 positions ，其中 positions[i] = [ri, ci] 是要执行第 i 次操作的位置 (ri, ci) 。

返回一个整数数组 answer ，其中 answer[i] 是将单元格 (ri, ci) 转换为陆地后，地图中岛屿的数量。

岛屿 的定义是被「水」包围的「陆地」，通过水平方向或者垂直方向上相邻的陆地连接而成。你可以假设地图网格的四边均被无边无际的「水」所包围。

 
示例 1：

![](https://assets.leetcode.com/uploads/2021/03/10/tmp-grid.jpg)
```
输入：m = 3, n = 3, positions = [[0,0],[0,1],[1,2],[2,1]]
输出：[1,1,2,3]
解释：
起初，二维网格 grid 被全部注入「水」。（0 代表「水」，1 代表「陆地」）
- 操作 #1：addLand(0, 0) 将 grid[0][0] 的水变为陆地。此时存在 1 个岛屿。
- 操作 #2：addLand(0, 1) 将 grid[0][1] 的水变为陆地。此时存在 1 个岛屿。
- 操作 #3：addLand(1, 2) 将 grid[1][2] 的水变为陆地。此时存在 2 个岛屿。
- 操作 #4：addLand(2, 1) 将 grid[2][1] 的水变为陆地。此时存在 3 个岛屿。
```
示例 2：
```
输入：m = 1, n = 1, positions = [[0,0]]
输出：[1]
```

提示：
```
1 <= m, n, positions.length <= 10^4
1 <= m * n <= 10^4
positions[i].length == 2
0 <= ri < m
0 <= ci < n
```
```
进阶：你可以设计一个时间复杂度 O(k log(mn)) 的算法解决此问题吗？（其中 k == positions.length）
```

### 解法 并查集
很显然，这题最朴素的解法，就是构建一个`O(m*n)`的地图，然后参考`LC.200`的解法进行一次DFS之类的。
这样的话，显然复杂度会达到`O(kmn)`。而且想都不用想就知道，会有大量重复的计算。

于是想到两方面的优化。
第一，能不能不要每次都遍历一次地图去确定岛屿数量？关于这一点，想到了是不是可以用`LC.200`中也提到的并查集做法？
彼时，并查集显得有些过于重量级了，但是这题可能恰好可以用。
第二，用哈希集来代替整个地图，优化空间。

这次，我们实现的并查集，带有实时统计图中连通分量个数的功能。
具体的也十分简单，在进行find的时候，如果输入的某个节点不存在于当前图中，自然会增加一个连通分量，因此加1；
反之，如果某次union后进入了`root_x != root_y`的分支，那么显然会进行一次合并，连通分量个数减1。

至于哈希集就不用多说了。
在外围，我们遍历每个position。扫描到某个位置时，首先将这个位置加入并查集（一次find操作即可）。
接着，扫描其四周是否有已经变成陆地的位置，即判断四周某个位置是否在哈希集中。若有，那么进行一次union。
最后将本位置加入哈希集。

以上，针对长度为k的数组positions，我们一共进行了k次扫描。
而每次扫描内部，本质上都是调用了并查集的O(logn)的find方法，因此整体复杂度就是`O(k log(mn))`。
（实现时我们将点的二维坐标转化为一维加入并查集，所以对并查集来说`n = 二维矩阵面积即m*n`。