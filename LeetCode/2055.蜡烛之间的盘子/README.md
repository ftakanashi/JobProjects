## 题目描述
给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 0 开始的字符串 s ，它只包含字符 '*' 和 '|' ，其中 '*' 表示一个 盘子 ，'|' 表示一支 蜡烛 。

同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [lefti, righti] 表示 子字符串 s[lefti...righti] （包含左右端点的字符）。

对于每个查询，你需要找到 子字符串中 在 两支蜡烛之间 的盘子的 数目 。如果一个盘子在 子字符串中 左边和右边 都 至少有一支蜡烛，那么这个盘子满足在 两支蜡烛之间 。

比方说，s = "||**||**|*" ，查询 [3, 8] ，表示的是子字符串 "*||**|" 。子字符串中在两支蜡烛之间的盘子数目为 2 ，子字符串中右边两个盘子在它们左边和右边 都 至少有一支蜡烛。

请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。
 

示例 1:
```
输入：s = "**|**|***|", queries = [[2,5],[5,9]]
输出：[2,3]
解释：
- queries[0] 有两个盘子在蜡烛之间。
- queries[1] 有三个盘子在蜡烛之间。
```
示例 2:

![](https://assets.leetcode.com/uploads/2021/10/04/ex-2.png)
```
输入：s = "***|**|*****|**||**|*", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]
输出：[9,0,0,0,0]
解释：
- queries[0] 有 9 个盘子在蜡烛之间。
- 另一个查询没有盘子在蜡烛之间。
```

提示：
```
3 <= s.length <= 105
s 只包含字符 '*' 和 '|' 。
1 <= queries.length <= 105
queries[i].length == 2
0 <= lefti <= righti < s.length
```

### 解法 前缀和 + 二分查找
题目挺长，不过题意倒不难理解。

看到题目后第一反应是，通过顺序和逆序的两边扫描，将每一个盘子左边以及右边的最近的蜡烛位置标注出来。
这样，在指定范围内，只要寻找那些是盘子，且左边最近蜡烛和右边最近蜡烛也都在范围内的数量即可。

但是写了一遍之后发现超时。
究其原因，很简单因为query本身长度是10^5量级的，再加上`left_i`和`right_i`的范围也都是整个`s`，即每个query覆盖的范围也是`10^5`量级。
这么一来，复杂度就变成了`O(n^2)`。

于是寻找有没有更好的解决办法。

注意到，当query给出一个范围`start, end`之后，中间所有的盘子或者蜡烛总共是`end - start + 1`个。
接着我们只需要去除其中所有蜡烛的数量，以及所有在两头没有被蜡烛包裹到的盘子的数量，剩下的数量，一定是符合要求的盘子数量。

比如示例1的s，如果给出query是`1,7`，那么片段是`*|**|**`。
这7个元素，减去蜡烛数量2，减去两头未被蜡烛包裹住的盘子数量，左头1个，右头2个，`7-2-2-1 = 2`,就是最终答案。

然而如何确定蜡烛数量以及未被包裹盘子数量呢？如果还是线性扫描，那么仍然是O(n^2)。
这里采取前缀和的思路。

简单来说，预处理阶段，扫描输入s，并将蜡烛视作1，盘子视作0，求出所有位置对应的前缀和。
借助前缀和，就可以轻松求出任意一个区间的蜡烛数量。
对于区间`start, end`，若区间左端点不是蜡烛，那么区间内蜡烛数量等于`presum[end] - presum[start]`。
若左端点是蜡烛，则还要再加上1，等于`presum[end] - presum[start] + 1`。
脑补一些例子后就可以发现这个规律的正确性。

接着两端未被包裹的盘子数量其实也可以借助前缀和。首先是左端。
若左端是盘子，则我们只需要找`presum[start] + 1`在前缀和中第一次出现的位置，换言之，左端盘子右边的第一个蜡烛。
从start到那个蜡烛之间的所有盘子都是没有包裹的，应该去除。
若左端是蜡烛，那么自然无需处理。

接着右端。
右端更简单，只需找`presum[end]`第一次出现的位置即可。那个位置到右端盘子end位置之间的所有盘子都应该去除。
而且这包括了右端恰好是蜡烛的情况。

最后别忘了考虑一些特殊情况。比如区间内一个蜡烛都没有时的情况。

以上，预处理阶段O(n)构建前缀和。
处理query阶段，针对每个query，其都做了有限次二分，是O(nlogn)。
整体复杂度是O(n + nlogn)。
