## 题目描述
由范围 [0,n] 内所有整数组成的 n + 1 个整数的排列序列可以表示为长度为 n 的字符串 s ，其中:
```
如果 perm[i] < perm[i + 1] ，那么 s[i] == 'I' 
如果 perm[i] > perm[i + 1] ，那么 s[i] == 'D' 
```
给定一个字符串 s ，重构排列 perm 并返回它。如果有多个有效排列perm，则返回其中 任何一个 。

示例 1：
```
输入：s = "IDID"
输出：[0,4,1,3,2]
```
示例 2：
```
输入：s = "III"
输出：[0,1,2,3]
```
示例 3：
```
输入：s = "DDI"
输出：[3,2,0,1]
```

提示：
```
1 <= s.length <= 105
s 只包含字符 "I" 或 "D"
```

### 解法 模拟
按直觉走。

因为规定了返回出来的答案一定是一个0-n的排列，所以不妨设置第一个数字为0。
然后扫描s，按照I和D的规则分别构建剩余部分。

构建时，不妨设步长为1。即若第一个字母是I，则是`0,1`，否则就是`0,-1`。

然后第三个数字时可能会回到`0`，但是答案中不能有重复数字，因此需要跳过已经使用过的数字。

换言之，构建答案数组的过程中，使用到的数字是从0向两头扩散的，可以用两个指针分别指向正数和负数的边界。

最后得到一个数组，此时数组中有正有负，但是相对位置一定是正确的，且可以通过整体加上一个差值从而使得序列变成一个0-n的排列。