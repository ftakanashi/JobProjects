## 题目描述
给你一个正整数数组 arr，考虑所有满足以下条件的二叉树：

每个节点都有 0 个或是 2 个子节点。
数组 arr 中的值与树的中序遍历中每个叶节点的值一一对应。
每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。
在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个 32 位整数。

如果一个节点有 0 个子节点，那么该节点为叶节点。

示例 1：

![](https://assets.leetcode.com/uploads/2021/08/10/tree1.jpg)
```
输入：arr = [6,2,4]
输出：32
解释：有两种可能的树，第一种的非叶节点的总和为 36 ，第二种非叶节点的总和为 32 。
```
示例 2：

![](https://assets.leetcode.com/uploads/2021/08/10/tree2.jpg)
```
输入：arr = [4,11]
输出：44
```

提示：
```
2 <= arr.length <= 40
1 <= arr[i] <= 15
答案保证是一个 32 位带符号整数，即小于 231 。
```

### 解法 DP
这题题设看起来比较复杂，需要透过现象看本质。
可以看到虽然规则很多，但是都围绕着叶子节点这个核心。

实际上，构建题目中所描述的一棵树，本质上是对`arr`数组进行一次切割的一种分割方案。

对于每切出来的一个子数组，都可以将其视为一棵树。当然长度为1的子数组就是一个叶子节点了。

从这个角度看，就可以定义DP数组`dp[i][j]`表示`arr[i:j+1]`这个片段内的题目要求的最小代价值。
显然对于任何`dp[i][j]`其中`i >= j`的情况，`dp[i][j]`都是0。

另一方面，`arr[i:j+1]`这个片段实际上又可以进一步细分为`arr[i:k+1]`和`arr[k+1:j+1]`。
这两个子片段分别代表了`arr[i:j+1]`的树的左右两个子树。
从这个角度看，`dp[i][j] = dp[i][k] + dp[k+1][j] + max(arr[i:k]) * max(arr[k+1:j+1])`。

即按照题目的定义，`arr[i:j+1]`对应树的代价值是 左子树代价值 加 右子树代价值 加 两个子树中各自最大叶子节点的值的乘积。
另注意，此时的`k`是一个变值，所以真正的推导方程应该是：
```python
for k in range(i, j+1):
    dp[i][j] = min(
        dp[i][j],
        dp[i][k] + dp[k+1][j] + max(arr[i:k+1]) * max(arr[k+1:j+1])
    )
```

另外每次遍历都调用一次max也不太好，可以先行一次遍历将每个子数组对应的最大值都先保存下来，
这个过程比较简单就不多说了。

从状态推导方程看，`dp[i][j]`其实取决于`dp[i][k]`而`k < j`。因此遍历的顺序还有所讲究。
这里建议先遍历`j`，然后从后到前遍历`i`，再遍历`k`。
也就是说三层循环的嵌套分别是：
```python
for j in range(n):
    for i in range(j-1, -1, -1):
        for k in range(i, j):
            # ...
```

最后，当然返回整个DP的最右上角 `dp[0][-1]` 即可。
这个解法总体复杂度较高，有`O(n^3)`，好在`n`不是很大…