## 题目描述
给定二叉搜索树的根 root 、一个目标值 target 和一个整数 k ，返回BST中最接近目标的 k 个值。你可以按 任意顺序 返回答案。

题目 保证 该二叉搜索树中只会存在一种 k 个值集合最接近 target

示例 1：

![](https://assets.leetcode.com/uploads/2021/03/12/closest1-1-tree.jpg)
```
输入: root = [4,2,5,1,3]，目标值 = 3.714286，且 k = 2
输出: [4,3]
```
示例 2:
```
输入: root = [1], target = 0.000000, k = 1
输出: [1]
```

提示：
```
二叉树的节点总数为 n
1 <= k <= n <= 104
0 <= Node.val <= 109
-109 <= target <= 109
```

```
进阶：假设该二叉搜索树是平衡的，请问您是否能在小于 O(n)（ n = total nodes ）的时间复杂度内解决该问题呢？
```

### 解法 DFS (非进阶要求)
要做出这道题倒不算很难。
一个显然的解法是直接先把所有节点的值用一次中序遍历迭代出，形成一个有序的列表。
然后再到一个列表中去找符合要求的区间就是了。

另一个稍微高级一点的做法是维护一个长度始终为k的列表。而在dfs过程中只需要检查遍历当前节点与列表中距离target最远的值，
其距离是否大于当前节点距离target的值。

为了方便，上述列表可以用一个队列，并且在中序DFS遍历时，天生队列头肯定是距离target最远的。
换言之，只需要检查当前节点值与target的差，以及，队列头与target的差就行了。

不过显然，无论上述哪种做法，时间复杂度都是O(n)的。
你问我进阶的更快的做法怎么做？我怎么知道哈哈哈，看答案吧