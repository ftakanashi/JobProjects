## 题目描述
给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

- '.' 匹配任意单个字符
- '*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。
 
示例 1：
```
输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```
示例 2:
```
输入：s = "aa" p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```
示例 3：
```
输入：s = "ab" p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
```
示例 4：
```
输入：s = "aab" p = "c*a*b"
输出：true
解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
```
示例 5：
```
输入：s = "mississippi" p = "mis*is*p*."
输出：false
```
 

提示：
```
0 <= s.length <= 20
0 <= p.length <= 30
s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
保证每次出现字符 * 时，前面都匹配到有效的字符
```

### 解法 DP
联动`LC.44`。那题是`*`和`?`组合匹配，这题则是`*`和`.`组合匹配。
解法是很明显的，字符串套路的二维DP而已。

问题在于状态转移方程如何确定。
我们以p串中每个字符为行，s串为列考虑。即若`m, n = len(p), len(s)`的话，dp的size是`(m+1) * (n+1)`的。

再来简单看下初始化。
显然，`dp[0][0]`对应空串匹配空串，应该置为True。
第一行其他位置，则是空串匹配由内容的字符串，因此保持False即可。
至于第一列，则和`LC.44`一样稍微有点复杂。比如像`c*a*b*`这样的p串，其实在`*`对应的位置上，第一列都是可以置True的（即每个`*`都匹配零个字符串）
但是如果去掉任意一个`*`，从被去掉的位置开始，就不能匹配空串，因此从那开始的dp值也要保持False。

综上，初始化时从上至下扫描第一列，当第一列保持`x*x*x*`这种情况时，将`*`位置置True。
但第一列不能有连续两个非`*`字符出现，否则就直接break掉。

接下来考虑转移方程。
从简单的情况开始考虑，显然当`p[i-1]`是普通字符时，`dp[i][j] = dp[i-1][j-1] and p[i-1] == s[j-1]`。

此外由于`.`是万能匹配一个字符，因此`p[i-1] == '.'`时也符合上述条件。
于是就得出了一部分转移方程：
```python
if p[i-1] != '*':
    dp[i][j] = dp[i-1][j-1] and (p[i-1] == '.' or p[i-1] == s[j-1])
```

难点在于，当`p[i-1]`是`*`时，如何考虑。
平时我总是习惯于写一些例子然后从例子中归纳规律。但是对于这种规则比较复杂的情况，这样效率其实不高。
结合实际情况推导规律可能会更快一点。

比如`xxx a*`和`xxx aa`这两个p和s。（xxx部分表示已经完成匹配的部分，只需要关注后面的一部分）
此时，对最右下角的那个格子，其dp值如何确定？显然这个值左边的值是True，即`a*`可以匹配`a`。
而由于s的最后一个字符也是a，等于p串中`*`前面的基准字符，因此这里也可以置True。
再拓展一点，基准字符为`.`时，则也可以置True。

于是就有了一条规则：
```python
dp[i][j] = dp[i][j-1] and (p[i-2] == '.' or p[i-2] == s[j-1])
# 注意这里无需考虑p[i-2]越界的风险，因为题目明确说了，*前面有有效的基准字符
```

但是这样够了吗？考虑这样两串：`c*a*b*`和`a`。显然这个输入的答案是True。
但是写一下就发现，`dp[-1][-1]`的左边是True，同时`p[-1]`是`*`，所以看基准字符。然而基准字符是b，不等于`s[j-1]`（此时是a）。
按照上面说的规则，最后`dp[-1][-1]`变成了False。

说明上面一条规律还不够。
其实仔细想一下就知道，上面的规律对应的，其实是`x*`总匹配到至少一个字符的情况。然而它也可以一个字符都不匹配。
若`x*`这部分一个字符也不匹配的话，我们就应该check一下`dp[i-2][j]`，如果彼时是True。那么其实也可以断定当前位置也应该是True（相当于`x*`部分什么都不匹配）

于是我们就得到了完整的转移方程：
```python
if p[i-1] != '*':
    dp[i][j] = dp[i-1][j-1] and (p[i-1] == '.' or p[i-1] == s[j-1])
else:
    if dp[i][j-1] and (p[i-2] == '.' or p[i-2] == s[j-1]):
        dp[i][j] = True
    if i > 2 and dp[i-2][j]:
        dp[i][j] = True
```

初始化和状态转移方程都有了，写代码水到渠成。