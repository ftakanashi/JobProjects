## 题目描述
你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。

为了使收益最大化，矿工需要按以下规则来开采黄金：

每当矿工进入一个单元，就会收集该单元格中的所有黄金。
矿工每次可以从当前位置向上下左右四个方向走。
每个单元格只能被开采（进入）一次。
不得开采（进入）黄金数目为 0 的单元格。
矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。

示例 1：
```
输入：grid = [[0,6,0],[5,8,7],[0,9,0]]
输出：24
解释：
[[0,6,0],
 [5,8,7],
 [0,9,0]]
一种收集最多黄金的路线是：9 -> 8 -> 7。
```
示例 2：
```
输入：grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]
输出：28
解释：
[[1,0,7],
 [2,0,6],
 [3,4,5],
 [0,3,0],
 [9,0,20]]
一种收集最多黄金的路线是：1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7。
```

提示：
```
1 <= grid.length, grid[i].length <= 15
0 <= grid[i][j] <= 100
最多 25 个单元格中有黄金。
```

### 解法 回溯DFS
注意条件，只能进入带黄金的格子，且进入后黄金被采完。换言之，不能重复进入任意一个格子。
很明显这题可以用回溯法来做。但是具体细节上还是有需要注意的地方。

定义dfs函数如`dfs(x, y, gold)`表示当到达`(x, y)`点且累计已经获取到了`gold`个黄金时，从该点出发进行探索能够得到的
最大的收益。

通常为了保证不重复进入格子而发生循环探索，会设置一个外部的seen哈希集。
不过这题可以更加自然地将`x, y`中的黄金数量置零，从而保证不循环探索。
当然，置零后进一步探索，当探索完成返回值之前，记得将值重新恢复。这也就是回溯的要义。

在函数中，我们先将本位置置零，加入黄金收益，然后向四周探索。
若四周越界或者没有黄金，就无需探索直接continue。
将向四周探索后得到的最大收益作为从本点出发探索能够得到的最大收益，返回出去。
在那之前别忘了恢复本点的黄金值。

另外，由于题目中任意一个有黄金的格子都可以作为起点，所以在dfs外面，我们需要遍历每个格子，
当其中有黄金时就尝试将其作为起点，看看从这里作为起点时最多能拿到多少黄金。然后取全局最大值即可。

以上就是本题的算法了。

#### 关于是否可以记忆化的一些思考
算法很自然，也不难写。
问题在于写完之后，我稍加思考后加了个cache做了记忆化，然后就gg了。

仔细思考后发现，cache是不能加的。

我们知道，dfs探索若依赖dfs函数外部的信息，那么就不能随便加cache，因为无法做到输入和输出的一一对应。
而这题，我们虽然没有用到常见的`seen`，`visited`之类的外部信息，但是还是用到了地图`grid`。
换言之，仅仅确定当前点`x,y`和当前黄金持有量`gold`是无法确定其最终能获得的黄金量。
因为周边的地图信息还未考虑进去。

举个简单的例子，加入是下面这个地图：
```text
1 9 0 0 0
1 1 2 1 0
0 0 0 1 1
```
若有记忆化，在最开始探索的过程中，我们可能从左上角开始走了`下 右 右`的路线，到达位置`(1, 2)`。
此时我们会第一次调用`dfs(1, 2, 3)`，显然这个函数返回值应该是8，即从`(1, 2)`开始继续走`右 下 右`，
将地图中所有的1都拿光。而cache中就会保存`(1,2,3) -> 8`这个关系。

接着，在尝试其他点作为起点时，我们会碰到从右下角开始走`左 上 左`，此时调用的函数，恰好也是`dfs(1,2,3)`。
因为有记忆，这会导致这个函数直接返回8。
但是实际上，如果是从右下角开始探索到达的`(1, 2)`，
我们可以走`左 上 左 下`，把包括最大金矿的9在内的所有黄金都拿完。显然带了记忆化之后，结果出错了。

综上，加不加cache还是得谨慎一点，要仔细考虑到底有没有用到外部信息。