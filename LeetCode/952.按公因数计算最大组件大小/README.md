## 题目描述
给定一个由不同正整数的组成的非空数组 nums ，考虑下面的图：

有 nums.length 个节点，按从 nums[0] 到 nums[nums.length - 1] 标记；

只有当 nums[i] 和 nums[j] 共用一个大于 1 的公因数时，nums[i] 和 nums[j]之间才有一条边。

返回 图中最大连通组件的大小 。

示例 1：

![](https://assets.leetcode.com/uploads/2018/12/01/ex1.png)
```
输入：nums = [4,6,15,35]
输出：4
```
示例 2：

![](https://assets.leetcode.com/uploads/2018/12/01/ex2.png)
```
输入：nums = [20,50,9,63]
输出：2
```
示例 3：

![](https://assets.leetcode.com/uploads/2018/12/01/ex3.png)
```
输入：nums = [2,3,6,7,4,12,21,39]
输出：8
```

提示：
```
1 <= nums.length <= 2 * 104
1 <= nums[i] <= 105
nums 中所有值都 不同
```

### 解法 并查集
这道题没有看上去那么难（不管效率的话…

题目一看就知道要用并查集，但是如果朴素地将所有数字作为节点去做的话，那么求边的时候要调用很多次的`gcd`，会导致比较复杂。

这里我们可以参考之前有些题目的虚拟节点的做法，比如20和50，我们直接尝试求20的所有因数，比如2和10，虽然这两个数字都不在nums中，
但是可以作为虚拟节点插入图里。

这样一来，就可以节省不少计算时间。

并查集构建完毕后，直接统计nums中每个数字的root是什么，然后按照root出现的频次，就可以统计得到最大连通分量的大小了。