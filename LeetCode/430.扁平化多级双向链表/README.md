## 题目描述
多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。

给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。

示例 1：
```
输入：head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
输出：[1,2,3,7,8,11,12,9,10,4,5,6]
解释：

输入的多级列表如下图所示：
```
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlist.png)

```
扁平化后的链表如下图：
```
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlistflattened.png)

示例 2：
```
输入：head = [1,2,null,3]
输出：[1,3,2]
解释：

输入的多级列表如下图所示：

  1---2---NULL
  |
  3---NULL
```
示例 3：
```
输入：head = []
输出：[]
```

### 解法 DFS（递归）
解法几乎是一眼就可以看出来的，大体的思路也很好想。
但这道题也完美体现了链表类题目，思路很好想，但是魔鬼在细节的特点。

首先，第一时间脑海中浮现出来的肯定是一个`dfs(node)`的DFS递归函数。
这个函数检查node是否有`child`，如果有，那么就将`dfs(node.child)`。将其子链表（以及所有下面的后代链表）全部递归拉平，然后拼接到当前节点以及其next中间。

由于要整个拼接拉平后的子链表，比较重要的是子链表的尾巴（头就是node.child，可以直接访问到），因此我们安排dfs函数返回拉平后子链表的尾巴。

由于题设的结构中，横向是双向链表，但是纵向的还是从上至下的单向。因此我们可以在dfs函数中传入某个层级链表的头结点。
接着去向后遍历该层节点，若节点有child则根据上述规则将child对应的子链表递归地拉平然后插入。

更具体的情况以及一些注意点可以看代码注释。