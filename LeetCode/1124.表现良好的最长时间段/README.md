## 题目描述
给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。

我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。

所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。

请你返回「表现良好时间段」的最大长度。

示例 1：
```
输入：hours = [9,9,6,0,6,6,9]
输出：3
解释：最长的表现良好时间段是 [9,9,6]。
```
示例 2：
```
输入：hours = [6,6,6]
输出：0
```

提示：
```
1 <= hours.length <= 104
0 <= hours[i] <= 16
```

### 解法 前缀和 哈希表
什么地狱题目…

题目本身不难理解，另外也很容易想到，将大于8的元素视作+1，否则视作-1，然后累加就可以得到一个前缀和数组。
这个灵感来源于括号匹配的那种题目。

比如示例1，就可以写成一个前缀和数组为`[0, 1, 2, 1, 0, -1, -2, -1]`。

然后就可以发现，求一段时间是不是题目要求的表现良好时间段，只要看这段时间的起始点`i`和终点`j`在前缀和数组中的关系。
具体的，只要`presum[j] > presum[i]`，那就是。

于是题目就变成了，拿到前缀和数组之后，如何从中求出一个片段`i:j`，使得`presum[j] > presum[i]`的前提下`j - i`最大。

按照朴素的解法，我们可以遍历所有`j`，然后再遍历所有`i`，一定可以找到答案。
这里提供一种优化的思路。

要优化，肯定是要结合具体情况中的一些条件来优化朴素思路。
这里，我们注意到`presum`是一个前缀和数组，也就是说`presum[0]`一定是0。
换言之，对于任意的`presum[j] > 0`，与之对应的符合要求的最长的片段一定是`0:j`。

而最妙的事，如果`presum[j] <= 0`呢？
先给出结论，我们只需要关注最靠左的`presum[j] - 1`出现的位置即可。
因为对于原数组的解析的操作只有加1或者减1，所以前缀和中的每个元素都是一点点增加或者递减的。

如果`presum`中存在一个负数比如说-5，那么只需要关注左边是否有-6即可。
为什么不用管-7呢，因为如果-7存在，考虑到最左端的起始点固定是0，所以-7的左边一定会存在一个-6。
实现上，为了确认某个负数第一次出现的位置，在构建前缀和数组时就可以直接用哈希表记录这部分对应关系信息。

总的解题思路就是：

首先将原数组根据元素是否大于8，来映射为1或者-1，然后转化为一个前缀和数组。
转化时用哈希表记录前缀和数组中的各个元素第一次出现的位置。
然后遍历`j`，根据`presum[j]`的正负性分类讨论。如果是正数，则记录`j`，否则记录`j`减去上面哈希表中记录的`presum[j] - 1`的位置。