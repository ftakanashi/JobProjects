## 题目描述
给你一个整数数组 `nums` ，返回 `nums[i] XOR nums[j]` 的最大运算结果，其中 `0 ≤ i ≤ j < n` 。

进阶：你可以在 O(n) 的时间解决这个问题吗？
>注: 并不是特别严格的O(n)，其实是O(nc)，其中c指输入的整数的最大幂范围。比如这题输入最大是2^31，所以c可以认为是31。

示例 1：
```
输入：nums = [3,10,5,25,2,8]
输出：28
解释：最大运算结果是 5 XOR 25 = 28.
```
示例 2：
```
输入：nums = [0]
输出：0
```
示例 3：
```
输入：nums = [2,4]
输出：6
```
示例 4：
```
输入：nums = [8,10,2]
输出：10
```
示例 5：
```
输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70]
输出：127
```

提示：
```
1 <= nums.length <= 2 * 104
0 <= nums[i] <= 231 - 1
```

### 解法1 贪心思想 + 哈希集
这题说难不难，说简单也没那么简单。
一个最朴素的思想，就是暴力n^2求解，试了一下也能跑过不少case。
另一方面，思考了异或最大的意思，感觉应该让高位尽量大，也就是说符合条件的两个数应该尽量分别是最小值和最大值。
带着这样的思路，尝试排序然后丛两边试。但是一来排序就O(nlogn)了，二来像示例4这种也没有取最大值，其中规律比较微妙。

于是看答案。
这道题首先要意识到的是贪心思想。要求异或结果最大，显然应该贪心地希望结果中1越多且处于越高位越好。

于是我们从高到低依次决定答案的各个位置的值。其中存在一个低位和高位结果冲突的问题。
比如示例4中的三个输入二进制分别是
```text
1000 --- 8
1010 --- 10
0010 --- 2
```
第一位显然可以取到1，第二位没办法只能取0。第三位表面上可以取1，但是这里终归是一个有条件的组合问题。
第一位取1时，两两组合可能是8 2或者10 2。而第三位取1时两两组合可能是8 10或者8 2。
恰好8 2是交集，所以还没什么问题。但如果前后两个组合的集合交集时空集的话，那就无法取到了。此时，由于贪心思想要保证高位尽量是1，
因此只能忍痛割爱，将第三位取0。

所以，问题的关键在于，如何在确定低位的时候同时考虑已经确定好了的高位信息。
按照上述描述，一个朴素的想法是扫描过程中维护"可能的集合种类"。但这需要在每一位都遍历所有两两组合，无法优化O(n^2)。
此时一个关键的想法是，将已经确定的高位结果也带入到低位决策的过程中。

具体的，上述例子决定第三位的时候，我可以假设第三位也取1，因为前两位是10，所以此时假设的第三位的结果是101。
接下来，只需要再
```text
100 --- 8的前三位
101 --- 10的前三位
001 --- 2的前三位
```
中找两个数，使得其异或结果等于101即可。因为是整体等于101，所以那些保证第三位是1但是使得高位降低了的组合就被过滤了。
但是问题还没完，按照上面说的，这不还是要遍历两两组合吗？！

其实注意到，问题到这里，已经变成了"如何从一些数中，找到两个数使得其异或结果是指定数"。是一个TwoSum的变体了！
又因为异或运算的性质表明：`a^b = x 等价于 a = x^b`。
所以一个简单的解法就是，维护一个哈希集，放入100，101，001这三个数。然后再扫描101和这些数的异或结果，若干此结果存在于哈希集中，
说明原数组中可以找出两个数其异或结果是101，也就说明第三位可以取1。否则，就取0。

上述算法其实在TwoSum中还更加复杂一点。因为取数字是不放回的抽样，因此TwoSum中还需要在哈希集中加上下标信息，保证在诸如从`nums=[2, 3, 4]`
`target=6`时，出现`3,3`这种答案。
但是这里异或运算有一个好处，因为我们假定当前需要确定的位置，target的值是1，因此保证了`target >= 1`。这也意味着上面的式子`a^b = x`中，
`a != b`，因此就无需考虑`x^b = b`的可能性，从而无需向哈希集中维护下标信息。

上述算法，因为从高到低扫描，外层需要O(c=31)的复杂度，而每一位还需要一次扫描各个数字一遍，所以整体是O(nc)。
考虑到c并不是一个很大的数字，所以大体可以认为是O(n)复杂度。

### 解法2 字典树
一说出字典树三个字，恐怕就能脑补出大概的解法了…

首先是根据所有数字的二进制表示构建一个字典树。因为二进制只有0和1两个方向，所以这个字典树也是个二叉树。不妨设left是0方向，right是1方向。

其次，确定一个基准值n后，从高位开始扫描，在树中寻找可以和n异或最大的值（或者说路径）。
这条路径的特点是"尽可能地和n唱反调"。比如n的第一位是0，那么树就应该尝试右子树走。
当然右子树不一定存在，此时实在没办法才往左子树走。此时结果第第一位也只能取0。

以此类推，当扫描完n的所有位置后，树中的指针也走完了唱反调的路径，扫描过程中统计结果的每一位是0还是1，
就可以得到对于n来说，在树中可以找到的某个数使其最终的异或结果最大了。

对这道题，建立完树之后，依次遍历每个输入，以其作为基准值进行一套上述扫描树的操作即可。

建树的过程和后续扫描过程都是O(nc)，因此整体时间也是O(nc)。
另一方面，树虽然会有很多共用节点（共同前缀），但是整体空间复杂度也会是O(nc)，所以空间复杂度上不如上一种方法那么好。