## 题目描述
给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。

要求返回这个链表的 深拷贝。 

我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：

val：一个表示 Node.val 的整数。
random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。

示例 1：
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)
```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```
示例 2：
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)
```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```
示例 3：
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png)
```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```
示例 4：
```
输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。
```

提示：
- -10000 <= Node.val <= 10000
- Node.random 为空（null）或指向链表中的节点。
- 节点数目不超过 1000 。

### 审题
说是什么random指针，搞得很高大上的样子。
其实就是一个和next一样的东西，只不过它不再规定指向下一个节点而已。

### 解法1 两次迭代 先构建next连接 再基于哈希表后构建random连接
一个很自然的想法，如果没有random指针捣乱，只是一个单纯的链表复制，该怎么做？

显然，设置两个指针，一个指针`i`扫描原链表，另一个指针`j`从零开始依据扫描结果构建新链表。

一遍扫描完了之后，新链表还没有进行random连接。因此两个指针还需要再从头扫描一遍，帮助新链表构建random连接。

注意这次扫描的`i`指针的步进依据仍然是next而不是random，否则容易形成闭环。
而正因为依据是next，所以random不管你连到什么地方，`i`都只看一层，不会去看`node.random.next`之类的东西，避免混乱出现。

剩下只有一个问题，`i`的random指向的节点仍然是原链表的节点，那么如何将`j.random`指向新链表的节点呢？
看来需要一个哈希表来维护新旧节点之间的对应关系。
这样只需要`j.random = hash[i.random]`就可以了。

这个哈希表，显然在第一次扫描的时候就可以构建起来了。

### 解法2 不使用额外空间的巧妙做法
上述用了O(n)的哈希表用来维护新旧节点之间的对应关系。

下面介绍一种方法，默认将新节点放在其旧节点和旧节点的next的中间。
这样，扫描完一遍之后，random连接建立时就不需要外部哈希表了。

只需要`j.random = i.random.next`。

见图：
![](https://pic.leetcode-cn.com/1789e6dd9bbe41223cab82b2e0a7615cd1a8ed16a3c992462d4e1eaec3b82fb1-image.png)