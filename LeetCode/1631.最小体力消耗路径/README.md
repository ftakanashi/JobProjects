## 题目描述
你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。

一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。
你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。

一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。

请你返回从左上角走到右下角的最小 体力消耗值 。

示例 1：
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex1.png)
```
输入：heights = [[1,2,2],[3,8,2],[5,3,5]]
输出：2
解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。
这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。
```
示例 2：
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex2.png)
```
输入：heights = [[1,2,3],[3,8,4],[5,3,5]]
输出：1
解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。
```
示例 3：
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex3.png)
```
输入：heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]
输出：0
解释：上图所示路径不需要消耗任何体力。
```


提示：
- rows == heights.length
- columns == heights[i].length
- 1 <= rows, columns <= 100
- 1 <= heights[i][j] <= 10^6

### 解法 BFS（Dijkstra算法）
最开始想到用DFS或者BFS来探索路径，然后实时记录到达某个位置的体力消耗。

但是问题在于，这里无法避免重复访问。
通常FS通过设置一个visited来避免重复访问从而引起死循环。

但是这题里，比如下面这个例子
```text
1 6 6 6
2 3 4 5
```
从左上角1到右上角6，显然按照一般手法探索，最先走的路径是`1-6-6-6`，全程消耗体力是5。

可是稍微绕一点原路，走`1-2-3-4-5-6`，体力消耗是1。

上述例子说明了，要改变固有的探索顺序。
这就想到了将BFS中的一般队列换成优先队列，即堆。

具体算法说明请参考Dijkstra算法，今天有事没时间细看…