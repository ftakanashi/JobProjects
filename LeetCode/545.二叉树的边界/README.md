## 题目描述
二叉树的 边界 是由 根节点 、左边界 、按从左到右顺序的 叶节点 和 逆序的右边界 ，按顺序依次连接组成。

左边界 是满足下述定义的节点集合：

根节点的左子节点在左边界中。如果根节点不含左子节点，那么左边界就为 空 。

如果一个节点在左边界中，并且该节点有左子节点，那么它的左子节点也在左边界中。

如果一个节点在左边界中，并且该节点 不含 左子节点，那么它的右子节点就在左边界中。

最左侧的叶节点 不在 左边界中。

右边界 定义方式与 左边界 相同，只是将左替换成右。即，右边界是根节点右子树的右侧部分；叶节点 不是 右边界的组成部分；如果根节点不含右子节点，那么右边界为 空 。

叶节点 是没有任何子节点的节点。对于此问题，根节点 不是 叶节点。

给你一棵二叉树的根节点 root ，按顺序返回组成二叉树 边界 的这些值。
 

示例 1：
```
输入：root = [1,null,2,3,4]
输出：[1,3,4,2]
解释：
- 左边界为空，因为二叉树不含左子节点。
- 右边界是 [2] 。从根节点的右子节点开始的路径为 2 -> 4 ，但 4 是叶节点，所以右边界只有 2 。
- 叶节点从左到右是 [3,4] 。
按题目要求依序连接得到结果 [1] + [] + [3,4] + [2] = [1,3,4,2] 。
```
示例 2：

![](https://assets.leetcode.com/uploads/2020/11/11/boundary2.jpg)
```
输入：root = [1,2,3,4,5,6,null,null,null,7,8,9,10]
输出：[1,2,4,7,8,9,10,6,3]
解释：
- 左边界为 [2] 。从根节点的左子节点开始的路径为 2 -> 4 ，但 4 是叶节点，所以左边界只有 2 。
- 右边界是 [3,6] ，逆序为 [6,3] 。从根节点的右子节点开始的路径为 3 -> 6 -> 10 ，但 10 是叶节点。
- 叶节点从左到右是 [4,7,8,9,10]
按题目要求依序连接得到结果 [1] + [2] + [4,7,8,9,10] + [6,3] = [1,2,4,7,8,9,10,6,3] 。
```

提示：
```
树中节点的数目在范围 [1, 10^4] 内
-1000 <= Node.val <= 1000
```

### 解法 模拟 DFS
边界说了一大堆，净说没用的…

总之很简单，从根节点开始，逆时针转一圈，能够在最外围看到的节点就是二叉树的边界。
这些节点包括了
1. 根节点本身
2. 根节点从上向下遍历最靠左的那些节点，这个遍历过程是能往左就往左，若无左再尝试往右，直到叶子节点
3. 叶子节点（从左到右）
4. 和2类似，只不过是从下向上遍历的最靠右的那些节点

于是思路就很清晰了…
2和4通过线性的遍历就能够解决，3通过一次DFS解决。
注意所有叶子节点都放在3中处理比较方便，因此可以2和4线性遍历过程中记得别把叶子节点计入。