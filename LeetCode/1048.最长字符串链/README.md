## 题目描述
给出一个单词数组 words ，其中每个单词都由小写英文字母组成。

如果我们可以 不改变其他字符的顺序 ，在 wordA 的任何地方添加 恰好一个 字母使其变成 wordB ，那么我们认为 wordA 是 wordB 的 前身 。

例如，"abc" 是 "abac" 的 前身 ，而 "cba" 不是 "bcad" 的 前身
词链是单词 [word_1, word_2, ..., word_k] 组成的序列，k >= 1，其中 word1 是 word2 的前身，word2 是 word3 的前身，依此类推。一个单词通常是 k == 1 的 单词链 。

从给定单词列表 words 中选择单词组成词链，返回 词链的 最长可能长度 。

示例 1：
```
输入：words = ["a","b","ba","bca","bda","bdca"]
输出：4
解释：最长单词链之一为 ["a","ba","bda","bdca"]
```
示例 2:
```
输入：words = ["xbc","pcxbcf","xb","cxbc","pcxbc"]
输出：5
解释：所有的单词都可以放入单词链 ["xb", "xbc", "cxbc", "pcxbc", "pcxbcf"].
```
示例 3:
```
输入：words = ["abcd","dbqca"]
输出：1
解释：字链["abcd"]是最长的字链之一。
["abcd"，"dbqca"]不是一个有效的单词链，因为字母的顺序被改变了。
```

提示：
```
1 <= words.length <= 1000
1 <= words[i].length <= 16
words[i] 仅由小写英文字母组成。
```

### 解法 DFS
题目不难，也是经典的那种有很多种做法的题型。
由于数据范围不大，我们这里采用比较直观DFS。

要形成一个链条，如果按照题目描述从底向上地逐个添加字母，那么就会面临每做一个操作就要遍历26个字母的情况，会让整体逻辑片复杂。
但是如果反过来思考，从顶向下，也就是找到一个较长的字符串，然后尝试将其中的某个字母删除，看剩下的部分是否是`words`中的，这就简单很多了。

具体的，我们定义一个`dfs(s)`函数，用于判断字符串`s`作为最顶部（最长的）字符串时字符串链的情况。
此时，显然我们可以遍历每个字母，然后将去掉这个字母后前后两个片段拼接起来看是否存在于words中，然后决定是否进行下一轮的dfs。
对于`s not in words`的情况，直接返回0作为计数值即可。
于是每个dfs都应该统计去掉每个字母后的下层dfs的返回，然后加上1。

虽然dfs依赖了外部的words，但是并不改变这个数组，因此可以直接给dfs函数套一层cache作为记忆化。