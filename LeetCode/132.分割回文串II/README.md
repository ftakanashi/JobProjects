## 题目描述

给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。

返回符合要求的 最少分割次数 。

示例 1：
```
输入：s = "aab"
输出：1
解释：只需一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。
```
示例 2：
```
输入：s = "a"
输出：0
```
示例 3：
```
输入：s = "ab"
输出：1
```

提示：
- 1 <= s.length <= 2000
- s 仅由小写英文字母组成

### 解法 DP
其实`LC131`也可以用类似的想法来做。
是这么回事：

设置一个与字符串等长的DP数组，`dp[j]`代表 `s[j]`作为右边界时，`s[0:j+1]`最少需要切割的次数。
dp数组的初始化可以是`[i for i in range(n)]`。因为对于长度为n的字符串，最多最多切割的次数（即把所有字母都拆开）也就n-1次。

显然，当`s[0:j+1]`本身就是一个回文串时dp值为零。

如果不是，那么可以扫描`for i in range(0, j)`，针对每个`i`，状态转移方程是：
```python
if s[i+1:j+1] 是回文串:
    dp[j] = min(dp[j], dp[i] + 1)
```

上述dp思路建立完成，接下来还有一个问题，就是如何判断某个串是不是回文的。
如果写一个判断回文函数每次都调用一下肯定会超时。

一方面我们可以像`LC131`一样，用缓存机制进行函数的定义，从而节省时间。
而这里，用一种DP味道更浓的办法，先预处理整个字符串。

具体来说，建立一个n * n的矩阵`palin`，并且维护其右上角部分。
`palin[i][j]`表示`s[i:j+1]`是否是回文串的bool量。

之前在哪个题目中也遇到过，这种判断回文性质的矩阵的值填充顺序是从对角线开始向右上45度一层一层填充的。

针对任意一个位置，有如下状态转移方程：
```python
palin[i][j] = palin[i+1][j-1] and s[i] == s[j]
```
解释一下，就是`s[i:j+1]`是回文串的条件有两个。
第一，`s[i+1:j]`是个回文串。
第二，`s[i] == s[j]`。

**千万注意，再次强调，这种判断回文性质的矩阵不是按行扫描，而是应该从对角线开始，向着
右上45度一层一层扫描。**

至此细节都有了。
整体算法流程，就是先预处理字符串，得到`palin`矩阵，再按照上述思路设置dp数组并且计算每个位置。
最终返回`dp[-1]`就是答案。