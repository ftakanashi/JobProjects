## 题目描述
有时候人们会用重复写一些字母来表示额外的感受，比如 "hello" -> "heeellooo", "hi" -> "hiii"。我们将相邻字母都相同的一串字符定义为相同字母组，例如："h", "eee", "ll", "ooo"。

对于一个给定的字符串 S ，如果另一个单词能够通过将一些字母组扩张从而使其和 S 相同，我们将这个单词定义为可扩张的（stretchy）。扩张操作定义如下：选择一个字母组（包含字母 c ），然后往其中添加相同的字母 c 使其长度达到 3 或以上。

例如，以 "hello" 为例，我们可以对字母组 "o" 扩张得到 "hellooo"，但是无法以同样的方法得到 "helloo" 因为字母组 "oo" 长度小于 3。此外，我们可以进行另一种扩张 "ll" -> "lllll" 以获得 "helllllooo"。如果 S = "helllllooo"，那么查询词 "hello" 是可扩张的，因为可以对它执行这两种扩张操作使得 query = "hello" -> "hellooo" -> "helllllooo" = S。

输入一组查询单词，输出其中可扩张的单词数量。
 

示例：
```
输入： 
S = "heeellooo"
words = ["hello", "hi", "helo"]
输出：1
解释：
我们能通过扩张 "hello" 的 "e" 和 "o" 来得到 "heeellooo"。
我们不能通过扩张 "helo" 来得到 "heeellooo" 因为 "ll" 的长度小于 3 。
```

提示：
```
0 <= len(S) <= 100。
0 <= len(words) <= 100。
0 <= len(words[i]) <= 100。
S 和所有在 words 中的单词都只由小写字母组成。
```

### 解法 双指针
首先来解析一下题意。
唯一可能造成误解的一点是，`hello`中的`ll`，他并不需要作为一个整体去两个两个地扩展，而是只关注扩展后的字符串中有连续几个`l`即可。
比如示例给出的扩展后的字符串是有连着5个`l`，如果是3个`l`也是符合要求的，若只有两个就不符合了。

接下来来思考一下做法。
双指针的大体框架是很快能想到的。但是也可以想到，如果采用比较经典的，一个指针不动一个指针动的方案，那么像上面这种连着两个`l`之类的情况就会很难处理。

这里，采用一轮遍历时将两边的指针都尽量右移，保证扫过所有相同的字母。
也就是说停止遍历的条件是指针的下一个字母和另一边的不一样。
具体操作上，可以先移`i`再移动`j`。具体逻辑可以看代码里的部分。

这样在进行一轮遍历之后，可以得到两边连着一片的相同字母各自的长度，我们计`S`中的长度为`c1`，`word`中的为`c2`。

接着简单分类讨论即可。
当`c1 < c2`时，说明`S`中的一片相同字母甚至都还没有`word`中的那一片长，更不用谈扩张了，所以可以直接否决。
当`c1 == c2`时，这是其实就是没有扩张的情况，符合要求。
当`c1 > c2`时，按题意，若`c1 > 3`，则也符合要求，否则也否决。

按照以上逻辑写代码。更多细节写在注释中。