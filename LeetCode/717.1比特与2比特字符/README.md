## 题目描述
有两种特殊字符：

- 第一种字符可以用一个比特 0 来表示 
- 第二种字符可以用两个比特(10 或 11)来表示、

给定一个以 0 结尾的二进制数组 bits ，如果最后一个字符必须是一位字符，则返回 true 。

示例 1:
```
输入: bits = [1, 0, 0]
输出: true
解释: 唯一的编码方式是一个两比特字符和一个一比特字符。
所以最后一个字符是一比特字符。
```
示例 2:
```
输入: bits = [1, 1, 1, 0]
输出: false
解释: 唯一的编码方式是两比特字符和两比特字符。
所以最后一个字符不是一比特字符。
```

提示:
```
1 <= bits.length <= 1000
bits[i] == 0 or 1
```

### 解法 一遍扫描
这题说简单倒也不算太简单，而且还挺有意思的。

理解题意之后，看到这两个示例。
看了示例1之后，想到了，如果末尾是连续的两个0，那么无论前面怎么折腾，
最终都可以保证最后一个字符是也只可能是单比特字符`"0"`。

但是上述结论似乎还没覆盖到所有情况。
于是脑补一些情况后发现，单看字符串的合法性，不管前面怎么折腾，只要有一个0，那么到这个0为止肯定都是合法的。

由于题目保证了整个数组的末尾一定是0，因此，只需要从右向左扫描第二个0的位置即可。
找到第二个0的位置后，那个0往前的所有数字都可以不用看，只需要考察这两个0中间的内容即可。

而另一方面，根据定义，中间这些必然是若干个1。
于是可以简单地发现，当这其间1的个数是偶数时，刚好可以凑够整数个`11`，从而保证末尾的0单独成一个字符。
相反，若是奇数，则末尾的0必须与倒数第二个1形成`10`才能保证字符串合法。

综上，算法就是从右到左一遍扫描，找到倒数第二个出现的0，然后统计末尾到该位置间1的个数的奇偶性即可。
对于全数组仅末尾一个0的情况，自然将倒数第二个0下标设置为-1即可。