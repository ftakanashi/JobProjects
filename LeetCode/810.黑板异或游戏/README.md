## 题目描述
黑板上写着一个非负整数数组 nums[i] 。Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。 (另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 0。）

**换种说法就是，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0，这个玩家获胜。**

假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 true。

示例：
```
输入: nums = [1, 1, 2]
输出: false
解释: 
Alice 有两个选择: 擦掉数字 1 或 2。
如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么 Bob 可以擦掉任意数字，因为 Alice 会成为擦掉最后一个数字的人，她总是会输。
如果 Alice 擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。Alice 仍然会输掉游戏。
```

提示：
```
1 <= N <= 1000
0 <= nums[i] <= 2^16
```

### 解法 数学
一看到标签里有数学，又尝试思考了下能不能通过DFS之类的方法模拟，发现很难之后，直接看答案…

思路是这样的。
首先注意到，任意两轮之间互相不存在影响，而由于Alice是先手，因此可以把每次Alice碰到的黑板上的剩余数字作为一个单独的问题输入来思考。

那么Alice碰到什么样输入会赢，碰到什么样的输入会输呢？

设输入为`a1, a2, ..., an`，其异或结果是`S = a1 ^ a2 ^ ... ^ an`。
易得，如果`S == 0`，则Alice直接获胜。
反之，在`S != 0`的前提下，若擦掉任意数字`ai`都会导致剩余异或结果是0，则Alice失败。

换言之，（根据异或运算的性质）对于任意的`1 <= i <= n`，都有`S ^ ai == 0`，即
```text
S ^ a1 = S ^ a2 = ... = S ^ an = 0
```
给上述所有式子都追加异或一个S，得到
```text
a1 = a2 = ... = an = S
```
也就是说，`S != 0`并且满足上述条件的输入，Alice将直接失败。
注意，这里面其实还有一个隐含条件。因为前提是`S != 0`，如果`n`是偶数，那么上述`a1 = a2 = ... = S`必然不能被满足。

总结一下，若输入满足`S == 0`，则Alice获胜。
若输入满足`S != 0 并且 a1 = a2 = ... = an = S （后半隐含了n是奇数）`，则Alice失败。

剩余的情况（比如n是偶数或者不满足所有元素相等等情况）时，Alice都还有回旋的余地，即至少存在一些数字，Alice擦去它们并不会立刻失败。

推导到这里，通常要结合上面的判胜利失败的条件做DFS了。
但是因为Bob是最优策略选手，DFS模拟挺难的。

虽然没有严格证明，但既然题目要求返回的是Alice能否最终获胜的bool值，且两个选手都是最优策略选手，
所以肯定可以通过分析输入就知道最终谁必胜谁必败了。

最终，判断条件其实就是看
```text
1. S == 0
2. S != 0 并且 n是偶数
```
这两个条件满足其一，就是Alice获胜。否则Alice失败。

这题其实是一道博弈论的题目，对于不熟悉博弈论的我而言，有些地方确实挺难理解的。
姑且先按这样写一下答案。主要还是记住基本的异或运算性质，以及最优策略选手对垒时，必定有必胜必败这个结论吧。

最后的代码倒是非常简单。
首先查看n是不是偶数，如果不是就计算S，看是否是0，若不是就返回False。