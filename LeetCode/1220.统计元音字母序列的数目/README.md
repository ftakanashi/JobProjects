## 题目描述
给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n 的字符串：
```
字符串中的每个字符都应当是小写元音字母（'a', 'e', 'i', 'o', 'u'）
每个元音 'a' 后面都只能跟着 'e'
每个元音 'e' 后面只能跟着 'a' 或者是 'i'
每个元音 'i' 后面 不能 再跟着另一个 'i'
每个元音 'o' 后面只能跟着 'i' 或者是 'u'
每个元音 'u' 后面只能跟着 'a'
由于答案可能会很大，所以请你返回 模 10^9 + 7 之后的结果。
```
示例 1：
```
输入：n = 1
输出：5
解释：所有可能的字符串分别是："a", "e", "i" , "o" 和 "u"。
```
示例 2：
```
输入：n = 2
输出：10
解释：所有可能的字符串分别是："ae", "ea", "ei", "ia", "ie", "io", "iu", "oi", "ou" 和 "ua"。
```
示例 3：
```
输入：n = 5
输出：68
```

提示：
```
1 <= n <= 2 * 10^4
```

### 解法 DP
这题虽然标注是困难，但说实话确实不难。

看到这题的第一眼，想到的是有限状态自动机。
因为每个字母的下一个字母是固定的，因此可以画出一张有向图。用邻接表来表示就是：
```text
a: [e]
e: [a, i]
i: [a, e, o, u]
o: [i, u]
u: [a]
```

最朴素的思路，就是针对这个图中的每个节点开始一次dfs遍历。
每次遍历的时候都记录步数，直到步数达到n位置，统计所有的可能。

这样的思路配合上记忆化应该也可以做。
但是我脑补了一下感觉复杂度还是有点高的。而且答案要取模，不知道dfs中应该把取模放在什么地方合适。

看了眼答案。
有些DFS自顶向下暴力搜索的思路可以用DP自底向上地代替，这题就是一个典型的例子。
我们定义`n*5`的dp数组，`dp[i][j]`表示长度为`i`的序列，恰好以某个特定元音字母结尾的序列共有多少个。
比如我们规定`a e i o u`分别是下标`0 1 2 3 4`。

这样的思路其实也是显而易见的。
比如，当我们知道所有`n-1`的长度序列时，想要知道长度为`n`且末尾是`e`的序列数目，
显然只要把`n-1`中那些末尾是`a`和末尾是`i`的数目简单加起来就行了。

于是，状态转移方程也就轻松得到了。具体的写代码里，这里就不写了。

官方答案中还提到可以用数学技巧，即矩阵的快速幂算法来快速计算模拟这个递推的过程。
这里就不赘述了。