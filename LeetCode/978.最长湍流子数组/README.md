## 题目描述

当 A 的子数组 A[i], A[i+1], ..., A[j] 满足下列条件时，我们称其为湍流子数组：

- 若 i <= k < j，当 k 为奇数时， A[k] > A[k+1]，且当 k 为偶数时，A[k] < A[k+1]；
- 或 若 i <= k < j，当 k 为偶数时，A[k] > A[k+1] ，且当 k 为奇数时， A[k] < A[k+1]。

也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。

返回 A 的最大湍流子数组的长度。

示例 1：
```
输入：[9,4,2,10,7,8,8,1,9]
输出：5
解释：(A[1] > A[2] < A[3] > A[4] < A[5])
```
示例 2：
```
输入：[4,8,12,16]
输出：2
```
示例 3：
```
输入：[100]
输出：1
```

提示：
- 1 <= A.length <= 40000
- 0 <= A[i] <= 10^9

### 解法1 滑动窗口
因为形成湍流子数组有两种条件，一开始我觉得单纯一起考虑这俩条件有些麻烦，就额外弄了一个diff数组用来保存`arr[i] - arr[i+1]`的差，然后扫描
这个数组中最长的相邻符号不同的长度。

当然后来看了答案后发现一起考虑这俩条件无非就是多写一个if分支而已，本质上一样，但是不整diff数组可以节省点空间。

很明显用滑窗思想可以做。
当右指针的数满足比两边的都小的情况（注意是严格的小，不能等于）就右移右指针，
否则就将左指针置为右指针位置。

细节上需要注意一些，比如为了保持右指针始终在左指针右边，初始化以及左指针置右指针位置后，右指针都+1。

另外求解最大长度时，注意以下两种特殊情况：
```text
1 1 1 1    这种全相同的情况，结果是算1
1 2 3 4    这种单调的情况，结果是算2
```
初始化的时候由于初始化了`l, r = 0, 1`，所以根据`arr[l] == arr[r]`的情况，这个值可以初始化为1或者2。

另外收割结果时，当`r - l`是不够的，因为当r符合要求时，按照题意，这个子数组的边界在`r + 1`。
所以结果应该是`r - l + 1`。

### 解法2 状态压缩DP
这道题的DP数组是这样的：
设置一个`dp[n][2]`，针对位置`i`，
- `dp[i][0]`表示以`arr[i]`为结尾元素时，符合`arr[i] > arr[i-1]`情况的最长湍流子数组长度。
- `dp[i][1]`表示以`arr[i]`为结尾元素时，符合`arr[i] < arr[i-1]`情况的最长湍流子数组长度。

由此可知，状态转移方程是
```text
if dp[i] > dp[i-1]:
    dp[i][0] = dp[i-1][1] + 1
    dp[i][1] = 1
else if dp[i] < dp[i-1]:
    dp[i][1] = dp[i-1][0] + 1
    dp[i][0] = 1
```

这其实都已经把代码安排好了，只要遍历一遍，遍历过程中随时记录最大值即可。
由于只需要全程的最大值，因此可以状态压缩一波。
代码中用`dp_great`和`dp_less`两个变量分别表示上述dp数组中的`dp[i][0]`和`dp[i][1]`。