##题目描述

给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。

若可行，输出任意可行的结果。若不可行，返回空字符串。

示例 1:
>输入: S = "aab"
>
>输出: "aba"

示例 2:
>输入: S = "aaab"
>
>输出: ""

注意:
- S 只包含小写字母并且长度在[1, 500]区间内。

### 前言
这题一开始我以为维护一个counter然后不断地遍历counter的各个字符，始终让相邻字符不同就行了。但是事实上没那么简单额。

比如，3个a，2个b，1个c的情况，此时按照上面规律得到的结果是abcabaa，不符合条件。

但是实际上可以写成ababac这样的就可以了。

所以我自己是没想到什么好的办法，直接看答案了。

首先计数的思路是没错的。只是之后的处理比较tricky。

首先，假设字符串总长度是N而其中最多频数的字母出现次数是n时，如果有`(N + 1) / 2 < n`，此时是无解的。

为什么？可以假设，假如我们又六个字符。其中3个都是a的话，只要剩下的字母没有a，
那我可以把a分散得尽量开，然后让剩余字母插空，比如`a ? a ? a ?`就可以做到符合题意。但是一旦再多一个a，4个a但是总数还是6。
那么完蛋，不论怎么插空都无法避免a和a相邻了。

基于这个思路其实就可以做了，即先计数，再基于计数数据以及插空的办法模拟即可。

然而这里还有另一种神奇的最大堆，虽然没有严格证明为什么他work，但是就是可行的办法。目前可能姑且只能接受这个事实然后背下来。

### 解法1 最大堆
将原字符串的各个字符，维护到一个大顶堆中。堆序采用字符串中字符的频数作为key。

接下来，以抽取两次作为一个时间单位，不断地将大顶堆的堆顶抽出充入结果字符串。注意这个过程要随时维护count-=1之后的新字符信息进堆。

即从堆顶pop两次，然后将那两个字符count-=1后的新count，和字符再次入堆。

别问为什么是pop两次作为一个操作单位…如果pop一次就更新的话，那显然如果某个字符很多，那么一开始那个字符就会连续了。
那为什么不是三次呢…我也不知道，总之记着吧。

反正这个方法可以得到符合要求的结果。

某种意义上来说这也是一种贪心思想，比如当a的个数最多，我们显然不想让a"成块"，所以考虑尽快地消耗掉a。
但是又不能连着消耗，因为相邻字符不能相同。
所以此时只能考虑再用一个除了a意外个数最多的字符。如此，就是最大堆的思路了。

