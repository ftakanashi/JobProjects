## 题目描述
给你一个 m x n 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。

示例 1:

![](https://assets.leetcode.com/uploads/2021/04/08/trap1-3d.jpg)
```
输入: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]
输出: 4
解释: 下雨后，雨水将会被上图蓝色的方块中。总的接雨水量为1+2+1=4。
```
示例 2:

![](https://assets.leetcode.com/uploads/2021/04/08/trap2-3d.jpg)
```
输入: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]
输出: 10
```

提示:
```
m == heightMap.length
n == heightMap[i].length
1 <= m, n <= 200
0 <= heightMap[i][j] <= 2 * 104
```

### 解法 小顶堆
这题虽然是`LC.42`的扩展，但是（至少在我抄的这个做法的角度看来…）并没有太多可以从`LC.42`中得到的启发。

这题主要是这样考虑的。
首先我们应该意识到，在最外面一层的位置，无论是什么情况，都是一格水都保不住的。
而在非边缘的某个格子要能保住水，其必要条件就是其四周格子（可以向外延伸，如示例2的情况）的高度都要高于他。至于能保住多少水，就得看四周哪个柱子最矮了。

为了能够没有漏洞地考虑，我们不妨从最外层边界开始，并维护一个小顶堆，始终只关注全局最矮的那个柱子的情况。
若这么做，好处就是从堆顶取出一个位置后，我们只需要关注其四周那些可能积水的位置。这些位置只要有比本位置柱子矮的情况，那么其能够积水的量
必然是本柱高度 - 该位置高度。

将该位置也积满水之后，对于下一步探索，这个位置就可以作为积水后的高度使用了。于是将其积水后的高度以及其位置作为一个新的边界柱子，入堆即可。


比如下面这个例子：
```text
15  15  4   5
15  0   3   15
15  8   10  15
15  15  13  15
15  15  15  15
```

最开始发现四周柱子最矮的是`[0][2]`位置的4，于是将其pop出堆，然后探索其下方位置`[1][2]`，发现此处柱子比其矮，所以可以积`4 - 3 == 1`格子的水。
不用担心这格水会不会流到隔壁`[1][1]`上去。因为如果流过去，必然说明`[1][1]`位置周边有矮于4的格子存在，这与刚才我们拿出4时其位于堆顶的事实矛盾。

将`[1][2]`积水后，就可以将新的高度为4的`[1][2]`作为新的探索边界重新入堆了。

至于计算总的积水量，是很方便的。
我采用的办法，是事先声明一个和输入等size的water数组，用于保存每个位置积水的总高度。
最终求答案，只需要遍历每个位置，求算`water[i][j] - heightMap[i][j]`的总和即可。