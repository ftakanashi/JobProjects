## 题目描述
给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。

一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。

返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。

示例 1：

![](https://assets.leetcode.com/uploads/2021/02/18/enclaves1.jpg)
```
输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
输出：3
解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。
```
示例 2：
```
输入：grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
输出：0
解释：所有 1 都在边界上或可以到达边界。
```

提示：
```
m == grid.length
n == grid[i].length
1 <= m, n <= 500
grid[i][j] 的值为 0 或 1
```

### 解法 并查集
题目倒也不难。一看就知道可以用BFS或者DFS来做。
用搜索的思路做，就是将所有处于边界位置的1改成0，最后统计没有被改成0的剩余陆地数量即可。

不过好久没用并查集了，所以决定这题用并查集来做。

并查集的核心是可以判断两个格子是否处于同一个联通分量中，即是否可以通过通过移动到达彼此。
如此，一个简单的思路就是，先扫描一遍地图，将所有陆地维护进并查集。
即扫描到一个陆地格子时向其上下左右探索，将相邻的陆地格子通过union合并到一个连通分量。

此外，并查集中额外设置一个 -1 虚拟节点，用于表示"边界"。所有与边界相邻的节点，将其与-1节点加入同个连通分量。

这样扫描完一遍后，接着扫描第二遍，并检查所有陆地节点是否和-1在同一个连通分量内，即可知道这个陆地是不是飞地。

一些细节：
在扫描第二遍的时候，注意不能直接访问`uf.fa`中内容，还是得通过`uf.find`方法来确定某个节点所处连通分量的底层标识。
这个可以说是并查集的常见问题了…
另一方面对于`uf.find(-1)`倒是有可以解决的办法。如果这里不想写`find`而是直接写`-1`，则可以在初始化的时候，将`-1`的rank设置为无限大。
如此一来，在所有涉及-1的合并操作中，都是将别的节点合并到-1，保证`uf.fa[-1]`永远都是`-1`。

更多细节注释在了代码中。