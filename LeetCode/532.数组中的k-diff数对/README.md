## 题目描述
给定一个整数数组和一个整数 k，你需要在数组里找到 不同的 k-diff 数对，并返回不同的 k-diff 数对 的数目。

这里将 k-diff 数对定义为一个整数对 (nums[i], nums[j])，并满足下述全部条件：

```
0 <= i < j < nums.length
|nums[i] - nums[j]| == k
注意，|val| 表示 val 的绝对值。
```

示例 1：
```
输入：nums = [3, 1, 4, 1, 5], k = 2
输出：2
解释：数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。
尽管数组中有两个1，但我们只应返回不同的数对的数量。
```
示例 2：
```
输入：nums = [1, 2, 3, 4, 5], k = 1
输出：4
解释：数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。
```
示例 3：
```
输入：nums = [1, 3, 1, 5, 4], k = 0
输出：1
解释：数组中只有一个 0-diff 数对，(1, 1)。
```
示例 4：
```
输入：nums = [1,2,4,4,3,3,0,9,2,3], k = 3
输出：2
```
示例 5：
```
输入：nums = [-1,-2,-3], k = 1
输出：2
```

提示：
```
1 <= nums.length <= 10^4
-10^7 <= nums[i] <= 10^7
0 <= k <= 10^7
```

### 解法 排序 + 哈希
由于题目要求的是去除重复的数对种类数。
因此，一般来说，只要k大于0，我们需要考察的，就是去重后的数组就可以了。

另外，求所谓的k-diff数对`(a, b)`，无非就是求是否有`b - k`在数组中出现。
所以这种套路和前缀和+哈希那类很像，先对数组排个序，然后从左到右开始扫描。
扫描过程中实时将扫描过的数字加入哈希表，并且计算当前值-k在不在哈希表中。

在那类题目中，我们关心下标，所以会需要用哈希表维护`数字: 下标`关系。
而这题中只关心值，所以甚至不用哈希表，只用哈希集就可以了。

以上是`k > 0`的情况，
如果`k == 0`的话，那么其实可以看做是一种特殊情况。其实就是统计有多少种数字计数大于1了。

按照上面的两种情况分别写代码即可，代码都不复杂。