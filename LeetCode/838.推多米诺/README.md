## 题目描述
n 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。

每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。

如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。

就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。

给你一个字符串 dominoes 表示这一行多米诺骨牌的初始状态，其中：
```
dominoes[i] = 'L'，表示第 i 张多米诺骨牌被推向左侧，
dominoes[i] = 'R'，表示第 i 张多米诺骨牌被推向右侧，
dominoes[i] = '.'，表示没有推动第 i 张多米诺骨牌。
```
返回表示最终状态的字符串。

示例 1：
```
输入：dominoes = "RR.L"
输出："RR.L"
解释：第一张多米诺骨牌没有给第二张施加额外的力。
```
示例 2：

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/05/18/domino.png)
```
输入：dominoes = ".L.R...LR..L.."
输出："LL.RR.LLRRLL.."
```

提示：
```
n == dominoes.length
1 <= n <= 105
dominoes[i] 为 'L'、'R' 或 '.'
```

### 解法1 BFS
这题还挺有意思的。
理解题意之后第一反应是可以用BFS来做。

BFS的队列中维护`(i, d)`表示下标`i`处的骨牌收到了方向为`d`的力。
于是对于那些原值是`"."`的位置，大多情况下可以将其值改为相应力的方向，然后将`(i+1, d)`或者`(i-1, d)`加入队列表示力的传导。

当然，上述想法还有一个小bug，就是对于`R.L`这种情况。
由于BFS终归是讲先来后到的，对于中间位置的骨牌来说，我们可能先处理到`(1, "R")`这个项。
于是会将中间的骨牌的值置为`"R"`。但是接着又会受到从右边传递来的`(1, "L")`这个项。
此时由于中间项已经被置为`R`，按照一般逻辑就应该不对其做修改。
但实际上，由于左右两个力是同时传递到中间的，因此中间最终应该还是直立状态。

为了填补以上的漏洞，我们发现在这题中，"轮次"这个概念很重要。
一轮力的传递只能影响一部分骨牌，且若骨牌在一轮力的传递中同时受到两边的力，那么其保持直立。

具体到算法中，这就和树的层序遍历类似，我们开始从queue中pop出项时，一轮中我们只固定pop出当前队列中有的所有项。
也就是说在`while queue`的下面加上一个`for _ in range(len(queue))`。

这样，我们可以保证在for循环内处理的力是一个轮次内部的力。
但即便是一个轮次内部，还是会有先来后到，像上面说的，如果先将`.`变成`R`，为了让后面的`L`能够知道，这个`R`是本轮次新鲜改的，
所以可以在for循环外面加个哈希集，用于保存本轮次中修改的位置。

这样，如果`L`传递过来，发现碰到了`R`但是这个`R`是本轮新鲜改过来的话，那么就可以将这个`R`再次重置回`.`。

### 解法2 两遍扫描
一个更加符合直觉的解法。
如果仅考虑向右倒的情况，那么从每个R开始，其向右的力可以向其右边一片连续的直立骨牌传递。
向左倒的情况同理。
而一旦综合考虑两者，一个显然的结论是，直立骨牌离哪头近，就遵照哪头的规则。
若恰好离两头距离一样，那么最终其保持直立。

因此，一个新的想法是，像接雨水一样，我可以先行顺序、逆序两次遍历，求出每个初始时直立的骨牌在只考虑向左，只考虑向右倒时，
会受到来自多远的一个骨牌的力。
当某个直立骨牌不受到某个方向的力时，假设其是受到了来自该方向无穷远的一个力，即`inf`。
比如示例2的输入是`.L.R...LR..L..`。
先顺序遍历时，可以得到一个像下面这样的数组（`inf`用`F`表示）:
```text
F F F F 1 2 3 F F 1 2 F F F
```
再逆序遍历，可以得到像下面的数组：
```text
1 F F F 3 2 1 F F 2 1 F F F
```

最后，遍历所有初始直立骨牌，然后看在上面两个数组中，哪个方向的力对应的值更小，
越小，表示其受到的力越强，因此就向该方向倒下。