## 题目描述
老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：
- 每个孩子至少分配到 1 个糖果。
- 评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

示例 1：
```
输入：[1,0,2]
输出：5
解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。
```
示例 2：
```
输入：[1,2,2]
输出：4
解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。
```

### 解法 单调栈 + 贪心
初步写写画画之后发现从左到右扫描输入的过程中，发现有以下规律：

对于任何一个数字，其获得的糖果数至少得是"其右侧连续的严格单调递减子数组"的长度。
否则，在这个子数组最右端那个人无法保证可以至少获得1个糖果。

在这个前提下，再思考更多的情况。比如一个全递增序列，显然在每个位置，上述最低糖果数都是1。
但是由于是全递增的，找理由`i`位置的人要比`i-1`的多至少1个。
此时，根据贪心的原理，取前一个人的糖果数+1即可。

简单来说，总结一下就是：
```text
if i比i-1小(或者相等的情况也是):
    res[i] = i右侧连续严格递减子数组长度
else:
    res[i] = max(i-1糖果数 + 1, i右侧连续严格递减子数组长度)
```

举个例子，比如输入`2 4 5 2 2 1`，
根据上述规则，每个位置的右侧连续严格递减子数组长度是`desc_len = [1, 1, 2, 1, 2, 1]`。（注意5右边连续的严格递减子数组是`5 2`不是`5 2 2 1`。

然后从左到右扫描，根据上面的条件规则，前三个结果显然是`1 2 3`。第四个位置，输入值是2，小于前一个5，因此直接使用`desc_len[i]`为1，以此类推，
得到结果`1 2 3 1 2 1`，符合题目结果。

现在问题就是`desc_len`这个数组怎么求了。
最朴素的办法，当然就是逐个遍历，再扫描其右边的子数组计数了。这样是O(n^2)的。

另一方面，其实可以用单调栈来解决，而具体的，因为要求其右侧，所以可以从右往左遍历。遍历过程中维护一个单调递增栈。
对扫描到的位置`i`，如果直接push进栈，则此位置的`desc_len`也加一。一旦发生pop，就将`desc_len`归零。

以上，通过单调栈辅助加上贪心思想的规则设计，可以得到答案。
时间上用了O(n)，空间也用了O(n)。