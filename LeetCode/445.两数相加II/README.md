## 题目描述
给你两个 非空 链表来代表两个非负整数。

数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

你可以假设除了数字 0 之外，这两个数字都不会以零开头。

 

进阶：
- 如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。

示例：
- 输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
- 输出：7 -> 8 -> 0 -> 7

### 解法1 获取十进制表达后相加的常规解法
这题乍一看很简单。

我只要分别将两个链表表示的数字拿到手，加起来，再把和转换成一个链表就可以了。

不过这么做的风险也很显然，由于中介用了若干个整形变量，所以当链表很长的时候有可能会溢出。

好在Python没有大数溢出的概念，总之先用这个解法写了一遍。

### 解法2 栈 模拟加法
为了避免溢出，显然只能通过模拟加法的办法来做了。

但是另一方面，模拟加法要从个位开始算起，而题目又要求不能反转链表。

为了能够倒序获取各个数字，显然要用栈了。

思路很简单，将各个链表的各个数字依次入栈之后，再从栈中pop出数字进行加法。

注意进行加法时进位的处理，当一个链表比另一个长时余量的处理，以及最终如果加完之后最高位是10，从而保留0之后
需要在最前面再加上一个"1"的处理。