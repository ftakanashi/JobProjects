## 题目描述
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:
>输入: [-2,1,-3,4,-1,2,1,-5,4]
>
>输出: 6
>
>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

进阶:
- 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

### 解法1 状态压缩DP

一开始看到取连续区间的性质，还以为用滑动窗口。
但是想了一会，并没有找到合理的把窗口往前推的办法。

于是想到了可能用DP。但是没有细想DP数组用来保存什么东西。
看了眼答案之后懂了。

DP数组中的`dp[i]`表示第`i`个数字为窗口右边界时所有可能的窗口的和的最大值。

显然`dp[0] = nums[0]`。

接下来就是状态转移方程。
显然，`dp[i] = max(dp[i-1] + nums[i], nums[i])`。
也就是说，扫描到`i`时有两种选择，第一是拓展上一状态的窗口右边界到当前位置（前项）。
第二种是将`nums[i]`作为单独的一个长度为1的窗口。

按照上述思路可以写出第一版DP。

然后发现这个DP数组是逐个更新并且最终返回的是其中的最大值。
所以可以做状态压缩，时刻进行DP状态值更新并且时刻记录最大值即可。

### 解法2 前缀和 + 堆
对于这种求连续子数组的和，即子序和的问题，总是可以想到用前缀和做。

一开始我以为构建完前缀和数组后，直接拿max减去min就行了。
但是突然发现，前缀和数组的元素必须是右边减左边才有意义。

于是，从左到右扫描前缀和数组，将其减去已经扫描过的最小值，这样就可以在保证顺序的情况下获得以每个位置结尾时能够得到的最大的前缀和差，即子序和了。

而如何得知已经扫描过的最小值，显然可以用堆。

以上方法，用了O(nlogn)的时间和O(n)的空间，整体上肯定是不如DP的。

实际上这个堆可以退化成只用一个变量实时维护最小值也行。这样时间就可以O(n)了。
当然这样做的话感觉上和DP就很像了。

两种解决方案都写在代码里了。
