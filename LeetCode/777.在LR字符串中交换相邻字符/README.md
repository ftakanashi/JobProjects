## 题目描述
在一个由 'L' , 'R' 和 'X' 三个字符组成的字符串（例如"RXXLRXRXL"）中进行移动操作。一次移动操作指用一个"LX"替换一个"XL"，或者用一个"XR"替换一个"RX"。现给定起始字符串start和结束字符串end，请编写代码，当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。

示例 :
```
输入: start = "RXXLRXRXL", end = "XRLXXRRLX"
输出: True
解释:
我们可以通过以下几步将start转换成end:
RXXLRXRXL ->
XRXLRXRXL ->
XRLXRXRXL ->
XRLXXRRXL ->
XRLXXRRLX
```

提示：
```
1 <= len(start) = len(end) <= 10000。
start和end中的字符串仅限于'L', 'R'和'X'。
```

### 解法1 模拟
这题看似要用DFS暴力搜索。实际上并没有那么复杂。
应当注意到，用一个`LX`替换一个`XL`，相当于是指可以把X看做空位而让任意`L`向左移动任意格数。
同理，对`R`而言也是类似的。

因此，可以翻译一下这道题的题意，是指我是否可以通过将任意`L`左移以及`R`右移，从start变换到end。

再深入解析一下，其实本质是这样的：在所有的LR的相对位置不变（即去除了所有X之后两个字符串应该相同）的前提下，
是否所有的L和R的下标都符合，同次序的L，start中的下标总是大于等于end中的下标；R则反之。

再配合上长度是否相等之类的最基本的判定，就可以得到结果。
具体看代码。

### 解法2 双指针
这里提供一种更加简洁明了的解法。

用`i`和`j`两个指针分别扫描start和end，并且跳过其中所有的`X`。
当两边碰到非`X`字符时，首先看两头字符是否一样，若不一样则直接False。

若一样，则判断`i`和`j`的相对大小关系，判断规则同上个解法。
即若字符是`L`，则必定要有`i >= j`，反之则是`i <= j`。

另外还需要额外考虑一个情况就是当某个字符串遍历完了而另一个还没有时，
另一个剩下的字符是否都是X，若是则也是符合条件的。

具体看代码。