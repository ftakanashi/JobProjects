## 题目描述
给出一个字符串 s（仅含有小写英文字母和括号）。

请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。

注意，您的结果中 不应 包含任何括号。

示例 1：
```
输入：s = "(abcd)"
输出："dcba"
```
示例 2：
```
输入：s = "(u(love)i)"
输出："iloveu"
```
示例 3：
```
输入：s = "(ed(et(oc))el)"
输出："leetcode"
```
示例 4：
```
输入：s = "a(bcdefghijkl(mno)p)q"
输出："apmnolkjihgfedcbq"
```

提示：
```
0 <= s.length <= 2000
s 中只有小写英文字母和括号
我们确保所有括号都是成对出现的
```

### 解法1 栈
充满着可以用栈 或者 DFS 做的气息……

以栈为例，思路很简单。挨个扫描，碰到右括号时不断pop栈直到pop到左括号。
期间pop出来的字符们要反转。

当然由于栈pop顺序天然就反转，所以直接顺水推舟，将pop得到的东西再按顺序压入栈。

当然这种做法在嵌套很深的test case中会有很多无意义的反转操作。
这部分应该是可以优化一下的。

### 解法2 递归 一次遍历
当输入确定之后，其实对于每个一个括号内的内容，是否需要逆序，只要看其外面嵌套了几层括号即可。

对于嵌套了奇数层括号的内容，需要逆序；嵌套了偶数层的内容，无需逆序，直接将其按序取出即可。

另外，下一层内容和本层之前内容之间如何安排顺序也要看本层是否是逆序的。因此构建一个递归函数如下：
```python
def rec(start, rev):
    if start == n: return [], start
    i = start
    res = []
    while i < n and s[i] != ')':
        if s[i] != '(':
            if rev: res.insert(0, s[i])
            else: res.append(s[i])
            i += 1
        else:
            sub_res, end = rec(i + 1, not rev)
            if rev: res = sub_res + res
            else: res = res + sub_res
            i = end + 1
    return res, i
```
start表示扫描到的子串的开始位置（不包括左括号），而rev表示当前这个子串部分是否是逆序的。
所有字母都只被扫描到一次，因此这个做法是O(n)的。


### 解法3 递推 + 一次遍历
很巧妙的一个办法。
首先通过栈，先把每个左括号和右括号 之间的对应关系确定。具体的，栈中压入下标，并且维护一个和s等长的数组。左右括号下标处的值分别保存对方的下标。
这样用一个数组就可以将所有左右括号之间的对应关系给抽取出来。

接着，初始化扫描方向为从左到右（direc为1）并开始扫描。
当碰到左括号时，确定其匹配的右括号位置，然后从那个位置反过来扫。反过来扫的过程中可能会碰到更底层的右括号，这时再将这个底层右括号匹配的左括号
找出，然后从那开始再次从左到右扫。

以上过程，用递推实现并不是很方便。这也是巧妙的地方所在。
比如`(ed(et(oc))el)`这个输入，le -> et -> co三个单元扫描完之后，原本如何让指针跳回d，从而将剩下的de也扫出来是个难点。
而在给出的代码中，巧妙的将direc进行反向。这样一反向，一层层就把指针给返回去了。