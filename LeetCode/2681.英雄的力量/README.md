## 题目描述
给你一个下标从 0 开始的整数数组 nums ，它表示英雄的能力值。如果我们选出一部分英雄，这组英雄的 力量 定义为：

i0 ，i1 ，... ik 表示这组英雄在数组中的下标。那么这组英雄的力量为 max(nums[i0],nums[i1] ... nums[ik])2 * min(nums[i0],nums[i1] ... nums[ik]) 。
请你返回所有可能的 非空 英雄组的 力量 之和。由于答案可能非常大，请你将结果对 109 + 7 取余。

示例 1：
```
输入：nums = [2,1,4]
输出：141
解释：
第 1 组：[2] 的力量为 22 * 2 = 8 。
第 2 组：[1] 的力量为 12 * 1 = 1 。
第 3 组：[4] 的力量为 42 * 4 = 64 。
第 4 组：[2,1] 的力量为 22 * 1 = 4 。
第 5 组：[2,4] 的力量为 42 * 2 = 32 。
第 6 组：[1,4] 的力量为 42 * 1 = 16 。
第​ ​​​​​​7 组：[2,1,4] 的力量为 42​​​​​​​ * 1 = 16 。
所有英雄组的力量之和为 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141 。
```
示例 2：
```
输入：nums = [1,1,1]
输出：7
解释：总共有 7 个英雄组，每一组的力量都是 1 。所以所有英雄组的力量之和为 7 。
```

提示：
```
1 <= nums.length <= 105
1 <= nums[i] <= 109
```

### 解法 DP 前缀和
题意不难理解，而且朴素的做法非常好想到。

不难发现，一个子序列的最大值和最小值固定之后，中间部分如何取值并不影响最终的力量值。
所以，很自然想到可以先对数组进行一次排序。然后双重循环遍历数组，确定一个范围。
当范围的左右断电就是一个子序列中的最小值和最大值时，中间的数无论怎么取最终力量值都不变。
因此单纯的一个乘号就可以搞定了。

问题是，上面算法中用到了双重循环，复杂度为n^2，而数据长度最大是10000，因此直接暴力做肯定是会超时的。

注意到，确定了某个值比如`nums[i]`作为子序列的最大值之后，其对应的最小值的可能性是其左边的所有数字，（严格来说，
还需要算上它自己，即序列中只有一个`nums[i]`的情况）且这些数字大多数都会出现多次。

而这些序列的力量的总和，其实是`sum(nums[i] * nums[i] * x)`，此时`nums[i]`是个定值，所以可以转化成
`nums[i] * nums[i] * sum(x)`。其中`sum(x)`表示以`nums[i]`为结尾的所有子序列对应的最小和的总和。

然后发现，这个值其实是一个在从左到右遍历过程中，可以累计计算的值，换言之，是一个通过DP可以获得的值。
我们定义上述`sum(x)`为`dp[i]`，其具体含义是 所有以`nums[i]`为末尾的所有子序列中，对应的最小值的总和（显然这些子序列中最大值就是`nums[i]`）。
显然`dp[0] = nums[0]`。而对于`i > 0`的情况，有`dp[i] = nums[i] + sum(dp[:i])`。
相当于是说`dp[i]`是之前所有dp值即`i`左边所有位置的对应最小值和的总和（有点拗口…）再加上当前位置的`nums[i]`（其实就是算上了单数字序列的情况）

而上述状态转移方程中，`sum(dp[:i])`又是一个需要O(n)时间来计算的值。这可以用一个前缀和来简化。
而实际上这题中我们关心的只是`presum[i+1] - presum[0]`，所以实际上前缀和数组都不用建立出来，直接一个累加就行了。

综上所述，最终只需要一次循环，循环中兼顾
1. dp值的更新
2. 前缀和的更新
3. 答案的累加
就可以了。另外别忘了对MOD取余。具体细节见代码

另外多说一句，给出的代码中不难看出，`dp[i]`也之和`dp[i-1]`有关，所以实际上dp数组也可以做空间压缩。不过懒得搞了…
