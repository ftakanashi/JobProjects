## 题目描述
在一根无限长的数轴上，你站在0的位置。终点在target的位置。

你可以做一些数量的移动 numMoves :

每次你可以选择向左或向右移动。
第 i 次移动（从  i == 1 开始，到 i == numMoves ），在选择的方向上走 i 步。
给定整数 target ，返回 到达目标所需的 最小 移动次数(即最小 numMoves ) 。

示例 1:
```
输入: target = 2
输出: 3
解释:
第一次移动，从 0 到 1 。
第二次移动，从 1 到 -1 。
第三次移动，从 -1 到 2 。
```

示例 2:
```
输入: target = 3
输出: 2
解释:
第一次移动，从 0 到 1 。
第二次移动，从 1 到 3 。
```

提示:
```
-109 <= target <= 109
target != 0
```

### 解法 二分 数学
这题还挺有意思的。乍一看，似乎可以通过DFS暴力解开，但实际仔细思考一下会发现还是有门道的。

首先，一个显而易见的事实是，如果target是一个负数，那么其实和其相反数返回的答案是一样的，
因为数轴是对称的，只需要将所有操作中的向左和向右反过来即可。
因此问题简化到只需要考虑所有target大于0的情况。

接着，我们设`sum(x)`函数的值为`1 + 2 + ... + x`，即`(1 + x) * x // 2`。
显然，当某个target恰好是`sum(x)`的话，那么直接返回`x`即可，这必然是最快的捷径。

但若不是呢。比如`sum(9)`是45，如果target是43或者41，可以发现，仍然很方便，只要将之前的1-9的各个数字中的某一些改成负的就行了。
因为target和比其更大且最接近的一个`sum(x)`之间的差是偶数。并且这个差值的一半必然是之前1-x中的某个数，将这个数的符号改成负的，
就可以以最小的代价达到target。

可如果差是奇数呢？比如44或者42。
此时，我们仍然优先考虑将某些数字的符号改为负的，但是因为是奇数，当前情况是不可能恰好凑出来的。
所以我们退而求其次，取`sum(x+1)`。

由于`sum(x)`的奇偶性是两个两个一周期的，所以我们最多只需要检查`sum(x+1)`和`sum(x+2)`，就必然可以找到那个偶的差值了。
更具体的， 当`x`本身是偶数时，我们只需要用`sum(x+1)`即可，否则要用`sum(x+2)`（脑补几个例子就能推出这个结论了。）
因此当差是奇数的时候最终返回的应该是`x + 1 + x & 1`

显然，找到比target更大但是最接近的`sum(x)`，找其中的这个`x`可以用二分搞定。
之后就是一些按照规则进行判断的操作了。

