## 题目描述
有 n 个盒子。给你一个长度为 n 的二进制字符串 boxes ，其中 boxes[i] 的值为 '0' 表示第 i 个盒子是 空 的，而 boxes[i] 的值为 '1' 表示盒子里有 一个 小球。

在一步操作中，你可以将 一个 小球从某个盒子移动到一个与之相邻的盒子中。第 i 个盒子和第 j 个盒子相邻需满足 abs(i - j) == 1 。注意，操作执行后，某些盒子中可能会存在不止一个小球。

返回一个长度为 n 的数组 answer ，其中 answer[i] 是将所有小球移动到第 i 个盒子所需的 最小 操作数。

每个 answer[i] 都需要根据盒子的 初始状态 进行计算。

示例 1：
```
输入：boxes = "110"
输出：[1,1,3]
解释：每个盒子对应的最小操作数如下：
1) 第 1 个盒子：将一个小球从第 2 个盒子移动到第 1 个盒子，需要 1 步操作。
2) 第 2 个盒子：将一个小球从第 1 个盒子移动到第 2 个盒子，需要 1 步操作。
3) 第 3 个盒子：将一个小球从第 1 个盒子移动到第 3 个盒子，需要 2 步操作。将一个小球从第 2 个盒子移动到第 3 个盒子，需要 1 步操作。共计 3 步操作。
```
示例 2：
```
输入：boxes = "001011"
输出：[11,8,5,4,3,4]
```

提示：
```
n == boxes.length
1 <= n <= 2000
boxes[i] 为 '0' 或 '1'
```

### 解法 两次遍历
题意不难理解，而且如果暴力来做的话，两行就能搞定。
```python
class Solution:
    def minOperations(self, boxes: str) -> List[int]:
        indices = [i for i, ball in enumerate(boxes) if ball == '1']
        return [sum(abs(i-pos) for pos in indices) for i in range(len(boxes))]
```
第一行先过滤出所有在boxes中是1的下标。
第二行再计算每个位置和这些下标的差的绝对值的总和，就是答案了。

不过第二行针对每个位置都要进行一次遍历，所以总的复杂度在`O(n^2)`。
好在整体数据长度也不是太长，总的来看即便是暴力也可以搞定。

不过有更好的办法。
稍微借鉴一点DP的思想。

可以发现，如果把答案视为一个dp数组，在从左到右遍历的过程中，`dp[i]`是可以由`dp[i-1]`推得的:
```python
dp[i] = dp[i-1] + left - right
```

其中`left`和`right`分别指代`[:i]`和`[i:]`两个范围内1的个数。
相当于是说，如果所有球移动到`i-1`要`k`次的话，那么现在改为移动到`i`位置，则所有左侧的球（包括`i-1`位置的那个）都要多移动一次。
所有右侧的球（包括`i`位置的那个）都可以少移动一次。

总的方案，首先需要确定`dp[0]`的值，这个只能通过一次遍历来搞定。而在遍历的同时其实我们可以得到总的1的个数。

接着第二次遍历，遍历时一方面维护一个`left`值，同时根据`total`减去`left`可以得到`right`。
第二次遍历从左到右地把所有`dp`值都填满，就得到答案了。