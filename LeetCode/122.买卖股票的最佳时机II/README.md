## 题目描述
给定一个数组，它的第 `i` 个元素是一支给定股票第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
 

示例 1:
>输入: [7,1,5,3,6,4]
>
>输出: 7
>
>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

示例 2:
>输入: [1,2,3,4,5]
>
>输出: 4
>
>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

示例 3:
>输入: [7,6,4,3,1]
>
>输出: 0
>
>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
 

提示：
- 1 <= prices.length <= 3 * 10 ^ 4
- 0 <= prices[i] <= 10 ^ 4

### 解法1 贪心
这题某种意义上比LC.121还简单。因为其贪心思想更加明显。

由于不限制交易次数，那么最简单的做法，就是"见利就走"。从左到右扫描的过程中，只要遇到上升序列，默认就在上升序列的左端点买入，右端点卖出。

易证，任意`a < b`的两个数之间，期间插入任意个任意值的点，这些点的累计上升序列差的和（即题意中的股票买卖得到的总利润）肯定大于单纯的`b - a`。

因此确立了贪心的思想，只要有的赚，立马就卖掉。

当然在连续的上升子序列中，比如`a < b < c`的情况，虽然实际操作中不需要在`b`的时候先卖出再买入，
但是为了算法方便，可以计算`(b - a) + (c - b)`来等价`c - a`。

### 解法2 DP
考虑这样一个情况：由于最终是为了求出利益的最大值。

而实际上，每天的利益最大值是由前一天的利益最大值以及，前一天手中股票的持有情况共同决定的。

于是，可以设计如下DP算法，

状态分成"某天收盘之后手上没有股票"和"某天收盘之后手上持有股票"两种情况时，手头的累计收益。
（由于统计的是累计收益，所以不需要计算净收益（卖出价-买入价），只需要买入的时候减去买入价，卖出的时候加上卖出价即可。）

对于前一种情况
- 如果前一天手上也没有股票，那么显然今天没有做交易，所以沿用前一天的值。
- 如果前一天手上有股票，那么说明今天卖出了这个股票。收益应该加上今天的卖出价。

对于后一种情况
- 如果前一天手上没有股票，那么今天买入了股票。收益应该减去今天的买入价。
- 如果前一天手上有股票（注意是收盘时），因为题目规定不能持有时再买入，所以沿用前一天的值。

综上所述，状态转移方程如下
```python
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][0] - prices[i], dp[i-1][1])
```

最后输出`max(dp[-1])`即可。实际上因为最后一天持有股票情况的累计收益必然比空仓时的低，所以直接输出`dp[-1][0]`也可以。

注意初始化值，第一天收盘时如果持有股票则累计收益是负的。即`dp[0][1] = -prices[0]`

### 解法3 状态压缩DP
上述解法2中的DP数组，显然其从左到右依次填充值，并且最终也只用了最右端的值。

所以可以把数组压缩成两个变量。其余思想不变。
