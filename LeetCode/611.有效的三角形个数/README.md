##题目描述

给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。

示例 1:
>输入: [2,2,3,4]
>
>输出: 3
>
>解释:
>
>有效的组合是: 
>
>2,3,4 (使用第一个 2)
>
>2,3,4 (使用第二个 2)
>
>2,2,3

注意:
- 数组长度不超过1000。
- 数组里整数的范围为 [0, 1000]。


### 前言
暴力就不说了。

三角形成立的判别条件，是两边之和大于第三边。
显然，就像sum3或者三角形的最大周长之类的题目一样，先预处理排序一下是个好办法。
这样依次从左到右扫描如果发现i + j <= k了，那么k右边的所有数都不用管，且j到k间的所有数字都成立。

### 解法1 二分查找
基于上述前言中的思路。

针对一个已经排好序的数组，首先枚举两个游标是不可避免的了，即i,j。

设置好i,j之后，接下来的工作，是在j右边剩余的数组中，找到一个位置k，
使得`nums[k]`是第一个大于等于`nums[i] + nums[j]`的位置。

找位置k的工作当然可以从左到右依次遍历，不过那样还是O(n),算上i,j的遍历最终还是O(n^3)。

另一方面，一个序列里根据条件找k，二分查找嘛！

所以第一个办法就是枚举i,j，针对每对i,j，在`[j+1:]`的剩余序列中进行二分查找。
每查找到一个位置k，`count += (k - j - 1)`。

总体时间是O(n^2 * logn)的。

### 解法2 双指针
思路稍微回溯一点，当每对i,j确定，开始找k时，遍历真的不行么？

如果傻傻地每次都从j+1开始遍历，显然还是暴力法。

但是实际上，上一次针对具体的i,j找到了位置k之后，
下一步一般是`j += 1`，此时针对这对新的i,j，必然有
更大的`nums[i] + nums[j]`。换句话说，上一轮寻找k的过程中决定的k，
其左边的所有数必然在这一轮中也成立。因此没必要重新从j+1开始遍历，k直接在当前位置开始即可。

至于i更新的时候，稳妥起见，需要重置k为i+2。

因为可能存在这种例子：
`2,2,3,3,....,100,100`
当i是第一个2的情况，j迭代完最终时，j是倒数第二个100，而k是最后一个100。

接着，i,j重置成1,2，此时显然2+3并不大于100，因此k可不能让他还保持在最后一位。

换句话说，在j一直往右扫描的过程中，由于j数不会减少，所以可以放心说，k可以一直往右移。但是如果j一下子跳回左边去了，k自然也就得从新扫描了。

因为k始终需要保持在j的右边，所以当j和k等值的时候，也需要把k右移一位。

这个方法中，每固定一个i之后，j和k都是不走回头路地向右扫描，所以固定i时复杂度是O(n)的。
乘上n个i，总体复杂度O(n^2)