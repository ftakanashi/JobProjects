## 题目描述
给定一个长度为 n 的整数数组 A 。

假设 Bk 是数组 A 顺时针旋转 k 个位置后的数组，我们定义 A 的“旋转函数” F 为：
```
F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]。
```
计算F(0), F(1), ..., F(n-1)中的最大值。

注意:可以认为 n 的值小于 105。

示例:
```
A = [4, 3, 2, 6]

F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26

所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。
```

### 解法 找规律模拟 （简易DP）
这题是这么回事：
给出一个数组如`a, b, c, d`。可以计算其一个对应值`sum(i * nums[i] for i in range(len(nums)))`。

接着，将数组做一个所谓的顺时针旋转。
即将数组的最后一个数字拿到头上，剩余往后推一格。
针对旋转后的数组可以重新求值。
以此类推，可以获得n个值（原数组的值与n-1次旋转后的n-1个值）。

求这n个值中的最大值。

暴力解法当然是模拟旋转并且求值。但是显然每次求值都是`n`。
于是很自然地想到了看看能否用更快捷的办法求出旋转后的值。
即，旋转一次后，要求的值是否和之前的值有什么联系。
找到这层联系，往往就可以用O(1)的时间求出新值了，这也是说这种做法也是一种简易DP的原因。

我们来看，针对`a b c d`这样一个数组，其旋转过程中所求值的变化过程是
```text
t1 = b + c + c + d + d + d
t2 = a + b + b + c + c + c
...
```
仅从上面这一次旋转中就可以看出。t1和t2之间差了`a + b + c`。
于是很容易总结出规律，设当前数组是`nums`，数组单项总和是`s`，上一次所求值是`t0`的话，
当前所求值的推导公式是
```text
t = t0 - (n-1) * nums[-1] + (s - nums[-1])
```

加上题目明确说了`n`次旋转，即每种旋转后的pattern都会被照顾到。
因此，我们就直接从尾巴开始扫描一遍全数组，依次套用上述公式进行状态递推即可。