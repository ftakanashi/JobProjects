## 题目描述
给定一棵二叉搜索树和其中的一个节点 node ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 null 。

一个节点 node 的中序后继是键值比 node.val 大所有的节点中键值最小的那个。

你可以直接访问结点，但无法直接访问树。每个节点都会有其父节点的引用。节点 Node 定义如下：
```
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node parent;
}
```

示例 1：
```
输入：tree = [2,1,3], node = 1
输出：2
解析：1 的中序后继结点是 2 。注意节点和返回值都是 Node 类型的。
```
示例 2：
```
输入：tree = [5,3,6,2,4,null,null,1], node = 6
输出：null
解析：该结点没有中序后继，因此返回 null 。
```
示例 3：
```
输入：tree = [15,6,18,3,7,17,20,2,4,null,13,null,null,null,null,null,null,null,null,9], node = 15
输出：17
```
示例 4：
```
输入：tree = [15,6,18,3,7,17,20,2,4,null,13,null,null,null,null,null,null,null,null,9], node = 13
输出：15
```
示例 5：
```
输入：tree = [0], node = 0
输出：null
提示：
树中节点的数目在范围 [1, 104] 内。
-105 <= Node.val <= 105
树中各结点的值均保证唯一。
进阶：你能否在不访问任何结点的值的情况下解决问题?
```

### 解法 按情况遍历模拟
题目有点长，简单概括一下。
就是给你一个BST中的某个节点，然后让你找出这个BST中，比这个节点大一点的节点。

按照直觉来说，既然你是个BST，那么大多数情况下，答案的节点应该就是输入节点的右子树的最左下角节点了。
这个是没毛病的。

当然，对于有些情况节点可能没有右子树，此时就需要稍微思考一下了。
像示例2中的6，由于其本身是整个树的最右边节点，自然不存在更大的值，所以直接返回None。
而对于示例4的13，我们可以看出来，虽然其没有右子树，但是其仍然有比其大一点的值，这个值需要我们通过回溯parent去找。
具体来说，回溯parent的过程中，我们需要判断当前的节点是parent节点的左子节点还是右子节点。

对于是右子节点的情况，可知parent的值必然小于我们当初输入的节点的值，继续往上回溯。
对于左子节点的情况，说明已经找到了比输入值更大的值，此parent就是答案。

按照上述思路写代码即可。
值得注意的是，这个算法全程没有访问节点的值，单纯只是通过节点间关系来做的判断。