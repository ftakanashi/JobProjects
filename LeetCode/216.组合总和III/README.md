## 题目描述
找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：
- 所有数字都是正整数。
- 解集不能包含重复的组合。 

示例 1:
```
输入: k = 3, n = 7
输出: [[1,2,4]]
```
示例 2:
```
输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
```

### 解法1 DFS
这里由于有k和n两个限制条件，因此dfs函数按照经典套路，设计成
`def dfs(rest_k, rest_n, path)`。
当`rest_k == 0` 且 `rest_n == 0`的时候收割path进结果。

为了能够利用记忆化机制，可以将path设计成元组而非列表，从而可以hash。

在dfs函数内部时，则需要注意，因为答案要求每种组合不存在重复数字，因此探索总是从当前path的最大数+1开始。

### 解法2 DP（背包）
不难发现，其实这道题是一个恰好装满容量的01背包问题。

只不过一般背包问题求的是最值或者组合数之类，一个数字的解，而这里要求输出所有可能解的组合。

于是采用比较暴力的办法，DP数组里我就直接保存每个情况下，所有解的组合的可能性，不管组合长度是多少。

DP数组初始化时每个位置都是一个列表。
根据01背包-恰好装满的情况设计状态转移方程：
```python
# 不取i的情况
dp[i][j].extend(dp[i-1][j])

# 取i的情况
if j - i == 0: dp[i][j].append((i, ))
if j - i > 0 and len(dp[i-1][j-i]) > 0:
    dp[i][j].extend(l + (i,) for l in dp[i-1][j-i])
```
对上述转移转移方程稍作解释。
由于不是求最值之类的值，所以要把规划过程中前面所有的情况都搜罗起来。

因此，不取i的情况的时候，直接将`dp[i-1][j]`中的答案全部加入进来。

其次，如果取i，此时分成两种情况讨论。
如果`j - i == 0`，此时`dp[i-1][j-i]`必然是空列表（第一行）。
那么使用extend方法会没有变化。但是实际上，我们想将`(i,)`这个答案加入`dp[i][j]`的结果列表中。
因此单独拿出来讨论。

另外，如果`j - i > 0`，则按照一般01背包的套路走就行。
注意因为要恰好装满，所以还需要检查一下`dp[i-1][j-i]`中的结果列表是否有结果。如果有，说明取i可以恰好装满，否则取了i也没用。
总之就是恰好装满的额外讨论条件。

按照以上算法推算出的`dp[-1][-1]`中，包含了所有可能的取法。
比如`n=7`的情况，上述结果是`[(1, 2, 4), (3, 4), (2, 5), (1, 6), (7,)]`。

最后从中取出长度为`k`的结果即可。

上述方法看起来很没有效率，姑且算是对背包问题的小复习吧。