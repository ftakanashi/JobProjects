## 题目描述
给你一个披萨，它由 3n 块不同大小的部分组成，现在你和你的朋友们需要按照如下规则来分披萨：

你挑选 任意 一块披萨。
Alice 将会挑选你所选择的披萨逆时针方向的下一块披萨。
Bob 将会挑选你所选择的披萨顺时针方向的下一块披萨。
重复上述过程直到没有披萨剩下。
每一块披萨的大小按顺时针方向由循环数组 slices 表示。

请你返回你可以获得的披萨大小总和的最大值。

示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/sample_3_1723.png)
```
输入：slices = [1,2,3,4,5,6]
输出：10
解释：选择大小为 4 的披萨，Alice 和 Bob 分别挑选大小为 3 和 5 的披萨。然后你选择大小为 6 的披萨，Alice 和 Bob 分别挑选大小为 2 和 1 的披萨。你获得的披萨总大小为 4 + 6 = 10 。
```
示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/sample_4_1723.png)
```
输入：slices = [8,9,8,6,1,1]
输出：16
解释：两轮都选大小为 8 的披萨。如果你选择大小为 9 的披萨，你的朋友们就会选择大小为 8 的披萨，这种情况下你的总和不是最大的。
```

提示：
```
1 <= slices.length <= 500
slices.length % 3 == 0
1 <= slices[i] <= 1000
```

### 解法 DP
某次能取哪块披萨，取决于之前的选择，很明显的DP场景。
不过这题的DP也是比较难构建的。我们慢慢来看。

首先，需要将这个问题抽象化。
对于一个以数组形式表现的披萨，可以证明，实际上题意是让我从长度为`3n`的数组中任取`n`个初始状态下不相邻的数字，
使得这些数字的总和可以达到最大。

直观的想，比如有这么一个序列 `123456789`，当我第一次取走2之后，显然1和3也一起被拿走了。此时我的下一个选择可能是4。
此时5和9会被拿走。
你可能会想， 5和2没有相邻，此时是不是剥夺了同时取5和2的可能性呢？但是别忘了5被拿走的前提是第二步我拿了4。
相当于此时如果想拿5，那么手头上所有数字就会变成2、4、5，而4和5相邻，所以是和条件冲突的。

以上等价更加严谨的证明可以看官答（看了半天我没看懂…）这里就不多说了。

那么在抽象出问题后该怎么做呢？
首先，这里数组是一个环形数组，有个难点就是如何保证数字首尾的相邻性。这其实是个小trick，参考`LC.213`，可以将数组
分别掐头去尾，分别进行一次DP，取大者就行。

现在问题进一步简化成，当不考虑环形的情况，怎么做。
首先还是来定义DP值，我们定义`dp[i][j]`表示数组的前下标`i`个数字中，恰好选取`j`个不相邻数字时，能够获取到的最大数字和。
显然，dp的size是`3n * n`。
那么碰到一个数字后，我们可以选择选取他，此时dp值从`dp[i-2][j-1]`转移而来（因为`i-1`和`i`相邻不能被选了）；
或者不选，dp值是`dp[i-1][j]`。
换言之，状态转移方程为：
```python
dp[i][j] = max(dp[i-2][j-1] + nums[i], dp[i-1][j])
```

观察这个方程，容易发现，状态依赖到`i-2`的，所以初始状态需要初始化所有`dp[0:2]`，即前两行都要初始化。
这里的DP初始值也是个挺麻烦的点…

首先，对于`dp[0][0]`和`dp[1][0]`，没什么可说的，取出0个数，总和必然还是0。
`dp[0][1]`则就是`nums[0]`。
`dp[1][1]`则需要看`nums[0]`和`nums[1]`中较大的。
而对于所有`j > 1`的情况，相当于是要在前两个数字中选超过两个数字，显然是不可能的。
但是这部分值又有可能会参与到后面dp值的计算中。为了避免这部分值参与计算影响结果，可以将这部分值置为负无穷。

DP完成后，最终返回的答案可以是最后一行的最大值，`max(dp[-1])`。

至此所有思路齐了。注意以上是针对一次DP的过程。按照最开始的说明， 需要针对`slices[1:]`和`slices[:-1]`做两次DP，取结果较大值。
详细说明看代码注释吧。