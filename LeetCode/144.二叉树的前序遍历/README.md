##题目描述

给定一个二叉树，返回它的 前序 遍历。

示例:

>输入: [1,null,2,3]
```text  
   1
    \
     2
    /
   3 
```
>输出: [1,2,3]


进阶: 递归算法很简单，你可以通过迭代算法完成吗？


### 解法1 递归
不解释

### 解法2 栈迭代
以前书上看到过，二叉树的遍历还可以通过外置一个栈来实现。
前序遍历的逻辑也并不复杂。

从最开始的root开始，依次yield值到res中，然后依次把右子树，左子树push到栈中（因为后面是先处理左子树再处理右子树）
当某个子树为空时，就不必放入栈。
之后，从栈中每取出一个子树，就进行yield，右子树入栈，左子树入栈，这样的操作即可。


上述无论是解法1还是解法2，时间都是O(n)因为每个节点都要遍历一遍。
而空间来说，都是平均情况是O(logn)而最坏情况（单侧链条树，即变成一个链表）O(n)。
其实解法2是一个手动对递归的模拟。

### 解法3 Morris遍历
这种遍历法，不需要任何额外空间，所以是时间O(n)空间O(1)的。

>有一种巧妙的方法可以在线性时间内，只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply
」中首次提出，因此被称为 Morris 遍历。
>
>Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下：
>
>1. 新建临时节点，令该节点为 root；
>
>2. 如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；
>
>3. 如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点：
>
>    - 如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。然后将当前节点加入答案，并将前驱节点的右子节点更新为当前节点。
>
>    - 如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。
>
>重复步骤 2 和步骤 3，直到遍历结束。

以上来自LeetCode官方解释。

补充说明一些内容：

所谓的中序遍历下的前驱节点，即中序遍历序列中，root节点前面那个节点。换句话说，即root节点的左子树的"右下叶节点"。

