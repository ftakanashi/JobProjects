## 题目描述
给你一个字符串 s ，它仅包含字符 'a' 和 'b'​​​​ 。

你可以删除 s 中任意数目的字符，使得 s 平衡 。当不存在下标对 (i,j) 满足 i < j ，且 s[i] = 'b' 的同时 s[j]= 'a' ，此时认为 s 是 平衡 的。

请你返回使 s 平衡 的 最少 删除次数。

示例 1：
```
输入：s = "aababbab"
输出：2
解释：你可以选择以下任意一种方案：
下标从 0 开始，删除第 2 和第 6 个字符（"aababbab" -> "aaabbb"），
下标从 0 开始，删除第 3 和第 6 个字符（"aababbab" -> "aabbbb"）。
```
示例 2：
```
输入：s = "bbaaaaabb"
输出：2
解释：唯一的最优解是删除最前面两个字符。
```

提示：
```
1 <= s.length <= 105
s[i] 要么是 'a' 要么是 'b'​ 。​
```

### 解法 字符串 模拟
题意不难理解。
很容易想到，要达成题目中说的平衡状态，只有以下三种情况
- 字符串中全是a
- 字符串中全是b
- 字符串匹配`a+b+`

前两种情况的删除次数很好算，直接计数即可。
而第三种情况，实际上就是要找到一条分界线，而删除次数就是这条分界线左边的所有b的数量和右边的所有a的数量。

想明白了这一点，问题就转化得很简单了。
具体的做法可以一次遍历搞定。比如初始化`l, r = 0, count('a')`，`l`和`r`分别表示分界线左边的`b`的数量和右边的`a`的数量。
起始状态下两者的初始值是`0`和`count('a')`。

然后从左到右遍历，遍历到一个字母是`a`时，就将`r -= 1`，是`b`时将`l += 1`。
此时`l`和`r`就代表分界线在这个字母后面时的情况，收割`l + r`的全局最小值即可。