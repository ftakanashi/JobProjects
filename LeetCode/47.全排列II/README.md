## 题目描述
给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

示例 1：
>输入：nums = [1,1,2]
>
>输出：
>[[1,1,2],
> [1,2,1],
> [2,1,1]]

示例 2：
>输入：nums = [1,2,3]
>
>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
 

提示：
- 1 <= nums.length <= 8
- -10 <= nums[i] <= 10

### 解法 基于选择的递归
`LC46`中的做法在这题不适用。
因为当允许重复元素存在时，最终结果去重还挺麻烦的。

这里转变思路，对于可以重复的情况，要关注到每个数是一个独立的存在。
因此采用选择的思路。
每个排列的长度和原数组一定是相等的，因此可以从0开始判断每个位置选用哪个数字。
使用一个counter维护还可以使用的数字递归。

和上题一样，注意递归过程中的copy以节省空间。

### 解法2 基于交换的回溯法 LC46解法加强版
base是LC46，没有重复数字时基于交换的回溯法。

相比于46题中没有重复数字的情况，这里有重复数字，因此碰到下面这种情况
```text
1 2 3 2
```
假设碰到这个情况时dfs的pos参数是1，那么固定第二个数字是2或者和其后面的3交换一下都没问题。
当要交换最后一个2到第二个数字位置时，显然，开头固定是`1 2`的在刚才就已经遍历过了。

因此，在每次进行开始于pos位置的dfs时，都要设置一个seen的set，将`seen.add(x)`，即告诉后面的遍历轮，
当pos位置安排为值x的情况前面已经检查过了，没必要继续检查。
如此便可避免最终输出中的很多重复。
