## 题目描述
给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

示例 1：
>输入：nums = [1,1,2]
>
>输出：
>[[1,1,2],
> [1,2,1],
> [2,1,1]]

示例 2：
>输入：nums = [1,2,3]
>
>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
 

提示：
- 1 <= nums.length <= 8
- -10 <= nums[i] <= 10

### 解法 基于选择的递归
`LC46`中的做法在这题不适用。
因为当允许重复元素存在时，最终结果去重还挺麻烦的。

这里转变思路，对于可以重复的情况，要关注到每个数是一个独立的存在。
因此采用选择的思路。
每个排列的长度和原数组一定是相等的，因此可以从0开始判断每个位置选用哪个数字。
使用一个counter维护还可以使用的数字递归。

和上题一样，注意递归过程中的copy以节省空间。