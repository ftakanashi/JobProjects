## 题目描述
假如有一排房子，共 n 个，每个房子可以被粉刷成 k 种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。

当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x k 的矩阵来表示的。

例如，costs[0][0] 表示第 0 号房子粉刷成 0 号颜色的成本花费；costs[1][2] 表示第 1 号房子粉刷成 2 号颜色的成本花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。

注意：所有花费均为正整数。

示例：
```
输入: [[1,5,3],[2,9,4]]
输出: 5
解释: 将 0 号房子粉刷成 0 号颜色，1 号房子粉刷成 2 号颜色。最少花费: 1 + 4 = 5; 
     或者将 0 号房子粉刷成 2 号颜色，1 号房子粉刷成 0 号颜色。最少花费: 3 + 2 = 5.
```
``` 
进阶：
您能否在 O(nk) 的时间复杂度下解决此问题？
```

### 解法 带有辅助变量的DP
用DP应该没什么疑问，状态定义和转移方程也不难写。

显然，DP数组是一个和`costs`大小相同的二维矩阵。
`dp[i][j]`表示前`i`个房子在第`i`个房子刷`j`色时可以取到的最小cost。
显然`dp[0] == costs[0]`。

接下来是状态转移方程。
对于任意的`dp[i][j]`，可以发现，其应该等于`min(dp[i-1][k] for k != j) + costs[i][j]`。
其他没有情况了，所以状态转移方程也就是这简简单单的一句话。

只是，在查找`min(dp[i-1][k] for k != j)`的过程中，要对上一行的`k-1`个元素进行扫描以确定最小值。
这就导致整体时间复杂度来到`O(n*k*k)`。

为了能够在O(nk)内解决问题，显然可以设置一个外部的辅助变量，用来记录每一行的最小值。
但是这样够了吗？因为还有判断条件`k != j`，换句话说，如果上一行最小值的列下标恰好和本位置列下标相同，
那么本位置不能取那个值作为最小值，此时应该取上一行的次小值作为baseline。

由于上述限制，所以我们需要三个变量，`min_cost`记录每一行最小值，`min_cost_i`记录每一行最小值的列下标，
而`sec_min_cost`记录每一行次最小值。

这样就可以通过下面这样的逻辑做到正确的选择baseline：
```python
for i in range(1, n-1):
    for j in range(k):
        baseline = min_cost if k != min_cost_i else sec_min_cost_i
        dp[i][j] = baseline + costs[i][j]
```

另外别忘了再填充dp的过程中也要实时记录当前行的这三个辅助变量的值，以便在开始下一行扫描的时候更新。