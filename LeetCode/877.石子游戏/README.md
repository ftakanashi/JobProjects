## 题目描述
亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。

游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。

亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。

假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。

示例：
```
输入：[5,3,4,5]
输出：true
解释：
亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。
假设他取了前 5 颗，这一行就变成了 [3,4,5] 。
如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。
如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。
这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。
```

提示：
```
2 <= piles.length <= 500
piles.length 是偶数。
1 <= piles[i] <= 500
sum(piles) 是奇数。
```

### 解法 博弈论推理
首先指出，这题是`LC.486`的一个特殊限定情况。因此，用`LC.486`的DP方法也可以做。DP做法写在了注释里。

另一方面，其实在写写画画一通之后，发现似乎先手是必胜的。

抱着想看看什么情况下先手会输的心态提交了一波`return True`，结果没想到直接AC了。。。

然后看了答案的数学证明如下。

因为题目限定了两个条件：
- 总石子数是奇数，因此无平局
- 石子堆数是偶数

据此我们可以将任意一个输入都表示为`a0, b0, a1, b1, ..., ak, bk`。
其中`ai`表示奇数位置的石子数，`bi`表示偶数位置的。
由于无平局，因此`sum(ai) != sum(bi)`，两者之间必然有一个大一个小。

另一方面，对先手来说，我可以第一步选`a0`，此时留给后手的就只有`b0, bk`两个选项。不论其选哪个，都会使得一个新的a组的数字（`a1` or `ak`）出来，
于是我可以选择之。以此类推，只要我第一步选择`a0`，从策略上来说我就可以选择出a组所有数，也就可以拿到`sum(ai)`的分数。
同理，第一步选择`bk`可以最终得到`sum(bi)`分数。

这么一来，因为两者中必然有一个更大，我只要提前计算一波，选择那个更大的分数，便可必胜。

以上证明了这个游戏的先手必胜规律，因此直接返回True就完事儿了。 