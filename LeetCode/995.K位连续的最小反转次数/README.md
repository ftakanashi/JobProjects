## 题目描述
在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。

返回所需的 K 位翻转的最小次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。

示例 1：
```
输入：A = [0,1,0], K = 1
输出：2
解释：先翻转 A[0]，然后翻转 A[2]。
```
示例 2：
```
输入：A = [1,1,0], K = 2
输出：-1
解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。
```
示例 3：
```
输入：A = [0,0,0,1,0,1,1,0], K = 3
输出：3
解释：
翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]
翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]
翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]
```

提示：
- 1 <= A.length <= 30000
- 1 <= K <= A.length

### 解法 贪心+滑动窗口+队列优化
>官方给出的基于差分数组的解法也太难懂了…

这题的基本思想并不复杂，虽然来不及严格证明，但是大概的操作思路还是容易想到的。

比如设置一个滑窗从左到右扫描，当左端点是0时就反转窗口内元素，否则继续向前扫描。
当剩余元素不足以支撑一个大小为K的窗口时检查窗口内所有元素，如果还有0，那么就返回-1，否则返回反转次数。

如上算法在几个示例上都可以通过，事实上写了代码后也跑过了一些简单的test case。

但是，当碰到一个长度30000，K是19000+的输入时超时了。

显然以上算法两层循环，其复杂度是O(nK)的。（虽然不觉得30000*19000很大…

于是只能想想办法如何节省时间。注意到，因为是01数组，所以我只要知道某个元素翻转了几次，甚至只要知道是奇数次还是偶数次，就可以决定其最终值。
而某一个元素翻转的话，在从左到右扫描的过程中，只可能是其左边K-1个元素作为左端点时翻转了。

因此，可以设置一个队列，扫描到某个元素时如果需要翻转其作为左端点时的子数组，就将其入队。而决定其要不要翻转，
则看其本身的值以及队列中存在奇数还是偶数个其左K-1个元素。

最后，当扫描的游标`i`大于`n - K`时，如果扫描到任意一个元素受到队列中其前K-1个元素翻转的影响最终变成了0，那么就返回-1。
否则就返回扫描过程中一直维护的翻转次数。

注意，根据某个元素的值以及队列中其前K-1个元素的个数决定其最终值，具体来说，可以是这样：
队列只维护下标在`[i-K+1,i]`之间的值，这样只要看队列长度即可，（同时也保证了队列最长不会超过K）。
而其最终值是0的条件可以表示为`(A[i] == 0 and len(q) & 1 == 0) or (A[i] == 1 and len(q) & 1 == 1)`。
或者更简洁的`(A[i] + len(q)) & 1 == 0`。