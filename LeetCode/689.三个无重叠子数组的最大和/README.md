## 题目描述
给你一个整数数组 nums 和一个整数 k ，找出三个长度为 k 、互不重叠、且 3 * k 项的和最大的子数组，并返回这三个子数组。

以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置（下标从 0 开始）。如果有多个结果，返回字典序最小的一个。

示例 1：
```
输入：nums = [1,2,1,2,6,7,5,1], k = 2
输出：[0,3,5]
解释：子数组 [1, 2], [2, 6], [7, 5] 对应的起始下标为 [0, 3, 5]。
也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。
```
示例 2：
```
输入：nums = [1,2,1,2,1,2,1,2,1], k = 2
输出：[0,2,4]
```

提示：
```
1 <= nums.length <= 2 * 104
1 <= nums[i] < 216
1 <= k <= floor(nums.length / 3)
```

### 解法 DP 背包变体 前缀和
官方解法给出的是多滑窗的思路。但是我感觉还是DP的解法更好懂一些。所以就尝试写了下DP。

其实这题的本质是一个变体背包问题。
背包内只能装3个物品，而一个物品的价值被表示成原数组中连续的k个数字的和。
在不重叠的条件下，最大化物品的价值。

这里倒没必要纠结于具体的物品表示，而是可以借鉴大的背包框架来思考。
比如，我们声明DP数组`dp[i][j]`用于表示装`i`个物品，且物品来源是前`j`个数字时，能够实现的最大价值。

借鉴背包思路，求`dp[i][j]`时针对数字`nums[j]`，可以有两种情况。
第一，不取数字`j`，那么显然`dp[i][j] = dp[i][j-1]`。
第二，取数字`j`，那么此时应该取`dp[i-1]`这行里找一个合理的base值。由于题目要求子数组之间不重叠，
也就是说，当取`j`的时候实际上是取了`nums[j-k+1:j+1]`这个片段。
所以第二种情况下，`dp[i][j] = dp[i-1][j-k] + sum(nums[j-k+1:j+1])`。

针对第二种情况，如果每次都去求`sum(nums[...])`，显然是不合理的。
这个地方显然也可以用前缀和来优化。所以上式可以改写成：
`dp[i][j] = dp[i-1][j-k] + presum[j] - presum[j-k-1]`

综上，这个DP的状态转移方程是
```python
dp[i][j] = max(dp[i][j-1], dp[i-1][j-k] + presum[j] - presum[j-k-1])
```
拿个例子来实际写了一下，发现没问题。

但是，题目要求的，是各个子数组起始位置的下标。而上面DP只能求出最大价值。
所以，要对DP过程进行进一步的改造，除了顾及最大价值的同时，还需要记录达到这个最大价值的"路径"。即各个子数组的起始位置。

为了达成这个目的，额外设计一个`path[i][j]`，用于记录价值达到`dp[i][j]`时的路径。
显然初始化状态下，`path[i][j] == []`。
接着，如果`dp[i][j]`采取`dp[i][j-1]`的值，那么`path[i][j] = path[i][j-1]`。
如果`dp[i][j]`采取`dp[i-1][j-k] + presum[j] - presum[j-k]`的值，那么
`path[i][j] = path[i-1][j-k] + [j-k, ]`，即在`i-1`个子数组的基础上新增了一个子数组，且这个子数组的起始下标是`j-k`。

最终，返回`path[-1][-1]`即可。

以上描述中，所有的`i`和`j`下标都没有严格标定，只是一个意思。
实际的DP数组因为size是`4 * (n+1)`的，且前缀和数组的长度也是`n+1`的，所以要小心一点。