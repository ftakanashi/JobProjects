## 题目描述
给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。

 

示例 1：
![](https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg)
```
输入：points = [[1,1],[2,2],[3,3]]
输出：3
```
示例 2：
![](https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg)
```
输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
输出：4
```

提示：
```
1 <= points.length <= 300
points[i].length == 2
-104 <= xi, yi <= 104
points 中的所有点 互不相同
```

### 解法 哈希表斜率计数
平面上给出两点就可以确定一条直线，而直线又可以用方程`y = kx + b`来表示。
所以，其实一个二元组`(k,b)`可以表示一条直线。

至于这题，我们先选定一个点，然后计算其他所有点和它形成直线的表达。
显然，如果出现了位于同一直线上的第三个点，第二个点和第三个点与基准点计算所得的`k,b`是重复的。
所以对`k,b`计数，最终取最大值，得到的就是"通过基准点时能够获得的最大同线点数"。

这时注意到，因为上面计算所得的直线，全部通过基准点，所以`k,b`只要确定一个即可确定直线。所以我们选择确定k。
换言之，我们只要统计其他所有点与基准点形成直线的斜率，将其计数，最终返回最大的计数即可。

当然，我们还需要遍历所有点作为基准点的情况。
这个遍历过程中我们没必要回头遍历，所以第二层遍历的抬头应该是类似于`for j in range(i+1, n)`这样的。

按照以上思路 写代码即可。通过两点坐标计算斜率`(y2 - y1) / (x2 - x1)`，若`x1 == x2`则值是无穷大。

#### 追记
这题看起来并不难，但是翻看了下以前别人的答案，发现代码更复杂一些。
仔细分析之后发现，这题的题设应该是被简化过了。

首先，以前这题没有`points`中所有点互不相同这个限制条件。
这就导致了，遍历过程中如果碰到`points[i] == points[j]`的情况，则应该额外跳过处理。
相应的，以这个点为基准点的counter基础值应该是这个点在points中的计数值。
此外以别的点作为基准点，计算其到这种重复点的计算时，counter加等的时候也应该加等重复点的计数值而非1。
总之就是要多写几个if条件分支。

另外，还有一个除法精度的问题。可能是因为后台的Python引擎升级了，所以上述将斜率`k = (y2 - y1)/(x2 - x1)`可以作为键传入counter。
但是这个k，因为是一个除法得到的浮点数，不一定完全精确。

比如一个离原点很远的点：`x, x`和其左下方的`x-1,x-1`。和原点一起考虑时，他们应该位于同一直线上，人手算斜率也都是1。
但是实际上计算机算的时候很可能会有`x / x`与`(x-1) / (x-1)`在小数点后多少多少位不同的情况。
此时按照上述算法就没办法将他们统计到一个counter的键值对里了。

上述除法精度引起的问题，可以通过最大公约数的办法来解决。
即针对除法`dy / dx`，不直接计算，而先通过gcd函数找到`gcd(dy, dx)`的最大公约数`g`。
然后将`dy //= g`, `dx //= g`。由于`//`是整数间的计算，不会有精度损失问题。

如果采用这种方法还有一个跟着的小问题。假如得到两组`dx, dy`分别是`1, -2`和`-1, 2`。
他们的`dy/dx`值相等，即是同一条直线，但是如果直接使用`(dx, dy)`这个元组作为标识，他们又是不同的。
所以这里，我们采用`(abs(dx), abs(dy), dy/dx的正负性)`作为标识。
第三项可以是-1，0，1中的一个。显然这可以通过一个逻辑判断来实现。

实现上述算法，只需要将目前给出的代码中的`analyze`函数替换成如下即可：
```python
def analyze(p1, p2):
    x1, y1 = p1
    x2, y2 = p2
    dy = y2 - y1
    dx = x2 - x1
    if dx == 0:
        k = (None, None, None)
    else:
        g = math.gcd(dy, dx)
        dy //= g
        dx //= g
        if dy == 0: flag = 0
        else: flag = -1 if (dy>0)^(dx>0) else 1
        k = (abs(dy), abs(dx), flag)
    return k
```