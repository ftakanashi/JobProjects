## 题目描述
给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。

返回 nums 中 所有 子数组范围的 和 。

子数组是数组中一个连续 非空 的元素序列。
 

示例 1：
```
输入：nums = [1,2,3]
输出：4
解释：nums 的 6 个子数组如下所示：
[1]，范围 = 最大 - 最小 = 1 - 1 = 0 
[2]，范围 = 2 - 2 = 0
[3]，范围 = 3 - 3 = 0
[1,2]，范围 = 2 - 1 = 1
[2,3]，范围 = 3 - 2 = 1
[1,2,3]，范围 = 3 - 1 = 2
所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 = 4
```
示例 2：
```
输入：nums = [1,3,3]
输出：4
解释：nums 的 6 个子数组如下所示：
[1]，范围 = 最大 - 最小 = 1 - 1 = 0
[3]，范围 = 3 - 3 = 0
[3]，范围 = 3 - 3 = 0
[1,3]，范围 = 3 - 1 = 2
[3,3]，范围 = 3 - 3 = 0
[1,3,3]，范围 = 3 - 1 = 2
所有范围的和是 0 + 0 + 0 + 2 + 0 + 2 = 4
```
示例 3：
```
输入：nums = [4,-2,-3,4,1]
输出：59
解释：nums 中所有子数组范围的和是 59
```

提示：
```
1 <= nums.length <= 1000
-109 <= nums[i] <= 109

进阶：你可以设计一种时间复杂度为 O(n) 的解决方案吗？
```

### 解法 单调栈
这题思路挺有意思的，而且细节很魔鬼，需要仔细思考一番。

看到这道题后，第一个能想到的办法肯定是O(n^2)的暴力解法，事实上好像也能过，当然那样没什么意思。

取巧一点的方法，我想到了可以通过扫描一遍数组，在预处理阶段找到某个位置`i`，从最左边开始到它以及从最右边开始到它的最小、最大值。
接着进一步O(n^2)扫描所有区间，对于区间开头和末尾，若两者对应的最大值和最小值不同，那么就可以认为这些值在区间内，
因此就可以直接求出这个区间所谓的"范围"。

虽然省去了一点找最值的力气，但是本质上还是O(n^2)。

无奈，看答案。然后直呼妙啊。
首先应该意识到的一点是，因为题目要求的是所有"范围"的和，做一个简单的转换后，
其实题目要求的，是所有区间的最大值的和减去所有区间的最小值的和。

然后需要转换视角，不能从区间视角去找，这样必然会O(n^2)。既然题目提示有O(n)解法，那么就得从数字视角分析。

对于任意一个数字而言，它有可能有机会成为某个区间的最大值或最小值。
那么这个可能会发生在什么时候呢？
比如以下面这个区间为例：
```text
... 4 1 2 3 2 1 4 ...  (假设省略号里面都是一些很大的数)
```
对最中央的3来说，要想知道其作为某个区间最大值的可能，显然左端点可能是1，2，3、右端点可能是3，2，1。
两者做一个笛卡尔积，就可以得到共有9种区间的选项，这个9，是`3*3`得来的。

更一般来说，假设左右两个4的下标分别是a和b（显然`b==a+6`），而3的下标为`x`的话，
上述要求的区间的左端点的种类数是`x - a`即3，右边同理，`b - x`也是3。
两边一乘，`(x-a) * (b-x)`，就是区间种类数。

别忘了这些个区间，其最大值都是3，所以上述全部区间，为 所有区间的最大值的和 贡献了`(x-a) * (b-x) * 3`。

好了，讲到这里，这个题已经变成如下，针对所有所有位置，求 其左/右边离其最近且比其更大/小的位置在哪里。
这其实是四个问题，而每个问题，实际上就是一个经典的用单调栈的问题。

在所有上述信息都求出来之后，只需要最后遍历一遍`range(n)`。
针对每个位置计算 最大值和贡献 - 最小值和贡献，然后把所有位置累加，就得到最终答案啦。

最后还有一个魔鬼细节。
在求左/右边更大的数的位置（当然更小的数也类似）时，对于相等的数如何处理？
为了避免重复计算区间，具体来说是要保证两边的单调栈有且只有一边在维护栈时将相等情况计入pop的条件。
这一点在代码中也注释了出来。