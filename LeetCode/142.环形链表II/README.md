## 题目描述
>原题中有较多图，如果需要看图建议参考原题页面

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。

说明：不允许修改给定的链表。

进阶：
- 你是否可以使用 O(1) 空间解决此题？
 

示例 1：
>输入：head = [3,2,0,-4], pos = 1
>
>输出：返回索引为 1 的链表节点
>
>解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：
>输入：head = [1,2], pos = 0
>
>输出：返回索引为 0 的链表节点
>
>解释：链表中有一个环，其尾部连接到第一个节点。

示例 3：
>输入：head = [1], pos = -1
>
>输出：返回 null
>
>解释：链表中没有环。
 

提示：
- 链表中节点的数目范围在范围 [0, 104] 内
- -105 <= Node.val <= 105
- pos 的值为 -1 或者链表中的一个有效索引

### 解法1 哈希表
非空间O(1)解法。

和上一题141类似，记录一下各个链表节点的被访问情况。当碰到一个已经被访问过的节点，那就是这个环的起始点了。

因为这题明确要求了不能修改链表内容，所以采取的方案是建立一个哈希set，把已经访问过的节点放到里面即可。

### 解法2 快慢指针
和上一题141类似的，也可以用快慢指针。

上一题中，只关心环是否存在，所以只要快慢指针相遇了就可以返回有环的结论，简单粗暴。这题就需要稍微精细一点了。

要知道，快慢指针相遇在哪个位置，我们还没做过仔细的考察。

实际上这个位置具有一些特别的性质说明如下：

![](https://assets.leetcode-cn.com/solution-static/142/142_fig1.png)

以上图为例，将入环前的节点连接数抽象为`a`，到相遇点位置慢指针走过的节点连接数为`b`，未走过的剩余环内节点连接数为`c`。

因为快指针，即便是在慢指针刚入环时的next时也可以保证在接下来的走一个环的过程中能够追上慢指针一次，即慢指针第一次被追上，必然还没走完超过一圈
的环。

因此可以得到以下结论：
```text
2*(a + b) == a + n*(b+c) + b
```
式子左边是慢指针走过的步数，右边是快指针走过的步数，两者刚好是两倍的关系。
其中`n`是一个大于零的正整数（快指针追上慢指针前已经走过的圈数）

以上式子变形为`a = (n-1)*(b+c) + c`。

由于`n >= 1`，这个式子其实是在说明，链表的环外"尾巴"长度，恰好等于环长度的整数倍加上`c`这段长度。

按照上图的情况估计，`a`应该等于`c`的感觉，即`n=1`的情况。当`a`很长很长时当然`n`就会大。

这个性质可以用来找到入环节点。

当快慢指针相遇时，此时从head再出发一个指针`p`。它和慢指针继续同速率，即每次走一步向前走。

当慢指针走完若干圈加`c`，`p`也恰好走完`a`，此时两者相遇的地方就一定是，入环节点。