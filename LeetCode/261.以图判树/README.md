## 题目描述
给定编号从 0 到 n - 1 的 n 个结点。给定一个整数 n 和一个 edges 列表，其中 edges[i] = [ai, bi] 表示图中节点 ai 和 bi 之间存在一条无向边。

如果这些边能够形成一个合法有效的树结构，则返回 true ，否则返回 false 。

示例 1：

![](https://assets.leetcode.com/uploads/2021/03/12/tree1-graph.jpg)
```
输入: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]
输出: true
```
示例 2:

![](https://assets.leetcode.com/uploads/2021/03/12/tree2-graph.jpg)
```
输入: n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]
输出: false
```

提示：
```
1 <= n <= 2000
0 <= edges.length <= 5000
edges[i].length == 2
0 <= ai, bi < n
ai != bi
不存在自循环或重复的边
```

### 解法 并查集
题意到并不复杂，主要在于看清如何通过一个图判断其是不是一个树。

简单脑补一下，可以得到一个结论，
一个图，当且仅当其中所有节点都处于同一个连通分量内，同时图中没有环，这就是一棵树。
（这也是树的正式定义

既然这样，那么就很简单了。
是否处于同一个连通分量，显然用并查集就行了。
至于判断有没有环，我一开始还以为要做一个拓扑排序，但是看了眼答案后才发现，原来并查集自带这个功能。

简单来说，因为题目给出了图中的所有边，所以，在遍历所有边构建图的过程中，可以判断新来的边`a,b`的两个端点，
a和b是否已经处于同一个连通分量中，若是，则加上这个边必然导致环的形成，此时直接返回False即可。

注意，a和b同时处于并查集中并不是判断条件，比如`[[0,1], [2,3], [1,2]]`这样的一组输入，
处理完第一条和第二条边时，1和2这两个节点都已经存在于并查集中但是未处于同一个连通分量。

基于并查集，遍历所有边，构建起图。
构建完成时，只需要判断`range(n)`中是否所有节点都已经被维护过，且并查集中的连通分量只有1个。
同时满足两者，就返回True。