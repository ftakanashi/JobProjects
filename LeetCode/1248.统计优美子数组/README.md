## 题目描述
给你一个整数数组 nums 和一个整数 k。

如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。

请返回这个数组中「优美子数组」的数目。

示例 1：
```
输入：nums = [1,1,2,1,1], k = 3
输出：2
解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。
```
示例 2：
```
输入：nums = [2,4,6], k = 1
输出：0
解释：数列中不包含任何奇数，所以不存在优美子数组。
```
示例 3：
```
输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2
输出：16
```

提示：
```
1 <= nums.length <= 50000
1 <= nums[i] <= 10^5
1 <= k <= nums.length
```

### 解法 前缀和 + 哈希表
看到连续子数组先想了一波滑窗。但是诸如示例3数据这种，显然前三个和后三个2之间可以自由搭配。
滑窗算法是单向移动的，不是很好处理。

于是连续子数组，接着想到前缀和。尝试了一波使用原数组做前缀和，试图从前缀和差值的奇偶性入手解，但是发现是死路。

而后突然发现，既然我只关心奇偶性，那么是否可以直接把所有奇数置为1，所有偶数置为0，此时这题就变成了求一个01数组中包含k个1的子数组种类数了。

这个问题，很显然就可以用前缀和+哈希表来做了（`LC.560`套路）。

具体的，比如示例3的数据改写成`0001001000`，而后做前缀和得到`00001112222`。
从左到右扫描，每扫描到`presum[i]`时，只要查找其左侧共有多少位置的值`presum[j]`满足`presum[i] - presum[j] == k`即可。

扫描过程中维护一个哈希表counter，从而可以一次扫描就解决战斗。