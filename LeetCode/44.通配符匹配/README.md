## 题目描述
给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。

- '?' 可以匹配任何单个字符。 
- '*' 可以匹配任意字符串（包括空字符串）。
- 两个字符串完全匹配才算匹配成功。

说明:
- s 可能为空，且只包含从 a-z 的小写字母。
- p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。

示例 1:
```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```
示例 2:
```
输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。
```
示例 3:
```
输入:
s = "cb"
p = "?a"
输出: false
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
```
示例 4:
```
输入:
s = "adceb"
p = "*a*b"
输出: true
解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
```
示例 5:
```
输入:
s = "acdcb"
p = "a*c?b"
输出: false
```

### 解法 DP
联动`LC.10`。字符串类型DP，显然就是一个二维DP数组。
为了一致性，在两个字符串前都加个空字符。

至于这题，其实初始化上还有些trick。比较容易看出来的是`dp[0][0] = True`，因为空串可以匹配空串。
同时，如果p是纵向方向的话，像示例4这样的情况，开头是`*`的话，其实也是True。
换句话说，其实可以再扫描一遍第一列，把开头的那些`*`的位置设置为True。
再考虑一下，除了`*`，其他的`?`和字符都不符合要求因此不设置。

接下来考虑内部的转移方程。对于`dp[i][j]`而言，
如果`p[i-1]`不是特殊符号，此时看`p[i-1]`和`s[j-1]`。如果两者相等，显然可以直接沿用`dp[i-1][j-1]`的值。

如果`p[i-1] == '?'`，这个情况也不复杂，相当于一个万能匹配字符，所以只要看两者都不存在的`dp[i-1][j-1]`的值即可。

最后，若`p[i-1] == '*'`稍微复杂一些。
首先如果`dp[i-1][j]`是True，相当于不加这个星号时也匹配，那么显然加上了也无妨，可以直接判True。
另一方面，如果`dp[i][j-1]`是True，因为星号匹配无限个字符，所以s这边新加一个字符不影响匹配结果，也可以直接判True。
所以有`dp[i][j] = dp[i-1][j] or dp[i][j-1]`。

综上，转移方程如下：
```python
if p[i-1] == '*':
    dp[i][j] = dp[i-1][j] or dp[i][j-1]
elif p[i-1] == '?':
    dp[i][j] = dp[i-1][j-1]
else:
    dp[i][j] = dp[i-1][j-1] and p[i-1] == s[j-1]
```
有了转移方程，结合上面提到的稍微tricky一点的初始化，写代码就没什么问题了。