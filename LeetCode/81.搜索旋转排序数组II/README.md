## 题目描述
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,0,1,2,2,5,6]` 可能变为 `[2,5,6,0,0,1,2]` )。

编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。

示例 1:
```
输入: nums = [2,5,6,0,0,1,2], target = 0
输出: true
```
示例 2:
```
输入: nums = [2,5,6,0,0,1,2], target = 3
输出: false
```
进阶:
- 这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。
- 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？

### 解法 二分查找
首先不用说，肯定是二分查找咯。

这题是`LC33.搜索旋转排序数组`的进阶题，
同时也和`JZ.11旋转数组中的最小数字`很像。

简单来说，对于本题和JZ11这种可能存在重复数字的情况，下面两个旋转排序数组的例子很重要：
```text
1 0 1 1 1
1 1 1 0 1
```
在`LC33`中，由于数字没有重复，所以通过判断`nums[mid]`和`nums[right]`的
大小情况以及`target`和他们两者间的相互关系，可以确定`target`在哪个区间内，从而方便操作
left和right两个指针来逼近target。

另一方面，如果可重复数字，上面两种情况是尴尬的。
`nums[mid]`和`nums[right]`相等，意味着我不知道左半边还是右半边是单调区间。

所以，学习`JZ11`的做法，实在不知道没法确定，那么只能将二分搜索退化成一般遍历，让`right -= 1`了。

### 心得
二分查找旋转后的数组的这类题，思路应该是这样的。

首先要明确它本身还是一个二分查找问题，因此可以套用二分查找的套路。即可以写出类似下面的代码：
```python
while l <= r:
    mid = (l + r) // 2
    if nums[mid] == target: return True
```
问题在于后面。

在一般的二分查找中，由于数组是有序的，因此比较mid和target的大小关系就可以缩小一半的搜索范围。
但是由于数组旋转了，数组会分成"前长后短"和"前短后长"两种可能性。
首先应该意识到这两种情况可以用`nums[mid]`和`nums[r]`之间的关系来区别。

仅比较mid和target无法确定范围。
这里，确定范围重要的是要**找到单调区间**。
比如前长后短的情况（即`nums[mid] > nums[r]`），如果target介于`nums[r]`和`nums[mid]`之间，那么探索区间是在左半边的单调区间。
否则，不论是target比r更小还是比mid更大，探索区间都在右半边。
这样的分类讨论思路，只要写一个条件：`nums[r] < target < nums[mid]`即可，从代码角度来说最为便捷。

前短后长的情况类似。

最后，注意本题中可能存在相同元素，这也就是说还要考虑`nums[mid] == nums[r]`的情况。
此时前短后长和前长后短无法直接判断（记住例子10111和11101）。因此退化，直接`r -= 1`即可。