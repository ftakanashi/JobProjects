## 题目描述
大餐 是指 恰好包含两道不同餐品 的一餐，其美味程度之和等于 2 的幂。

你可以搭配 任意 两道餐品做一顿大餐。

给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i​​​​​​​​​​​​​​ 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。结果需要对 109 + 7 取余。

注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。

示例 1：
```
输入：deliciousness = [1,3,5,7,9]
输出：4
解释：大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。
它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。
```
示例 2：
```
输入：deliciousness = [1,1,1,3,3,3,7]
输出：15
解释：大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。
```

提示：
```
1 <= deliciousness.length <= 10^5
0 <= deliciousness[i] <= 2^20
```

### 解法 哈希表
题目的意思，就是给出一个数组，让你求其中有多少对组合，其和是2的幂。注意相同数字算不同的个体。

因为相同数字也算不同个体，很容易就想到维护一个counter，然后将counter中的key拿出来考察。两两key组合，检查其和是否为2幂。
如果是则收割结果。这里还要分成两种情况，就是key和key本身组合时，结果应该加上`cnt = counter[key]; (cnt - 1) * cnt // 2`，如果key和别的key
组合，那么自然是`counter[key1] * counter[key2]`。

乍一看，一个二重循环就能搞定了。
为了继续优化，我还用`n & (n-1) == 0`的方式判两key之和是不是2的幂。

当然，试了一波后发现超时，显然，二重循环的复杂度太大了。
注意到题目规定输入数组最大是2^20。反过来想，对于任意一种数组中的数字`n`，与其相加后得到2幂的候选数字只可能是：
`[2**p - n for p in range(22)]`。注意最大是21，因为考虑到数组中有两个`2^20`的情况。

于是，搜索仍然是二重循环，只不过内层可以从`for j in range(i, n)`优化到`for p in range(22)`：
```python
cands = counter.keys()
n = len(cands)
for i in range(n):
    for p in range(22):
        rest = 2**p - cands[i]
        if rest in counter:
            if rest == cands[i]: ans += (counter[rest] * (counter[rest] - 1) // 2)
            else: ans += (counter[rest] * counter[cands[i]])
```
但上述代码对于一对keys会重复计算两次，因此还需要优化。
一个最简单的方法是，我们强行限制`cands[i] >= rest`。这样，比如`(3,5)`这对，只会在`cands[i] = 5, rest = 3`的时候扫描一次。

进一步，绝大多数`cands[i]`都是大于1的，因此可以预见，绝大多数rest都小于0，而小于0的rest不可能出现在counter中。因此可以直接跳过。
与其额外写一条continue，不如直接把p的遍历反过来，于是相应的把限制也反过来：`cands[i] <= rest`。
事实证明，这样的优化方式最快。

给出代码中，使用第二种优化，第一种优化写在注释里了 。