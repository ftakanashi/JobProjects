## 题目描述

判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

上图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 '.' 表示。

示例:
>输入:
>
>```text
>[
>  ["8","3",".",".","7",".",".",".","."],
>  ["6",".",".","1","9","5",".",".","."],
>  [".","9","8",".",".",".",".","6","."],
>  ["8",".",".",".","6",".",".",".","3"],
>  ["4",".",".","8",".","3",".",".","1"],
>  ["7",".",".",".","2",".",".",".","6"],
>  [".","6",".",".",".",".","2","8","."],
>  [".",".",".","4","1","9",".",".","5"],
>  [".",".",".",".","8",".",".","7","9"]
>]
>```
>
>输出: false
>
>解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。

说明:
- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 给定数独序列只包含数字 1-9 和字符 '.' 。
- 给定数独永远是 9x9 形式的。

### 解法
最简单的办法，当然就是扫描每个元素，然后检查他所在行，所在列，所在小宫中是否有重复数字。

不过由于board本身的构造原因，检查列和小宫时都要构建额外的列表。同时，`n in lst`这个操作，某种意义上还是很费时间的。

为了节省`in`操作的时间，很显然，可以用哈希表。

即先扫描一遍，把每行，每列，每小宫的数字存在情况维护到各自的哈希表中。然后第二遍扫描检查。

由于只要检测冲突，所以其实可以一遍扫描完成。即实时维护数字存在情况进各个哈希表，同时检查当前数字是否和
之前已经扫描过的数字有冲突，有冲突返回false即可。

> 关于小宫的index
>
>小宫的哈希表也是9个。但是小宫本身是二维结构，而我们通常使用一维数组来保存那些哈希表。这就导致一个
>元素下标转化小宫下标，小宫下标转化小宫哈希表数组下标的过程。
>
>简单来说，board中某个元素[i, j]，他所在的小宫下标显然是[i // 3, j // 3]。
>
>完了这个小宫的哈希表在数组中的下标又有[x, y] -> x * 3 + y的关系。
>
>所以总体来说，某个元素其小宫哈希表在数组中的下标是(i // 3) * 3 + (j // 3)

不过这样的话显然还是需要3 * 9 = 27个哈希表。同时每个哈希表最多可能会需要保存九个数字的存在情况。

这里祭出一个不用哈希表，用位运算来进行数字存在情况维护和检查的高级办法。

整体框架没变，只是，哈希表中只是维护某个数字存不存在这个二元状态的话，就可以考虑使用位运算。

比如每一行有九个位置，我可以初始化一个二进制数`000000000`，然后如果发现这行里有一个9，那么就把他改成
`100000000`，接着又发现5也在这行里，那么就可以改成`100010000`。

显然，位运算可以实现
1. 某数字是否在行中
2. 改变二进制表明某个数字进入了行中

上述两个操作分别是
```python
row >> (n-1) & 1 == 1    # True表示n在row中
row = row | 1 << (n-1)
```

列和小宫的检查和维护也是一个意思。

最终写出代码。