## 题目描述
对于给定的整数 n, 如果n的k（k>=2）进制数的所有数位全为1，则称 k（k>=2）是 n 的一个好进制。

以字符串的形式给出 n, 以字符串的形式返回 n 的最小好进制。

示例 1：
```
输入："13"
输出："3"
解释：13 的 3 进制是 111。
```
示例 2：
```
输入："4681"
输出："8"
解释：4681 的 8 进制是 11111。
```
示例 3：
```
输入："1000000000000000000"
输出："999999999999999999"
解释：1000000000000000000 的 999999999999999999 进制是 11。
```

提示：
```
n的取值范围是 [3, 10^18]。
输入总是有效且没有前导 0。
```

### 解法 二分查找
做这题，首先应该意识到，k进制下各位全是1的N位数，其转换为十进制，那就是：
```text
f(k, N) = k^0 + k^1 + k^2 ... + k^(N-1)
```

容易证明，答案的k应该大于等于2，且小于等于`n - 1`。
因此一个最朴素的办法，就是从小到大挨个遍历可能的k，将n转换为k进制的形式查看是否全部是1。
显然这种做法外层循环就需要O(n)的时间，内部检查是否是1还需要O(N)的时间。

现在我们来换个角度。看上面那个式子，当n可以被表示成各位都是1的情况，决定其具体形式的是两个变量，k和N。
从绝对值上来说，一般`k >> N`。
所以不妨从N入手而不是k。

那么N的取值范围是多少呢。容易证明，将n表示为二进制时，其位数N是其所有进制中最大的；相反，最小的是`n-1`进制的2位。

因此，N的取值范围是`2 ~ len(bin(n)) - 2`(注意bin的输出带有0b前缀，所以减2)。
要得到最小的好进制，因此N应该考虑从大到小遍历。

当N确定之后，要是还是线性遍历k就没有意义了。
注意到N为定值时，上述`f(k, N)`就变成了一个单调递增的数据，因此可以引入二分查找。
换言之，确定左右边界分别是`2`和`n-1`，然后计算mid，计算`f(mid, N)`。如果这个值小于`n`，则说明`l = mid + 1`；
否则`r = mid - 1`。
当恰好`f(mid, N) == n`时，说明此时的mid正是我们要求的好进制之一。又因为N是从大到小扫描的，因此第一次遇到好进制之后就可以直接返回了。

另一方面，绝大多数N的情况下，都找不到`f(mid, N)`恰好等于`n`，此时说明位数N时无法凑出全是1的表达了。

由于对于任意`n`，必然会有`n - 1`进制下的`11`作为符合条件的答案，即本题必然有答案。
所以就不用担心默认返回的问题，外层从大到小遍历N，内存二分查找合适的进制k，大胆做就行了。

最后还有一个优化点，上述`f(k, N)`的计算，虽然可以一个个迭代加起来，但这本身是一个等比数列，可以应用等比数列求和公式，将复杂度降低为O(1)。
