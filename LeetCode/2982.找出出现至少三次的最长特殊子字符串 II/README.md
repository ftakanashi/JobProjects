## 题目描述
给你一个仅由小写英文字母组成的字符串 s 。

如果一个字符串仅由单一字符组成，那么它被称为 特殊 字符串。例如，字符串 "abc" 不是特殊字符串，而字符串 "ddd"、"zz" 和 "f" 是特殊字符串。

返回在 s 中出现 至少三次 的 最长特殊子字符串 的长度，如果不存在出现至少三次的特殊子字符串，则返回 -1 。

子字符串 是字符串中的一个连续 非空 字符序列。

示例 1：
```
输入：s = "aaaa"
输出：2
解释：出现三次的最长特殊子字符串是 "aa" ：子字符串 "aaaa"、"aaaa" 和 "aaaa"。
可以证明最大长度是 2 。
```
示例 2：
```
输入：s = "abcdef"
输出：-1
解释：不存在出现至少三次的特殊子字符串。因此返回 -1 。
```
示例 3：
```
输入：s = "abcaba"
输出：1
解释：出现三次的最长特殊子字符串是 "a" ：子字符串 "abcaba"、"abcaba" 和 "abcaba"。
可以证明最大长度是 1 。
```

提示：
```
3 <= s.length <= 5 * 105
s 仅由小写英文字母组成。
```

### 解法 滑动窗口
这题和2981题目一模一样，只不过这题的范围更大，所以2981的暴力显然就不能用了。

另外如果照抄2981给出的解法代码，会OOM，也过不了。所以需要进一步优化。
OOM的case是一个长度为 100000 的全是 `a` 的字符串。

沿着2981的思路，发现当统计到了某个字母的某个最长的特殊字符串片段后，如果这个片段特别特别长，将其从1开始到`n`的所有长度的计数
都维护到哈希表中是不合适的。

而实际上，在这两道题目中，我们只是关心其可以贡献到的最大长度就行。设这个最大长度为`l`的话，那么其实其贡献了1个`l`，两个`l-1`。
另一方面，如果`l > 2`，那么无需其他任何条件， `l - 2` 就是一个可能的答案。

因此，我们改变思路，在滑窗遍历过程中，首先维护一个 字母 -> span长度 的映射。
比如 `aabaaacaad` 这个输入，就可以将 `a -> [2, 3, 2]`。

然后针对每个字母的所有span长度，进行计数，比如上面这个就变成了`{2: 2, 3: 1}`。

最后针对这个计数，我们从大到小遍历 key，并判断value。
如果value大于等于3，没啥可说的，key就是一个可能的答案。
如果value等于2，或者value等于但是value-1大于等于1，那么key-1可能是一个答案。（这条需要稍微想一下）
另外就是上面说的如果key大于2，那么key-2就是一个可能的答案。

由于是从大到小遍历的，当上述任何一种情况符合要求，可以直接break。

最后注意，上述逻辑可能会把答案归置为零，但如果没有答案是返回-1而不是0。