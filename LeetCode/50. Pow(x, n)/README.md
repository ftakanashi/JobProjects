## 题目描述
实现 pow(x, n) ，即计算 x 的 n 次幂函数。

示例 1:
>输入: 2.00000, 10
>
>输出: 1024.00000

示例 2:
>输入: 2.10000, 3
>
>输出: 9.26100

示例 3:
>输入: 2.00000, -2
>
>输出: 0.25000
>
>解释: 2-2 = 1/22 = 1/4 = 0.25

说明:
- -100.0 < x < 100.0
- n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。

### 解法 递归，快速幂技巧
>同JZ16，但是main里代码实现有点不一样。

没啥可说的。。注意负幂的处理。

快速幂是指，当要求x^n的时候，如果单纯连乘n个x,那么是O(n)的。

但是实际上，`x^n = (x^n/2)^2`，而`x^n/2`又可以再分成两个`x^n/4`的乘积。
这样二分地分下来，可以节省一半的计算。就好比线性查找要O(n)而二分查找只要O(logn)一样。
快速幂只要O(logn)就可以计算出来幂的结果了。

### 2021/12/05 追加笔记 更方便记忆的递推式
上述递归式的快速幂虽然可以奏效，但是比较难以记忆。
实际上快速幂可以按照下面的方式来记忆。

快速幂，本质上是将线性乘以`n`个底数的过程转化为连乘多个底数的二次幂次方如平方、四次方、八次方等。
既然和二次幂扯上关系，自然就可以将其联系到二进制位运算。
实际上，快速幂的真正含义，是
当你要求`a ^ b`时，将`b`用二进制的方式写出，然后逐位进行扫描并结合底数将相应的因子累乘到结果中。

举个例子，比如求`3`的`14`次方。`14`的二进制表达是`1110`，其数学意义也就是
```text
3^(1110) = 3^(1000) * 3^(100) ^ 3^(10)    # 注意上面次幂中都是二进制表达哦。
```
即
```text
3^(14) = 3^(2^3) * 3^(2^2) * 3^(2^1)
```
而为什么没有`3^(2^0)`呢？因为`1110`的最低位是0。

综上，可以有这样一个算法：
```python
def quick_pow(a, b):
    ans = 1
    base = a
    while b > 0:    # 从低到高逐个扫描b的二进制位

        if b & 1 == 1:
            ans = ans * base    # 当扫描到当前二进制位是1时，将对应的因子累乘到结果中
        base = base * base    # 随着扫描位从低到高，对应的累乘因子也水涨船高

        b = b >> 1
    return ans
```
一个值得注意的点是，
每次扫描到某个二进制位时，其实只要知道当前是第几位，也可以通过`a ** (2**k)`这样的方式来求出累乘因子。
但显然，这么做就违背了快速幂`O(logn)`的初衷，毕竟你这两次乘方都是线性的。
因此快速幂算法中，充分利用了当前累乘因子，直接进行一个翻倍，从而实现了快速且准确的累乘因子的计算。

当然，上述算法只适用于`b >= 0`的情况。对于小于0的情况，就按照题意进行分类讨论就行了。
采用上述递推式快速幂的代码也写在main中了。