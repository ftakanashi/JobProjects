## 题目描述
给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。

示例 1:
```
输入: ["abcw","baz","foo","bar","xtfn","abcdef"]
输出: 16 
解释: 这两个单词为 "abcw", "xtfn"。
```
示例 2:
```
输入: ["a","ab","abc","d","cd","bcd","abcd"]
输出: 4 
解释: 这两个单词为 "ab", "cd"。
```
示例 3:
```
输入: ["a","aa","aaa","aaaa"]
输出: 0 
解释: 不存在这样的两个单词。
```

提示：
```
2 <= words.length <= 1000
1 <= words[i].length <= 1000
words[i] 仅包含小写字母
```

### 解法 暴力 位运算优化 排序优化
这题第一眼就能想到的是暴力。O(n^2)的时间下，结合哈希表，肯定能求出答案。
但是O(n^2)感觉略有些离谱。

想了一会儿有没有更好的办法，但是没想到。
然后看答案，居然发现还真是用暴力…
毕竟`words[i].length`最大也就1000，所以暴力还可以接受。

虽然时间很难优化，但是空间到有优化的空间。
看到单词只有小写字母，很容易就想到用位图法将哈希表替换成O(1)的一个数字就行了。

具体而言，在预处理阶段，求算出所有单词的位图，放到统一的一个flags列表中。
然后在暴力搜两两配对。判断`words[i]`和`words[j]`有没有撞车的字母，就只要看`flags[i] & flags[j]`是否大于0即可。

另外还有一个不是那么靠谱的优化点。
就是预处理阶段可以对words进行单词长度倒序排序。然后双层遍历。
遍历过程中记录当前一对单词的结果`cur = len(words[i]) * len(words[j])`。
如果`cur`小于当前记录到的答案`ans`，那么第二层对`j`的遍历可以直接跳出，因为后面不可能会有比当前`words[j]`更长的单词，自然也就不会有更大的结果。

最后结果来看，加上排序优化后大概可以继续加速10ms的样子…