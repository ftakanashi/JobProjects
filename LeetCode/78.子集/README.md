## 题目描述
给你一个整数数组 nums ，返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。

>补充说明：
>我觉得这题题干少说了一句，nums没有重复数字。
>否则官方后台对于类似于1,1,2之类的case，也会返回出多个1的情况。
>不符合子集的定义。
>
>对于可能重复的情况，参见LC90.子集II

 
示例 1：
>输入：nums = [1,2,3]
>
>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

示例 2：
>输入：nums = [0]
>
>输出：[[],[0]]
 

提示：
- 1 <= nums.length <= 10
- -10 <= nums[i] <= 10

### 解法 DFS
我以为DFS已经玩得相对比较熟悉了，不知道为什么还是在这道题上嗝屁了这么长时间…

最先想到的思路，是先得到各个长度子集的结果，然后把所有结果合并起来。

但是仔细一想，其实在得到k长度子集的结果时，DFS的过程中k-1以及以下所有长度的结果都会得到一遍，如果真这么做显然会有大量重复计算。

换句话说，长度为n的`nums`数组的子集用DFS来探索，当探索到`nums`本身的时候，这个过程中所有子集都可以被收割。

按照这个思路写代码就可以了。

实现过程中注意如何避免重复。
最朴素的DFS中会出现`1,2,3`和`1,3,2`之类的重复。和之前做过的某题类似，只要在DFS函数参数中设置一个`start`参数，
用来表示本次递归调用中只能使用下标为start及以后的元素。这样就可以避免已有`1,3`的情况下再取`2`了。

心态有点崩……这么简单一道题为啥花了这么久才整出来……