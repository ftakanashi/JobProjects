## 题目描述

有一个二维矩阵 A 其中每个元素的值为 0 或 1 。

移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。

在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。

返回尽可能高的分数。

示例：
>输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]
>
>输出：39
>
>解释：
>
>转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]
>
>0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
 

提示：
- `1 <= A.length <= 20`
- `1 <= A[0].length <= 20`
- `A[i][j]` 是 0 或 1

### 解法 贪心
很明显，要用贪心的思想来做。但是具体的策略是什么样的还需要仔细思考。

首先，应该要保证每行首位肯定是1。因为即使1后面全是0，也比0后面全是1大。那么如何保证每行的首位都是1呢，
最直接的办法自然就是把开头是0的行都翻转一下了。

此时例子变成了
```text
1 1 0 0
1 0 1 0
1 1 0 0
```

在保证每行开头都是1之后，自然就会想到，接下来是不是可以保证第二列也都是1。

目前第二列有一个0两个1。如果考虑将第二行翻转，那势必会把第一列的1破坏掉。
列翻转也不可取，会破坏第二列的两个1，显然是不合算的。

那么怎么样才算合算？此时有了思路，当某一列的0的个数多于1的个数，那么就翻转此列，否则保留此列当前情况。

其实上面这个矩阵完全没必要看成是三个二进制数，而可以看成所有第一列的都是2^3，第二列的都是2^2，以此类推。

从高位到低位扫描，保证每一列的1个数尽量多，就是这个贪心法的奥义了。

想到这个思路之后，代码实现一点也不难了。

