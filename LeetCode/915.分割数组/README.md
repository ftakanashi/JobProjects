## 题目描述

给定一个数组 nums ，将其划分为两个连续子数组 left 和 right， 使得：

```
left 中的每个元素都小于或等于 right 中的每个元素。
left 和 right 都是非空的。
left 的长度要尽可能小。
在完成这样的分组后返回 left 的 长度 。
```

用例可以保证存在这样的划分方法。

示例 1：
```
输入：nums = [5,0,3,8,6]
输出：3
解释：left = [5,0,3]，right = [8,6]
```
示例 2：
```
输入：nums = [1,1,1,0,6,12]
输出：4
解释：left = [1,1,1,0]，right = [6,12]
```

提示：
```
2 <= nums.length <= 105
0 <= nums[i] <= 106
可以保证至少有一种方法能够按题目所描述的那样对 nums 进行划分。
```

### 解法 两次遍历 模拟求最值
一开始看到这道题，想到了可能要用单调栈去求某个位置左/右侧第一个更大/小值这样的套路。

但是仔细思考（指看了答案）后发现，其实不用这么复杂。
暂时先不管让`left`的长度尽量小这个要求，只想着如何把数组切成两半的话，其实一点也不复杂。

假设`right`的开头数字的下标是`i`，即切割发生在`i-1`和`i`两个元素之间的话，
那么显然有`left`中最大的数字小于等于`right`中最小的数字。

接下来就是遍历试错了。
我们尝试将从`n-1`开始到`1`为止（因为保证`left`和`right`都不为空，所以只能到`1`为止），
所有位置作为`i`时的情况。这个遍历过程中，显然我们找出每个位置对应的`right`的最大值。
我们将这些最大值放到一个数组`min_right`中，形成一个长度和原数组相同的数组。
（这里为了处理方便，直接给下标0处也添加一个值，但是后面不用）

那么到底哪个位置才是正确答案呢？
我们第二次从左到右遍历，并且遍历过程中维护一个`max_left`值，表示以当前位置作为`right`的第一个数字时，`left`中最大的值。

显然，只要`left_max <= min_right[i]`，这就是符合要求的，直接返回`i`就是我们的答案了。
由于还要求`left`长度尽量小，因此碰到的第一个`i`就可以返回。

