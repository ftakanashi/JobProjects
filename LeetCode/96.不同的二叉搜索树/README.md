## 题目描述
给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:
```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

### 解法1 记忆化DFS
针对输入n，可以考虑从1到n所有数字作为根的情况。
比如以数字i作为根，此时1...i-1在i的左子树，i+1...n在i的右子树。
将这两个子树的种类数相乘便可得到以i为根总共有多少种情况。

而求这两个子树的种类数又分别是一个更小的问题。

这个递归终止在区间的起始和终点相同，即长度为1时，此时只有一种情况，返回1即可。

按照以上思路DFS即可。应对大量重复计算，引入cache进行记忆化。

### 解法2 DP
注意到其实一个区间能够构成几种二叉搜索树，决定因素与其说是其起始和终止位置，不如说是两者之差。
比如1，2，3构成的种类数和7，8，9的种类数应该是一样的。

这样，我们就设计一个DP数组，`dp[i]`表示当起始和终止差是`i`的时候的种类数。
然后从小到大求各个`dp[i]`。

为了求`dp[i]`，需要遍历以`1...i`之间所有数作为根时的情况。而根据上面解法的思路，
以`1 <= k <= i`作为根时，`dp[k-1] * dp[i-k]`。因为`k-1`和`i-k`两者都是小于`i`且我们是从小到大求dp值的，所以这两个值都是知道的。

因此dp核心部分的代码应该像下面这样：
```python
for i in range(n+1):
    for k in range(1, i+1):
        dp[i] += dp[k-1]*dp[i-k]
```

注意初始值，当区间起点终点差值为0或者1时，都只有一种可能，因此赋初值为1。