## 题目描述
给你一个 R 行 C 列的整数矩阵 A。矩阵上的路径从 [0,0] 开始，在 [R-1,C-1] 结束。

路径沿四个基本方向（上、下、左、右）展开，从一个已访问单元格移动到任一相邻的未访问单元格。

路径的得分是该路径上的 最小 值。例如，路径 8 →  4 →  5 →  9 的值为 4 。

找出所有路径中得分 最高 的那条路径，返回其 得分。

示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/06/27/1313_ex1.jpeg)
```
输入：[[5,4,5],[1,2,6],[7,4,6]]
输出：4
解释： 
得分最高的路径用黄色突出显示。 
```
示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/06/27/1313_ex2.jpeg)
```
输入：[[2,2,1,2,2,2],[1,2,2,2,1,2]]
输出：2
```
示例 3：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/06/27/1313_ex3.jpeg)
```
输入：[[3,4,6,3,4],[0,2,1,1,7],[8,8,3,2,7],[3,2,4,9,8],[4,1,2,0,0],[4,6,5,4,3]]
输出：3
```

提示：
```
1 <= R, C <= 100
0 <= A[i][j] <= 10^9
```

### 解法 并查集 + 贪心
一开始尝试了回溯DFS暴力搜，但是果然超时，只过了大概60%的case。
接着尝试BFS等手段，也还是失败。

看答案…
答案标签里有并查集三个字，于是想到了这种图中的某条路径问题，也可以构建一个并查集并以节点为视角构建图。
换句话说，这题其实是一道变向的最小生成树问题。

既然是最小生成树，就可以用Kruskal算法做。
具体的，构建一个并查集并将起点和终点初始化进去。
接着，将图中所有格子的值都综合统计，排序（这里用堆也可以，复杂度是一个意思）。

接着，按照格子值从大到小的顺序依次遍历各个格子。并查看若将其加入路径能否将起点和终点连通。
若不能，则继续往下搜索。
具体的，扫描到每个格子后，检查其上下左右四个相邻格子是否已经遍历过，如果是则union他们。

由于格子值是从大到小遍历的，所以当碰到第一个将起点和终点连通的格子时，其值就是我们要求的路径的最高分数了。
这其中也表现了这种解法的贪心思想。即我从最大的值依次往下遍历。不怕多遍历一些错的格子，但是保证最终答案尽可能地大。

实现起来可以说并不算太难，但是难的是在这么一个疯狂暗示用搜索做的背景下，敢不敢抛开固有思维用并查集做…