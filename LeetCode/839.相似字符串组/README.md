## 题目描述

如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。

如果这两个字符串本身是相等的，那它们也是相似的。

例如，"tars" 和 "rats" 是相似的 (交换 0 与 2 的位置)； "rats" 和 "arts" 也是相似的，但是 "star" 不与 "tars"，"rats"，或 "arts" 相似。

总之，它们通过相似性形成了两个关联组：{"tars", "rats", "arts"} 和 {"star"}。

注意，"tars" 和 "arts" 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。

给你一个字符串列表 strs。列表中的每个字符串都是 strs 中其它所有字符串的一个字母异位词。请问 strs 中有多少个相似字符串组？

 

示例 1：
```
输入：strs = ["tars","rats","arts","star"]
输出：2
示例 2：

输入：strs = ["omv","ovm"]
输出：1
```

提示：
- 1 <= strs.length <= 100
- 1 <= strs[i].length <= 1000
- sum(strs[i].length) <= 2 * 104
- strs[i] 只包含小写字母。
- strs 中的所有单词都具有相同的长度，且是彼此的字母异位词。
 

备注：
- 字母异位词（anagram），一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。

### 解法 并查集
很明显可以用并查集的题目。
只不过需要稍微想一下，如何判断两个字符串相似。

也不难，因为两个字符串相似的条件是两者至多只通过一次交换就可以完全一致。
所以用一个游标扫描两个字符串各个位置，字母不同的位置个数不能超过2（应该说是只能是0或者2）

由于要建完整图，所以只能笨笨地两轮扫描。

计算量分析：
首先两轮扫描肯定就n^2了，n是strs的长度。
其次，每次扫描进去都要check两个字符串是不是相似，
如果字符串长度是k的话那就是O(kn^2)。
再次，如果两个字符串相似，就要在并查集中合并。
每次合并耗时O(logn)，最多可能进行n次，因此并查集方面的操作是O(nlogn)。

总体耗时O(kn^2+nlogn)。