## 题目描述
可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
'A'：Absent，缺勤
'L'：Late，迟到
'P'：Present，到场
如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：

按 总出勤 计，学生缺勤（'A'）严格 少于两天。
学生 不会 存在 连续 3 天或 3 天以上的迟到（'L'）记录。
给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 109 + 7 取余 的结果。

示例 1：
```
输入：n = 2
输出：8
解释：
有 8 种长度为 2 的记录将被视为可奖励：
"PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL" 
只有"AA"不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。
```
示例 2：
```
输入：n = 1
输出：3
```
示例 3：
```
输入：n = 10101
输出：183236316
```

提示：
```
1 <= n <= 105
```

### 解法 DP
第一个想到的办法是dfs。设计了dfs函数为`dfs(pos, a, l)`。
即表示扫描到pos位置时，累计A的个数是`a`，而累计末尾L的个数是`l`。

显然在DFS过程中，首先可以给当前位置设置P，那就是`dfs(pos+1, a, 0)`（注意，l归零，因为连续L被砍断）
若`a < 1`，还可以`dfs(pos+1, a+1, 0)`。
若`l < 2`，还可以`dfs(pos+1, a, l+1)`。
当`pos == n`时返回1，然后每层dfs累计加和计数即可。

这个过程中，由于dfs结果完全依赖于输入，所以还可以进行记忆化，加`@cache`即可。

但是上述代码一写，发现超时（虽然每个case单独跑都能跑过去…）于是没办法，只好改写DP。

对于DP，DP数组定义为什么很重要。
显然，第一个维度是`n`，即"前n个位置"。
问题在于，决定第`n`个位置可以填写什么的，取决于前面的具体状态。于是扩展维度。

具体的，需要考虑的状态可以从两个角度看。
第一个角度，状态有0个A还是1个A。
第二个角度，状态末尾是0个L还是1个L还是2个L。

即，DP数组每个位置是一个`2*3`的矩阵。
接着推导转移方程。
对于位置`i`来说，以上6中情况：

情况1，0A0L，这种状态可能是前序状态0个A，而末尾是任意的情况，再加上P。即前序的0A0L,0A1L,0A2L的和
情况2，0A1L，这种只可能是前序的0A0L加上一个L得来。
情况3，0A2L，和上种类似，只可能由0A1L加上一个L得来。

情况4，1A0L，这种情况还要细分讨论A所处的位置。若A刚好是最后一个位置，则可能是前序的0A*L情况的总和；
若A在前面，则可能是1A\*L的总和。换言之，1A0L的值是前序所有可能的总和。

情况5，1A1L  以及  情况6，1A2L和情况2/3分别对应，即前序的1A0L和1A1L得来。

具体的用代码表达上述转移规则：
```python
mat = dp[i]
prev = dp[i-1]
mat[0][0] = (prev[0][0] + prev[0][1] + prev[0][2]) % MOD
mat[0][1] = prev[0][0] % MOD
mat[0][2] = prev[0][1] % MOD
mat[1][0] = sum([sum(row) for row in prev]) % MOD
mat[1][1] = prev[1][0] % MOD
mat[1][2] = prev[1][1] % MOD
```

最后还需要确定初始状态。稍微脑补下就能想出来，`dp[0]`长这样：
```python
[[1, 1, 0], [1, 0, 0]]
```

有了初始状态和转移方程，做完了。

另外，这个DP推导过程中，`dp[i]`只和`dp[i-1]`相关，因此还可以压缩状态成一个2*3的矩阵。
代码中注释给出了非压缩版。