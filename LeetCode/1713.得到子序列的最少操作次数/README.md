## 题目描述
给你一个数组 target ，包含若干 互不相同 的整数，以及另一个整数数组 arr ，arr 可能 包含重复元素。

每一次操作中，你可以在 arr 的任意位置插入任一整数。比方说，如果 arr = [1,4,1,2] ，那么你可以在中间添加 3 得到 [1,4,3,1,2] 。你可以在数组最开始或最后面添加整数。

请你返回 最少 操作次数，使得 target 成为 arr 的一个子序列。

一个数组的 子序列 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的子序列（加粗元素），但 [2,4,2] 不是子序列。

示例 1：
```
输入：target = [5,1,3], arr = [9,4,2,3,4]
输出：2
解释：你可以添加 5 和 1 ，使得 arr 变为 [5,9,4,1,2,3,4] ，target 为 arr 的子序列。
```
示例 2：
```
输入：target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]
输出：3
```

提示：
```
1 <= target.length, arr.length <= 10^5
1 <= target[i], arr[i] <= 10^9
target 不包含任何重复元素。
```

### 解法 哈希表 + 替换单调栈
这题是个缝合解法，但是要想到确实还是有点难度的。

首先，既然要让arr中包含target这个子序列，要操作次数尽量少，根据贪心的思想，应该尽可能地使用arr中已有的数字。
换言之，需要在arr中找到尽量覆盖了target中全部或者一部分的最长子序列。
再换言之，就是找arr和target的最长公共子序列（LCS）。找到这个序列后，将target长度减去这个序列的长度，就可以得到答案了。

不过很遗憾，尝试了一波`O(mn)`的DP之后发现并AC不了，有些数据很长，会超时。

此时注意到，target还有一个条件，就是所有数字都互不相同。
在这种条件下，其实LCS解法还有这么一种套路：将arr中的所有数字都映射成target中的下标。
当然，arr中存在一些target中没有的数字，对于这些数字因为不可能出现在LCS中，所以可以直接忽略。
另一方面，得到一个映射完成后的arr'数组后，只要找到其内部的最长递增子序列，因为target那边是严格递增的`0,1,2,3,...`，所以这个最长递增子序列
就是所求LCS，长度自然也是一样的。

举个例子，比如示例2。经过处理后可以得到arr'是`1 0 5 4 2 0 3`（注意，原arr中的7不存在于target中所以直接忽略了）。
而其中可以找到的一个最长递增子序列如`0 2 3`对应原arr中的`6 8 1`，对比target，再在合适的地方插入`4 2 3`即可。

分析到这里，原问题已经转化为一个`LC.300`的求最长递增子序列长度的问题了。
彼时`LC.300`中，有两种方法。第一种方法通过`O(n^2)`的DP做，因为还是`n^2`，其实和直接求LCS没什么差别，因此不能用。
第二种，则是单调栈的变体（我称之为替换单调栈），通过单调栈+二分查找替换的办法，在`O(nlogn)`时间内就可以找到答案。

以上。