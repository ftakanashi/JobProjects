## 题目描述
给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k <= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。

求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。

说明: 请尽可能地优化你算法的时间和空间复杂度。

示例 1:
```
输入:
nums1 = [3, 4, 6, 5]
nums2 = [9, 1, 2, 5, 8, 3]
k = 5
输出:
[9, 8, 6, 5, 3]
```
示例 2:
```
输入:
nums1 = [6, 7]
nums2 = [6, 0, 4]
k = 5
输出:
[6, 7, 6, 0, 4]
```
示例 3:
```
输入:
nums1 = [3, 9]
nums2 = [8, 9]
k = 3
输出:
[9, 8, 9]
```

### 解法 单调栈+贪心 配合分治思想
这个问题乍一看非常复杂。所以需要冷静一下，看看可以不可以通过先解决一些小问题来入手。

既然是从两个数组中选取固定的k个数字。
一个很自然的想法就是，我可以遍历所有从数组A中选取i，B中选取k-i个数字的情况，然后在各个情况中把两个结果合并起来，最后比较各个情况结果取最大值即可。

于是问题分成了两个小问题。
第一，如何从数组中取出指定的k个数字，在保持原顺序的情况下使得取出的数字最大。
第二，如何尽可能大地合并两个结果，并且保持其各自的原有顺序
>当然这里面还有一个未经证明的小问题：为什么要让最终结果尽量大的话，两个小结果也都应该是最大的。这在直觉上是合理的，这里先不证明了。

上面两个小问题，虽然也不简单，但是是可以尝试解的。

第一个问题，其实就是`LC402`类似的问题。那个题中是指定删除几个数字，而这里是指定保留几个数字，差一个减法而已。
`LC402`可以通过单调栈+贪心的思想来解。这里就不赘述了。
为了解第一个问题，可以定义一个`def pick(nums: List[int], keep: int) -> List[int]`函数。

第二个问题其实很像归并排序中合并的步骤。但是其实比归并更加严格一点点。
差异的地方出在当两个数组中某个数字相同的情况。
比如下面这例子：
```text
6 5 0
5 0 4 
```
如果按照一直以来归并排序中合并部分的代码走，那么i,j分别是2,1时，元素都是0。
归并排序的时候默认两个数组都是有序的，因此可以认为j之后的数字不可能大于0，所以取i还是取j都差不多。事实上为了稳定排序，应该优先取i。

但是这里却不是这样，由于单个数组内没有严格地大小关系，实际上这里如果先取i和先取j两个结果是：
```text
先取i: 6 5 5 0 0 4
先取j: 6 5 5 0 4 0 
```
后者更大。因为j后面还有大于0的数字。

结合上面的例子，其实这道题的合并的过程，其判断取i还是取j并非看`nums1[i]`和`nums2[j]`的大小关系，而是看`nums1[i:]`和`nums2[j:]`的关系。

>这里顺便复习下Python中单元素种类列表大小关系判断的准则。
>
>比如这边全是数字的情况，其实是两个列表挨个元素对比，直到某个位置元素不同，不同处较大元素对应的列表更大。
>如果一个列表是另一个列表的前缀，则自然较长的列表更大。

既然判断准则变了，其实merge函数可以写得更简单：
```python
def merge(res1, res2):
    res = []
    while res1 or res2:
        bigger = res1 if res1 > res2 else res2
        res.append(bigger.pop(0))
    return res
```
>这个函数放在归并排序中也可以work。但是因为比对大小的是两个列表，显然耗时更长。
>因此，写归并排序的时候，还是应该选择用两个游标i,j的方式来做。


综上，有了`pick`和`merge`两个函数之后，接下来只要在外部实现下面的算法即可：
```python
for i in range(k+1):
    res1 = pick(nums1, i)
    res2 = pick(nums2, k - i)
    res = merge(res1, res2)
    取最大的res作为ans
```

最后还有个小trick。因为k和两个数组之间的长度关系没有任何限制，所以会导致情况比较复杂。
为了使得每次pick函数的第二个参数合法，所以可以加一个i和nums1长度以及k-i和nums2长度之间合法关系的判断。
只有两个条件都合法的时候，才去运行pick函数，这样就可以保证不出错了。

以上…~~~~~~~~