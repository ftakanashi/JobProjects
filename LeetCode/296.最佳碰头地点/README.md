## 题目描述
给你一个 m x n  的二进制网格 grid ，其中 1 表示某个朋友的家所处的位置。返回 最小的 总行走距离 。

总行走距离 是朋友们家到碰头地点的距离之和。

我们将使用 曼哈顿距离 来计算，其中 `distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|` 。

示例 1：

![](https://assets.leetcode.com/uploads/2021/03/14/meetingpoint-grid.jpg)
```
输入: grid = [[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]
输出: 6 
解释: 给定的三个人分别住在(0,0)，(0,4) 和 (2,2):
     (0,2) 是一个最佳的碰面点，其总行走距离为 2 + 2 + 2 = 6，最小，因此返回 6。
```
示例 2:
```
输入: grid = [[1,1]]
输出: 1
```

提示:
```
m == grid.length
n == grid[i].length
1 <= m, n <= 200
grid[i][j] == 0 or 1.
grid 中 至少 有两个朋友
```

### 解法 寻找中位数
这道题挺有意思的。

首先理解了题意，然后看到了整个地图最大也就`200*200`于是想直接暴力似乎也不是不可能。
暴力的思路嘛，就是先找出地图中所有的1，记录其位置。
然后遍历地图中所有点，计算其到所有1的位置的总和，然后取全局最小值即可。

果不其然，用Python提交可以过掉56/58个case，剩下两个还是超时了…（后来看答案发现Java等其他语言似乎暴力也可以过
于是看看有没有更好的办法。

直觉上可以感到，寻找一个让大家都路程最短的点似乎是一个很meta的问题，可以通过数学方法来解决。
一下子思考二维的情况可能有些困难，我们可以先来看看一维的情况。

一维时，当有两个点，很明显，两者中点或者尽量靠近中间的点（两者下标和为奇数时）就是所求答案。
比如
```text
1 0 1    # 答案是下标为1
1 0 0 1  # 答案下标可以是1或者2
```
而中点，在两个点的情况下，其实可能代表了两种含义。平均数或者中位数。
当把点加多后，我们发现中位数才是其中的奥义。
举个例子：
```text
1 0 0 0 0 0 0 1 1
```
上面三个1的下标分别是`0 7 8`,其平均值是5，若选择下标5作为碰头地点，那么总距离是`5+2+3=10`。
而若取中位数7，则总距离是`7+0+1=8`，后者更小。

以上虽然是一个未经严格证明的经验性的结论，但是足够应付这道题了。

总结一下，对于一个一维的数组，其中让众多1碰头总距离最小的碰头地点，就是这些1的下标序列的中位数。
若序列长度为奇数，中位数恰好是序列中的某个值；若是偶数，则可以选择正中间左边或右边的任意一个值。
稍微写几个例子就会知道不论选择哪个值，最终的总距离是一样的。

以上是对一维情况的解决和概括。那么二维了怎么办？
由于这题的距离是曼哈顿距离，所以二维可以简单地看做行列两个方向一维情况的结合。

简单来说，从任意一个点`xi,yi`走到碰头地点`x,y`，其距离是行方向的距离和列方向距离的和，而且这两者互相独立。
那么一个很简单的思路就是，对行列分别找中位数即可。

换言之，对于二维地图中所有的1的坐标，将其拆分成横坐标序列和纵坐标序列，并分别从小到大排序。
排序完后直接找横坐标的中位数和纵坐标的中位数，将其视为两个一维问题。
接着求出的两个中位数形成的那个坐标，就是二维地图中所求的坐标了。

基于以上思路就可以轻松写出代码了。