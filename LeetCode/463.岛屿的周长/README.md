## 题目描述
给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。

网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。

示例 :

>输入:
>
>```text
>[[0,1,0,0],
> [1,1,1,0],
> [0,1,0,0],
> [1,1,0,0]]
>```

输出: 16

解释: 它的周长是下面图片中的 16 个黄色的边：

![说明](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/island.png)


### 解法1 遍历统计边
乍一看有点难度，但是仔细想想这个周长是怎么来的？

首先，一块土地最多能提供四个边长。然而如果他边上的格子不是水是土地的话，那么连接土地的这条边就不能算作周长。
因此要减去1。

这么一来，一个最最简单朴素的思路就出现了。

首先统计整个地图上有几个土地格子。

其次，每个土地各自本来可以提供四条边的，然而由于邻接了其他土地，有一定数目的"内部边"
作废。减去这些内部边的数目即可。

时间上O(nm)不可避免，但没有用到额外空间。
另外代码中注意边界的处理。


### 解法2 DFS
一个典型的二维地图DFS探索场景。

只不过，这题里，探索永远从陆地出发，并且探索时需要注意的是
下一个探索位置是不是水或者边界外。只有下一个探索位置是水或者边界外，
那么这条边才可以被计入周长。

当两块陆地相邻时，如果探索不加以任何限制，那么a可以往b探索，由于b也是陆地，则递归地
从b开始探索，没有限制时，他会探索回a。如此形成循环调用，导致死循环。

解决这个问题的办法就是维护一些额外的信息，即"某块陆地已经被探索过了"。
这个信息最直白的办法当然是再整一个同样形状的数组。
不过注意到原数组只用了0和1两个值，如果可以修改原数组的话，可以把已经探索过的陆地
标记为2之类的值，这样就不用额外空间了。

