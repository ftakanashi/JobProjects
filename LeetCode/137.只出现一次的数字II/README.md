## 题目描述
给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。

示例 1：
```
输入：nums = [2,2,3,2]
输出：3
```
示例 2：
```
输入：nums = [0,1,0,1,0,1,99]
输出：99
```

提示：
```
1 <= nums.length <= 3 * 104
-231 <= nums[i] <= 231 - 1
nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次
```
- 进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

### 解法1 哈希表
不解释。

### 解法2 按位确定
如果按照每个二进制位统计，可以发现这么一个规律：
如果不算那个唯一的数字，各个数字位于同一个位的总和，必然是3的倍数。因为都是3个一组的0和3个一组的1加起来。

现在将唯一的数字计入之后，每个位的总和除以3的余数（只能是0或1），其实也就是答案数字这个位的数。

基于这样一个思想，我们可以从0位开始依次扫描到最高位（题设给的限制是32位整数，因此扫描到32位）。

另外需要注意Python对于位运算的特殊处理。
比如当已经确定了前31位，开始要确定最高位的32位，如果发现这个位是1，单纯的使用
```python
res = res | (1 << 32)
```
只会由于溢出，迫使python扩大整数表达，此处需要手动调整。
>一个正整数的二进制表达，将其符号位改为1，变成一个负数后，这个负数是原正数 减去 2**(n-1)

基于上述性质手动调整。

注意到这种算法要逐位检查确定数字，所以整体时间复杂度其实是O(32n)。
好在32是个常数，姑且也算O(n)，但并不是太好。