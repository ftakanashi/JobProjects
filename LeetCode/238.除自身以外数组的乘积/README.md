## 题目描述
给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。

示例:
```
输入: [1,2,3,4]
输出: [24,12,8,6]
 

提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。

说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。

进阶：
你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）
```

### 解法1 前缀和
最简单的解法是求出总乘积然后挨个除一下。
但是题目不让用除法，于是想到了前缀和，或者这题里应该叫前缀积。

单向的前缀积仍然避免不了用除法，因此这里需要双向。
也就是说，比如对于数组`[1,2,3,4]`。
我可以求出正向的前缀积`pre = [1,1,2,6,24]`，
还可以求出逆向的前缀积`rev = [24,24,12,4,1]`。

接着对于某个位置，只要求`pre[i-1] * rev[i]`就可以求得`res[i]`了。

### 解法2 隐式前缀和数组
进一步考虑进阶要求。
上述解法1用了两个O(n)的数组用于保存前缀积。
但是其实我们意识到前缀积数组中的任何一个值，其实从头到尾都只用了一次。
因此我们可以不用显式地维护前缀积的数组。

我们只要实现准备好res数组，然后再扫描，扫描过程中，动态地将前缀积的值乘到相关res中的位置，
便可不用显式地维护前缀积数组。

因为题目说了，返回的res数组不算在空间复杂度里，所以这个空间复杂度是O(1)的。