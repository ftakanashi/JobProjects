## 题目描述
一个字符串的 美丽值 定义为：出现频率最高字符与出现频率最低字符的出现次数之差。

比方说，"abaacc" 的美丽值为 3 - 1 = 2 。
给你一个字符串 s ，请你返回它所有子字符串的 美丽值 之和。

示例 1：
```
输入：s = "aabcb"
输出：5
解释：美丽值不为零的字符串包括 ["aab","aabc","aabcb","abcb","bcb"] ，每一个字符串的美丽值都为 1 。
```
示例 2：
```
输入：s = "aabcbaa"
输出：17
```

提示：
```
1 <= s.length <= 500
s 只包含小写英文字母。
```

### 解法 暴力
没有什么特别巧妙的方法，加上数据范围也很小，直接暴力即可。

暴力的时候还有一点小优化的技巧。
比如我们可以外层遍历左端点，内层遍历右端点。
这样就可以进入外层循环后始终使用同一个counter进行技术了。

另外，每当右端点向右移动，扫描一个新字符的时候，实际上范围内字母计数值的最大值其实是可以实时更新的。
但是最小值没有那么简单，因为有可能`s[j]`刚好就是之前最小值的对应的字母。所以此时不能直接实时更新，只好`min(counter.values())`。

按照以上思路写代码即可。