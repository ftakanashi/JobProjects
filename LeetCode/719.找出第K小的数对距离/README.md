## 题目描述
数对 (a,b) 由整数 a 和 b 组成，其数对距离定义为 a 和 b 的绝对差值。

给你一个整数数组 nums 和一个整数 k ，数对由 nums[i] 和 nums[j] 组成且满足 0 <= i < j < nums.length 。返回 所有数对距离中 第 k 小的数对距离。

示例 1：
```
输入：nums = [1,3,1], k = 1
输出：0
解释：数对和对应的距离如下：
(1,3) -> 2
(1,1) -> 0
(3,1) -> 2
距离第 1 小的数对是 (1,1) ，距离为 0 。
```
示例 2：
```
输入：nums = [1,1,1], k = 2
输出：0
```
示例 3：
```
输入：nums = [1,6,1], k = 3
输出：5
```

提示：
```
n == nums.length
2 <= n <= 104
0 <= nums[i] <= 106
1 <= k <= n * (n - 1) / 2
```

### 解法 排序 threshold二分 + 二分
这题略有意思。
既然要求第k小的数对，那么很自然的思路是从距离最小的数对开始慢慢一点点数，数够k个即可。

而最小的又该如何找？显然可以对数组拍个序，然后按照距离1，2，3...这样一点点去找。
当然真的去数第k个会发现有困难。

因此这里祭出threshold二分的思路。
显然任何数对中，距离的最小值是0，最大值是`max(nums) - min(nums)`。
而要求的答案必然在这之中，因此可以threshold二分。

threshold二分的关键在于实现check函数。这里，显然可以定义`check(mid)`，让其返回当mid作为阈值时，整个数组中距离小于等于mid的数对数量。

当返回小于k时，显然mid过小，因此`l = mid + 1`；大于`k`时则反过来`r = mid - 1`。
这道题的一个细节在于等于`k`时如何处理。当`check(mid)`等于`k`时，此时并不能说明`mid`恰好是要求的那个答案，而可能是有一个浮动范围的。

比如示例1，显然`check(0) == check(1) == 1`，不过只有0是答案。
一番斟酌之后发现，等号应该归结到`check(mid)`大于`k`这边，即对应的处理应该是`r = mid - 1`。
因为我们求的是一段范围的左边界。
以上这段逻辑也可直接用`bisect_left`实现。

至此，还剩下问题，`check`的具体逻辑是什么。
这里也还是用二分的思路。
固定一个末尾数字`nums[j]`（此时`nums`已经排序过），在`check(mid)`的时候，我们只需要找到`nums[j] - mid`这个值
在`nums`中的位置，然后减下两个下标即可得到形如`(x, nums[j])`的数对数量。
针对所有位置`j`都来这么一下就可以求出来了。

综上，在threshold二分大框架的基础上，再使用一般二分实现`check`函数，就是这个题的解法了。

另一方面，其实`check`函数还可以用双指针的办法，不过今天时间不多，就不做了。