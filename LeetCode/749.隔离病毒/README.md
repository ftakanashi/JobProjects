## 题目描述
病毒扩散得很快，现在你的任务是尽可能地通过安装防火墙来隔离病毒。

假设世界由 m x n 的二维矩阵 isInfected 组成， isInfected[i][j] == 0 表示该区域未感染病毒，而  isInfected[i][j] == 1 表示该区域已感染病毒。可以在任意 2 个相邻单元之间的共享边界上安装一个防火墙（并且只有一个防火墙）。

每天晚上，病毒会从被感染区域向相邻未感染区域扩散，除非被防火墙隔离。现由于资源有限，每天你只能安装一系列防火墙来隔离其中一个被病毒感染的区域（一个区域或连续的一片区域），且该感染区域对未感染区域的威胁最大且 保证唯一 。

你需要努力使得最后有部分区域不被病毒感染，如果可以成功，那么返回需要使用的防火墙个数; 如果无法实现，则返回在世界被病毒全部感染时已安装的防火墙个数。

示例 1：

![](https://assets.leetcode.com/uploads/2021/06/01/virus11-grid.jpg)
```
输入: isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]
输出: 10
解释:一共有两块被病毒感染的区域。
在第一天，添加 5 墙隔离病毒区域的左侧。病毒传播后的状态是:
第二天，在右侧添加 5 个墙来隔离病毒区域。此时病毒已经被完全控制住了。
```
![](https://assets.leetcode.com/uploads/2021/06/01/virus13edited-grid.jpg)

示例 2：

![](https://assets.leetcode.com/uploads/2021/06/01/virus2-grid.jpg)
```
输入: isInfected = [[1,1,1],[1,0,1],[1,1,1]]
输出: 4
解释: 虽然只保存了一个小区域，但却有四面墙。
注意，防火墙只建立在两个不同区域的共享边界上。
```
示例3:
```
输入: isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]
输出: 13
解释: 在隔离右边感染区域后，隔离左边病毒区域只需要 2 个防火墙。
```

提示:
```
m == isInfected.length
n == isInfected[i].length
1 <= m, n <= 50
isInfected[i][j] is either 0 or 1
在整个描述的过程中，总有一个相邻的病毒区域，它将在下一轮 严格地感染更多未受污染的方块 
```

### 解法 DFS + 模拟
正如评论区所说，这是一道搬砖题…
逻辑理清后并不复杂，但是代码细节很魔鬼，需要面向error编程…

大体逻辑是这样的：
面对一个初始状况的地图，我们首先扫描全图，统计一下总共有多少格子尚未被感染。后续循环中以这个为指标，当未被感染的格子小于等于0时就直接可以结束循环。

接着，我们需要进行搜索。搜索可以BFS或者DFS。我们这里采用DFS的办法。
具体的DFS函数长这样：
```python
def dfs(x: int, y: int, seen: set) -> Tuple[set, int, set]
```
这个函数的意义是，从坐标`x, y`处开始进行搜索，试图搜索一整片被感染的区域（连通分量）。
`seen`保存的是本轮搜索已经搜索过的格子，防止无限循环。

返回的东西是三个。
第一个是一个哈希集，保存了本轮感染块的今后一轮会感染的所有格子。
第二个是一个整数，表示本轮感染块的墙的数量。
第三个是一个哈希集，保存了本轮感染块内所有格子的坐标。

在函数内部，我们从坐标`x, y`向四周探索，若碰到0，则将其加入下一轮被感染的格子哈希集，以及相关的墙数量`+=1`。
若碰到1，则进行下一轮dfs。

搜索完成后，我们统计所有连通分量，以其下一轮感染块数量为依据进行排序。同时将当前连通分量中的所有块都置-1
（之所以不置零，是因为要考虑到这些方块并没有真的没被感染，而是病毒没了活性，所以需要进行区分）
选择下一轮会感染最多的联通分量，将其墙的数量加到答案中。除了这个连通分量，其余连通分量的下一轮感染块需要全部置1。

以上就是大体的逻辑，具体细节看代码的注释吧。
（这个解法的代码耗时有点长，应该还有很多可以优化的地方…