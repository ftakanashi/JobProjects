## 题目描述
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
 

示例 1：
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)
```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```
示例 2：
```
输入：height = [4,2,0,3,2,5]
输出：9
```

提示：
- n == height.length
- 0 <= n <= 3 * 104
- 0 <= height[i] <= 105

### 解法 单调栈
这题的做法好像蛮多的…
但是这题总感觉和`LC84.柱状图中最大的矩形`很类似，所以特地挑了一个一样的做法记录下来，方便一起记忆。

在从左到右扫描数组的过程中，注意到什么时候才会积水。只有两头高中间低的地形才会积水。
所以从左到右扫描过程中，显然可以维护一个递减的单调栈。只要高度还在减小，就入栈。

那么如果高度不减小了呢，此时至少我们可以说，`stack[-2]`位置和`stack[-1]`位置和当前位置之间，会有积水。
这个积水的量怎么算，首先宽度应该是`stack[-2]`位置和当前位置的差-1。高度则应该是`stack[-2]`位置和当前位置高度中较小的值，减去`stack[-1]`
位置的高度。

之后，就可以直接进行下一位置了吗？似乎还不行。因为当前位置只和最开始的`stack[-2]`之间计算了积水量。
如果`stack[-2]`之前的柱子，还是比当前位置的柱子矮，那么积水会更多（淹没`stack[-2]`）。

所以应该有一个循环，只要栈顶位置的柱子还比当前位置柱子矮，就不断地计算两者之间的雨水量并累加。

循环完成后，当前位置才再入栈。这个入栈的柱子有两种被利用的可能。
第一，和更后面的柱子形成积水。
第二，如果后面的柱子有更高的，作为base用来计算更多积水。

举个例子，比如`2 1 0 3`这个地形。
从左到右三个数都递减，所以入栈。此时栈是`2 1 0`。
接着来了一个3，因为3比0大，所以0先pop出来作为高度base，新栈顶1和3中较小值1再减去base 0 等于 1是高度。位置上，3 - 1 - 1 = 1。
所以这波积水新增1 * 1

但是，接下来，栈顶的1还是比3小，此时1pop出来作为高度base，新栈顶2和3中较小值2减去base 1 等于 1是高度。位置上，3 - 0 - 1 = 2。
所以这波积水新增1 * 2