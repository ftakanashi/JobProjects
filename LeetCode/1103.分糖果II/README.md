## 题目描述
排排坐，分糖果。

我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。

给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。

然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。

重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。

返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。

示例 1：
```
输入：candies = 7, num_people = 4
输出：[1,2,3,1]
解释：
第一次，ans[0] += 1，数组变为 [1,0,0,0]。
第二次，ans[1] += 2，数组变为 [1,2,0,0]。
第三次，ans[2] += 3，数组变为 [1,2,3,0]。
第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。
```
示例 2：
```
输入：candies = 10, num_people = 3
输出：[5,2,3]
解释：
第一次，ans[0] += 1，数组变为 [1,0,0]。
第二次，ans[1] += 2，数组变为 [1,2,0]。
第三次，ans[2] += 3，数组变为 [1,2,3]。
第四次，ans[0] += 4，最终数组变为 [5,2,3]。
```

提示：
```
1 <= candies <= 10^9
1 <= num_people <= 1000
```
### 解法 数学
题目不难理解，直接暴力也毫无难度，也能AC，但是就差点意思了。这里我们尝试用`O(n)`的时间和`O(n)`的空间来解。（`n`是人数哦

不难发现其实这题就是一个稍微需要理一理思路的等差数列。

首先先来定义几个术语。我们要将 `candies` 个糖果分给 `n` 个小朋友的话，
可以分很多个完整的回合，最后一个回合则只有排在前面的一部分人可以分到完整的糖果，最后一个人将分到剩余糖果。

不算最后那个人，显然之前分出去的所有糖果是一个等差数列，假设这部分总共分了 `p` 次，那考虑到分给最后一个人的残余糖果，
其数量应该大于0但是小于 `p + 1`， 则应该有
```
0 <= candies - (1 + p) * p // 2 < p + 1

化简并用Python表达：
p = int((2 * candies + 0.25)**0.5 - 0.5)
```

自然的， 最后一个人分到的残余糖果数量就是
```text
rest = candies - (p + 1) * p) // 2
```

然后我们把一轮分发视作一行，每个人视作一列，整个分发过程实际上就是往这个矩阵里从上到下从左到右填入数字的过程。
针对每一次分发，我们可以像二维矩阵一样，用 row 和 col 来定位。完整分发的行列数为
```text
rows, cols = p // n, p % n
```

比如以 `candies=29, n=3` 来分，形成的矩阵就是
```text
1 2 3
4 5 6
7 1
```

以上面的矩阵为例子，此时我们可以发现，在前2轮完整回合中，一个人能够分到的所有糖果总数是好算的：
```text
(i+1) + (i+1 + n*1) + (i+1 + n*2) + ... + (i+1 + n*rows)
用等差数列求和化简上述式子
(i+1) * rows + (n * (rows*(rows-1)) // 2)
```
其中 `i` 是从零开始的下标。

最后，还需要考虑最后一轮没有对所有人都进行完整糖果分配的情况。这最后一轮中，有部分人是得到了完整的应得的糖果的。
这部分人的特征是 `i < cols`，针对他们，还需要额外地加上 `i + 1 + rows * n`

最后的最后，对于`i`恰好等于`cols`的那个人，他就是最后一轮中虽然分到了，但是只是分到了残余糖果，并没有拿到完整的情况。
此时将最早计算得到的 `rest` 加上去。

至此，整个算法就完成了。
详细细节看代码。