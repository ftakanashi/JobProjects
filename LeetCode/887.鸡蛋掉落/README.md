## 题目描述
给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。

已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。

每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。
如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。

请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？

示例 1：
```
输入：k = 1, n = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 
否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 
如果它没碎，那么肯定能得出 f = 2 。 
因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 
```
示例 2：
```
输入：k = 2, n = 6
输出：3
```
示例 3：
```
输入：k = 3, n = 14
输出：4
```

提示：
```
1 <= k <= 100
1 <= n <= 10^4
```

### 解法 DP + 二分查找
这道是经典的谷歌面试题，确实很复杂，记不下来也不要气馁，就当是锻炼锻炼思维了。
有一些公司也喜欢套用原题，姑且就当死记硬背套路吧。

核心思想，首先是要用DP。

定义DP数组`dp[i][j]`为使用`i`个鸡蛋确定`j`层高楼的情况。
首先，初始化情况可以确定：
- 如果`j==0`，那么`dp[i][j] = 0`
- 如果`i==0`，那么除了`j==0`的情况，其他都是无穷大。
- 如果`i==1`，此时相当于用一枚鸡蛋找出答案f，此时最保守的情况就是一层一层试，否则可能会导致无法找到f。换言之，有`dp[i][j] = j`。

接下来是状态转移方程。
当我们需要确定`dp[i][j]`时，假设我们拿出一个鸡蛋来尝试楼层。此时应该如何尝试。
一个简单的方案，是从`f=1`处开始一层层向上尝试。在`x`楼尝试时，

- 如果鸡蛋碎了，那么答案楼层必然在1到当前楼层下面一楼中，此时有`dp[i][j] = dp[i-1][x-1] + 1`。
- 如果鸡蛋没有摔碎，那么答案楼层必然在当前楼层向上到`j`楼的这些楼层里此时有`dp[i][j] = dp[i][j-x] + 1`。
（注意，找出答案楼层需要的次数与楼层的绝对高度无关，而和需要探索楼层的范围大小有关。换言之，加入我现在知道答案在1-3层间和知道答案在8-10层间，
两种情况需要的尝试次数是一样的，因此可以有上面这个转移方程）

由于总是最坏情况，因此我们要找的是两者中的大值。而这些值又随着`x`的变化而变化，需要找到所有`x`中能够使这个大值尽量小的答案。
总结一下，就是
```python
dp[i][j] = min(
    max(dp[i-1][x-1], dp[i][j-x]) + 1
    for x in range(1, j+1)
)
```
其实到这里为止，DP数组和转移方程都有了，可以写代码了。
但是按照上面的一个for循环的做法，显然整体复杂度在`O(K * N^2)`。会超时。

下面介绍用二分查找来进一步优化的做法。
注意到，DP数组中的每一行，从左到右都是递增的。这也符合其物理意义。

如果将`dp[i-1][x-1]`和`dp[i][j-x]`视为两个关于x的函数，因为行内的递增性，所以这两个函数分别是单调递增和递减的函数。
于是原问题就变成了，当自变量`x`增加过程中，有一个关于x的函数`t1`递增，另一个关于x的函数`t2`递减。
找出两个函数值的最大值 最小的情况。

可以想象，当`x`很小时，`t1`很小但是`t2`很大，反之当`x`很大时情况相反。这些极端的情况都不利于两者中大值尽量小的要求。
于是，很自然想到，其实x应该是一个接近于两者交点附近的值。此时就可以用二分查找的办法来找到这个值了。

具体的，将`l, r = 1, j`，然后通过判断`dp[i-1][mid-1] dp[i][j-mid]`互相间的大小关系来移动游标逼近范围。
由于两个函数可能并不相交，所以最终取
```python
min(
    max(dp[i-1][c-1], dp[i][j-c]) for c in (l, r)
) + 1
```
作为`dp[i][j]`的取值。
这样，针对每个状态，由于二分查找，可以O(logn)时间内找到答案，因此总体复杂度优化到`O(N * K * logN)`。

另外，如果采用经典的DP数组遍历的形式，LC后台判定超时。因此抄答案，答案使用了类似记忆化DFS的方法去解。
思路是一样的，无非将DP状态通过`dp[i, j] = value`的形式保存在了字典中。这样可以AC。