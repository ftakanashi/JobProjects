## 题目描述
给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。

请你找出符合题意的 最短 子数组，并输出它的长度。

示例 1：
```
输入：nums = [2,6,4,8,10,9,15]
输出：5
解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
```
示例 2：
```
输入：nums = [1,2,3,4]
输出：0
```
示例 3：
```
输入：nums = [1]
输出：0
```

提示：
```
1 <= nums.length <= 104
-105 <= nums[i] <= 105
```
```
进阶：你可以设计一个时间复杂度为 O(n) 的解决方案吗？
```

### 解法1 堆
排序数组的一个性质是，其第一个数总是全局最小的，最后一个数总是全局最大的。

从左侧看，如果当前第一个数确实是全局最小数，那么就看第二个数是不是全局第二小。
显然，全局最小可以用一个小顶堆，而获取全局第二小的数则只要把小顶堆的堆顶pop掉即可。

这样，第一个思路就有了。
首先从左到右扫描，并且实时维护一个小顶堆。初始化情况下，小顶堆内有数组的完整内容。
当从左到右扫描过程中，`nums[i] == heap[0]`，就pop掉堆顶并继续扫描。
一旦有不相等的情况，则说明`i`就是要求的子数组的左边界。

同理，从右向左扫描维护一个大顶堆，可以找到右边界。

官方题解中提到了排序解法，更为方便。直接将nums排序后，挨个位置比较nums与排序后的nums，碰到从左到右第一个不同的就是左边界，同理可得右边界。

两个方法本质上是相同的，都需要`O(nlogn)`。
排序法就不写了。

### 解法2 （最值）单调栈
输入数组理论上可以被分为三部分`nums_a, nums_b, nums_c`。其中a和c两部分是已经排完序的，而b是待排序的。题目求的就是b的长度或者说b的边界。

注意到，`nums_a`具有这样一个性质：其中的数`nums[i]`是`nums[i:]`中最小的数。
于是我们只需要从左到右扫描找到第一个不满足上述条件的数，就是`nums_b`的左边界了。

要找到这样的数也很容易。只需要先扫描一遍`nums`，找到其中每个位置，其右边最小的值即可。
这可以通过从右到左的一次扫描搞定。比如示例1输入，得到的数组是`2 4 4 8 9 9 15`。第一个不同的位置发生在下标1，`nums[1]`是6而这里是4。因此1是左边界。
由于这个数组是一个单调不递减的，姑且称之为最值单调栈。其实我也没想好这种套路该叫什么。

同理，针对右边界，可以求得一个数组，其中每个位置`i`是`nums[:i+1]`中的最大最值。
这次数组是`2 6 6 8 10 10 15`。然后从右往左扫描，发现了下标5是右边界。

然后就完事了。
最后别忘了考虑下特殊情况比如输入数组本身有序。此时左边界定在数组长度`n`上，因此此时直接返回0。

虽然上面这种做法似乎并没有真的用到单调栈，但是套路的感觉来说，很像`LC.84`那种感觉。所以姑且取名单调栈了。