## 题目描述
小写字符 的 数值 是它在字母表中的位置（从 1 开始），因此 a 的数值为 1 ，b 的数值为 2 ，c 的数值为 3 ，以此类推。

字符串由若干小写字符组成，字符串的数值 为各字符的数值之和。例如，字符串 "abe" 的数值等于 1 + 2 + 5 = 8 。

给你两个整数 n 和 k 。返回 长度 等于 n 且 数值 等于 k 的 字典序最小 的字符串。

注意，如果字符串 x 在字典排序中位于 y 之前，就认为 x 字典序比 y 小，有以下两种情况：

x 是 y 的一个前缀；
如果 i 是 x[i] != y[i] 的第一个位置，且 x[i] 在字母表中的位置比 y[i] 靠前。

示例 1：
```
输入：n = 3, k = 27
输出："aay"
解释：字符串的数值为 1 + 1 + 25 = 27，它是数值满足要求且长度等于 3 字典序最小的字符串。
```
示例 2：
```
输入：n = 5, k = 73
输出："aaszz"
```

提示：
```
1 <= n <= 105
n <= k <= 26 * n
```

### 解法 贪心
题目不难理解，但官方题解的数学推理我感觉有点问题。
这里采用了评论中的另一种解法。

要用贪心思想做，这个是不难发现的。
也就是说从左到右决定字母的过程中，遵循能用小的尽量用小的原则。换言之，最终的答案往往是长成`aa...`这样的。
当然某些情况不得不用非`a`开头的比如`n=2, k=28`，此时答案就是`bz`了。

下面来说算法。
首先应用贪心思想，我们首先假设所有字母都是`a`，此时可以形成长度为`n`的前提下值最小的字符串，即`n`个`a`。
此时字符串的值和目标值`k`之间肯定存在很大差距。
所以我们要弥补这些差距。具体手段就是将某些`a`换成更大的字母，。

为了保证最终的字典序尽量小，优先从右端开始修改。
此时，当前字符串的总值和目标值`k`之间的差距就成为了最主要需要关注的因素。
我们设这个值为`diff`。显然`diff`的初始值是`k - n`。

当`diff > 25`时，说明此时仅替换一个字母是不够的，因为即便将`a`替换为最大的`z`那也只会给总值带来25的贡献。
所以在把最右侧字母替换为`z`之后还需要继续向左扫描。
当`0 < diff < 25`时，替换一个字母就能成。
当`diff == 0`时，可以终止扫描。

按照以上思想写代码即可。
具体如何拼凑最终的字符串是很简单的事情，也有很多方案，这里就不多说了。