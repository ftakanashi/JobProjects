## 题目描述
给定二叉树的根节点 root，找出存在于 不同 节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。

（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）

示例 1：

![](https://assets.leetcode.com/uploads/2020/11/09/tmp-tree.jpg)
```
输入：root = [8,3,10,1,6,null,14,null,null,4,7,13]
输出：7
解释： 
我们有大量的节点与其祖先的差值，其中一些如下：
|8 - 3| = 5
|3 - 7| = 4
|8 - 1| = 7
|10 - 13| = 3
在所有可能的差值中，最大值 7 由 |8 - 1| = 7 得出。
```
示例 2：

![](https://assets.leetcode.com/uploads/2020/11/09/tmp-tree-1.jpg)
```
输入：root = [1,null,2,null,0,3]
输出：3
```

提示：
```
树中的节点数在 2 到 5000 之间。
0 <= Node.val <= 105
```

### 解法 DFS
针对一个子树进行DFS的过程中，有三个要素比较重要。分别是
子树中节点的最小值，子树中节点的最大值，子树内部符合题目要求的最大差值。

对于任意一个节点，其左子树返回的上述三个值，右子树返回的上述三个值，结合节点自身的值，就可以拼凑出以该节点为子树的
上述三个需要返回给上层dfs的值。

具体的，记左子树的三个值分别是`l1, l2, l3`，右子树的三个值分别是`r1, r2, r3`。
显然，本层dfs应该返回的三个值分别是
```python
min(l1, r1, node.val)
max(l2, r2, node.val)
max(
    l3,
    r3,
    abs(node.val - l1),
    abs(node.val - l2),
    abs(node.val - r1),
    abs(node.val - r2),
)
```

前两个很好理解。
第三个的前两个候选值是 l3 和 r3 也很好理解，而如果不是这两个值，那么答案只可能是当前节点值与所有子节点的最大/最小值的差。
所以就把四种可能全部都考虑进去。

实际编码时还需要注意为了处理叶子节点的极端情况，需要判断l1l2l3,r1r2r3这些值是无穷大/小的情况。
具体细节看代码。