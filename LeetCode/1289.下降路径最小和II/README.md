## 题目描述
给你一个 n x n 整数矩阵 grid ，请你返回 非零偏移下降路径 数字和的最小值。

非零偏移下降路径 定义为：从 grid 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。

示例 1：

![](https://assets.leetcode.com/uploads/2021/08/10/falling-grid.jpg)
```
输入：grid = [[1,2,3],[4,5,6],[7,8,9]]
输出：13
解释：
所有非零偏移下降路径包括：
[1,5,9], [1,5,7], [1,6,7], [1,6,8],
[2,4,8], [2,4,9], [2,6,7], [2,6,8],
[3,4,8], [3,4,9], [3,5,7], [3,5,9]
下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。
```
示例 2：
```
输入：grid = [[7]]
输出：7
```

提示：
```
n == grid.length == grid[i].length
1 <= n <= 200
-99 <= grid[i][j] <= 99
```

### 解法 DP
一眼DP。
定义`dp[i][j]`表示，某个包含了前`i`行路径且最后一个格子为`grid[i][j]`时，路径最小的和。
显然，`dp[0]`等于`grid[0]`，且最终答案是`min(dp[-1])`。

至于状态转移方程也不难写。
由于唯一的限制条件是，`dp[i][j]`对应的路径，不上一层不能是`dp[i-1][j]`，所以只要找出`dp[i-1]`中，除了`dp[i-1][j]`外
最小的值即可。

一个朴素的做法，是统计`min([dp[i-1][k] for k in range(n) if j != k])`。
当然这样的话，算上外面的两层循环，最终复杂度会是`O(n^3)`的，不过这题的整体数据范围不大，所以可以AC。

一个可行的优化方案，是参考`LC.265`，用两个变量维护dp数组中每行的最小值和次小值，以及各自对应的下标。
这样，只要最小值的下标不是当前扫描到的`j`，那么就可以直接取用最小值，否则就取用次小值。
本行的这两个值的维护可以在从左到右填写DP值的过程中补充上。