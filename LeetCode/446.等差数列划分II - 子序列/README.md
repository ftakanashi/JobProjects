## 题目描述
给你一个整数数组 nums ，返回 nums 中所有 等差子序列 的数目。

如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。

例如，[1, 3, 5, 7, 9]、[7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。
再例如，[1, 1, 2, 5, 7] 不是等差序列。
数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。

例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。
题目数据保证答案是一个 32-bit 整数。

示例 1：
```
输入：nums = [2,4,6,8,10]
输出：7
解释：所有的等差子序列为：
[2,4,6]
[4,6,8]
[6,8,10]
[2,4,6,8]
[4,6,8,10]
[2,4,6,8,10]
[2,6,10]
```
示例 2：
```
输入：nums = [7,7,7,7,7]
输出：16
解释：数组中的任意子序列都是等差子序列。
```

提示：
```
1  <= nums.length <= 1000
-231 <= nums[i] <= 231 - 1
```

### 解法 DP（空间优化）
本题是`LC.413`的复杂变体。

相比于413，这里求的不再是子数组，而是子序列，这就意味着对于固定的位置`i`，
其可能的级差不再仅仅是`nums[i] - nums[i-1]`，还有可能是减去更前面的一些数得到的各种各样的值。

基于这种情况，普通的LIS肯定不行了。
不过既然你又引入了一个"变化的级差"这个可变因素，于是就采用DP维度的办法将其整合到DP推理过程中就行了。
于是第一个想法很快出炉，声明一个`n * m`二维DP数组。
其中n是输入数组长度，而m是数组 `(最大值-最小值) // 2`（因为级差不可能比这个值更大。
`dp[i][j]`被定义为前`i`个数字中，级差为`j`的等差子序列的个数。

然而，在尝试了一系列复杂的状态转移方程后，仍然撸不出正确答案。

尤其是，输入case中有一个超时：`[0,2000000000,-294967296]`，可以看到`m`直接爆炸。

于是看了答案。

首先，针对上述`m`爆炸的问题，注意到绝大多数`dp[i][j]`都是0。因为有效的级差是稀疏的。
于是我们采用一个非典型的DP数组声明方式，即利用哈希表或者说字典代替原先每一行的数组。
这样，就可以不用构建出完整的`m`长度的数组了。

既然用哈希表代替了数组，显然我们也不能再以挨个遍历级差的方式进行DP探索了。
于是转变视角，直接从输入数据入手。

具体的，针对`i`位置，可以扫描所有`for j in range(i)`，并计算可能的级差`diff = nums[i] - nums[j]`。
然后再`dp[i]`这个字典中维护以`nums[i]`为结尾且级差为diff的前序数字个数。
**（注意，这里不是维护符合要求子序列个数，而是数字个数。这么做的好处下面说。）**

显然，`dp[i][diff] += dp[j][diff] + 1`。
（这里用+=是因为考虑到可能有多个相同的`nums[j]`）

但是这里要注意，`dp[i][diff]`并不是以`nums[i]`为结尾且级差是`diff`的序列个数。

比如例子`2 4 6 8`和`4 4 4 6`。
对于两个例子的最后一个位置而言，都可以得到`2: 3`的结论。
但是这无法直接推导等差子序列个数。

事实上，正确的推导方式是这样的：
在位置`i`，扫描`for j in range(i)`时，`diff = nums[i] - nums[j]`。
若`dp[j][diff] > 0`或者说`diff in dp[j]`的时候，说明以`diff`为级差时在`j`前面至少有一个等差的前序数。

这样，加上`j`本身和`i`本身，就构成了至少长度是3的一个等差序列。
此时`ans += dp[j][diff]`。

语言描述很难说清，但是看一下代码，相信很快就能明白其中道理。