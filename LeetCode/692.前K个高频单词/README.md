## 题目描述
给一非空的单词列表，返回前 k 个出现次数最多的单词。

返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。

示例 1：
```
输入: ["i", "love", "leetcode", "i", "love", "coding"], k = 2
输出: ["i", "love"]
解析: "i" 和 "love" 为出现次数最多的两个单词，均为2次。
    注意，按字母顺序 "i" 在 "love" 之前。
 
```
示例 2：
```
输入: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4
输出: ["the", "is", "sunny", "day"]
解析: "the", "is", "sunny" 和 "day" 是出现次数最多的四个单词，
    出现次数依次为 4, 3, 2 和 1 次。
```

注意：
- 假定 k 总为有效值， 1 ≤ k ≤ 集合元素数。
- 输入的单词均由小写字母组成。

扩展练习：
尝试以 O(n log k) 时间复杂度和 O(n) 空间复杂度解决。

### 解法1 自定义排序
思路很明显，第一排序要素是count数，第二排序要素是单词序。

可以先整一个counter，然后将(cnt, word)元组抽取出来，根据上面的排序要素顺序进行排序即可。
排序具体可以自己实现一个排序函数，也可以用库函数。

用库函数的时候，由于count的顺序和word的顺序相反，如果你写类似于
```python
kvs.sort(key=lambda x: (kvs[x], x), reverse=True)
```
的话，单词也会被排成倒序的。

因为这里刚好count是一个数字，所以加个负号就可以解决，即
```python
kvs.sort(key=lambda x: (-kvs[x], x))
```
排序完成后取前k个即可。

### 解法2 堆
之前对这题解有些奇怪的误解。这次自己做出来了，就重新写一下。

为了找出前K高词频单词，扫描一遍所有单词的O(n)并记录其频数的操作是不可避免的了。
解法1中，直接将所有频数进行了排序，自然如果`k<<n`，则会有很多不必要的排序操作。

这里，可以利用堆实现前K词频提取。
具体的，维护一个小顶堆，堆中维护前K词频的词和词频数。
显然，新拿到一个词频数时，
如果堆的size还小于k，则无脑入堆；
如果堆的size已经是k，但是新词频数大于当前堆顶的词频数，此时说明应该将堆顶弹出并将新词频数入堆。

如此，使堆的size始终不大于k，就可以在扫描结束时得到所有数据中前K大的所有数了。
因此时间复杂度是O(nlogk)的。

另外，这题比较tricky的一点是，他不仅仅要求对词频数排序，还要求对词也排序。
这里比较麻烦。因为我们维护的是小顶堆，所以词频数是可以直接以正数，即升序入堆的。
在堆里，词频数越小的优先级越高。

但是另一方面，词频数相等的情况时，优先考虑保留单词排序更靠前的，也就是说要让字典序更大的词放在堆里优先度更高的位置。
然而在使用python的heapq库的时候，字符串没有办法直接加个负号改变其堆的排序方向。

此时，除了不用heapq，转而自己实现堆逻辑之外，还可以构造数据结构并且自定义比较大小的办法来解决。
具体的，定义如下类：
```python
class Entry:
    def __init__(self, cnt, word):
        self.cnt = cnt
        self.word = word

    def __gt__(self, other):
        if other.cnt != self.cnt:
            return self.cnt > other.cnt
        else:
            return self.word < other.word
```
实现了`__gt__`魔法方法之后，我们就可以直接拿新来的对象和当前堆顶比大小。
只有新对象的cnt更大，或者两者cnt一致但是新对象的word字典序更小的情况，需要弹出堆顶并且将新对象入堆。

将所有数据包在Entry这个类里面之后，就可以一边用heapq，一边实现上述算法了。

最后，由于最终输出的单词排序也是有要求的，因此需要对扫描完成后的堆，其中包含的信息做重新的整理。
这部分代码虽然多，但是并不复杂。简单来说就是根据词频降序，再根据单词字典序升序排列，挨个收割结果即可。