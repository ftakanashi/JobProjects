##题目描述
给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。

示例 1:
>输入: [1,2,0]
>
>输出: 3

示例 2:
>输入: [3,4,-1,1]
>
>输出: 2

示例 3:
>输入: [7,8,9,11,12]
>
>输出: 1
 

提示：
- 你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。

### 解法1 堆
>一开始没整明白，以为堆的pop是O(1)的操作，但是仔细想想应该是O(logn)的啊。
>所以这个解法严格来说时间是O(nlogn)，所以和排序是一样的。
>
>不过总归写出来了，就当参考写一下吧。

显然，建立一个小顶堆，然后不断地检查堆顶即可。
对于<=0的情况直接pop，对于大于0的情况则检查第一个未出现的数。


### 解法2 脑筋急转弯，原地哈希
如果原题没有常数空间复杂度的限制，那么一个很显然的做法是扫描一遍原数组把所有元素入哈希表。

然后从1开始依次遍历，查看某个数在不在哈希表中即可。

现在要求用常数空间，我是想不到这种办法…官方题解将原数组改造成了一个哈希表。

具体做法如下：
![](https://assets.leetcode-cn.com/solution-static/41/41_fig1.png)

基本想法是，如果一个数组的长度是N，那么答案只可能是1,2,3...N+1这N+1种答案。

N+1这个答案还是比较特殊的，即原数组恰好是`range(1,n+1)`时。

总之，为了找到这个答案，我们扫描原数组，每当扫描到一个处于`1~N+1`中的数`n`时，
我们将原数组中的置负作为一个标记。为什么用置负作为标记后面再说。

这样我们只要最后扫描一遍，查找第一个非负元素的下标，就可以找到相应的答案。

当然很容易想到，原数组中大于`N+1`或者小于等于零的那些数很碍事。
可以先预处理一遍将他们全部都置统一的一个,不在`1~N`范围内的大值从而避免其对最后一步判断产生影响。
官方答案用了`n+1`，而我用了`float('inf')`

至此一切都看似OK了。最后要注意一点。答案的第二个循环中，套了很多abs。
这是因为避免之前有"前面的值 置了后面的负" 的情况。比如上图中的`i=1`时，`nums[i]`是4。
根据规则`nums[4]`被置负。这样当`i`变成4时，本来应该将`nums[1]`置负的。如果不用abs，那就变得要去置负最后一个即`nums[-1]`了。

以上，置负操作是一个既能起到标记作用，又能方便地保留原来的信息的操作。
这也是上面提到的，为什么用置负作为标记操作的原因了。