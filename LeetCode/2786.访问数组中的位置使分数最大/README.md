## 题目描述
给你一个下标从 0 开始的整数数组 nums 和一个正整数 x 。

你 一开始 在数组的位置 0 处，你可以按照下述规则访问数组中的其他位置：

如果你当前在位置 i ，那么你可以移动到满足 i < j 的 任意 位置 j 。
对于你访问的位置 i ，你可以获得分数 nums[i] 。
如果你从位置 i 移动到位置 j 且 nums[i] 和 nums[j] 的 奇偶性 不同，那么你将失去分数 x 。
请你返回你能得到的 最大 得分之和。

注意 ，你一开始的分数为 nums[0] 。


示例 1：
```
输入：nums = [2,3,6,1,9,2], x = 5
输出：13
解释：我们可以按顺序访问数组中的位置：0 -> 2 -> 3 -> 4 。
对应位置的值为 2 ，6 ，1 和 9 。因为 6 和 1 的奇偶性不同，所以下标从 2 -> 3 让你失去 x = 5 分。
总得分为：2 + 6 + 1 + 9 - 5 = 13 。
```
示例 2：
```
输入：nums = [2,4,6,8], x = 3
输出：20
解释：数组中的所有元素奇偶性都一样，所以我们可以将每个元素都访问一次，而且不会失去任何分数。
总得分为：2 + 4 + 6 + 8 = 20 。
```

提示：
```
2 <= nums.length <= 105
1 <= nums[i], x <= 106
```

### 解法 DP 一次遍历
这题可以感觉到用DP。
初步想法构建一个与原数组等长的DP数组。将`dp[i]`定义为访问到`i`时能够获得的最大分数。

然而很快发现，这个分数其实取决于：之前访问过的所有偶数分数和奇数分数的最大值。我们分别定义其为 `eve_max` 和 `odd_max`。
这里，"偶数分数"和"奇数分数"定义为访问到某个数字是偶数时获得的分数与奇数时获得的分数。
（显然，根据`nums[0]`的初始值，可以将其中一个值设置为`nums[0]`。此外还需要注意的一点是，考虑到 `x` 可能很大，因此扣分可能扣成很小的负分，
因此另一个值初始化时应当设置为 `-inf` 最为保险。

之所以这么说，是因为
- 如果`nums[i]`是奇数，那么其可获得的分数是 `odd_max + nums[i]` 或者 `eve_max + nums[i] - x`。
- 如果`nums[i]`是偶数，那么其可获得的分数是 `eve_max + nums[i]` 或者 `odd_max + nums[i] - x`。

注意，上述式子算出的只是当前位置能够获得的最大分数。将其定义为`curr`的话，算出来之后
第一，需要将其和已经获得过的历史答案`ans`之间取大者。实际意义就是，为了获得最大分数我们不一定要遍历完整个数组，因此要获取过程中的最大者而不是
`nums[-1]`对应的DP值。
第二，别忘了结合`nums[i]`的奇偶性，更新 `odd_max` 或者 `eve_max`。

将上述思路代码化即可。