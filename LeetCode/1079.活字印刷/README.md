## 题目描述
你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。

注意：本题中，每个活字字模只能使用一次。

示例 1：
```
输入："AAB"
输出：8
解释：可能的序列为 "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA"。
```
示例 2：
```
输入："AAABBC"
输出：188
```
示例 3：
```
输入："V"
输出：1
```
 

提示：
```
1 <= tiles.length <= 7
tiles 由大写英文字母组成
```

### 解法1 暴力
这题是一道不太复杂的排列组合题。注意到因为最大的输入字符串长度才是7，相当于整个可供探索的空间最大最大也就
`A11 + A22 + ... + A77` 大概是14000种左右。所以完全可以暴力破。

暴力的话借助`itertools.permutations`和哈希集等数据结构，Python一行就能搞定，不多说了。

### 解法2 DFS 回溯
由于字母中相同的字母彼此之间没有区别，所以可以直接用一个哈希表将所有字母计数，然后dfs探索。
每探索到一个特定位置时，一方面需要决定当前位置可以选哪些字母（当然就是`counter`中计数值仍然大于零的那些

另一方面还需要考虑扫描到当前位置后，当前长度的字符串作为最终答案中的一种。（因为题目要求的并不是`len(tiles)`长度的排列有多少种，
而是从长度为1开始到长度`len(tiles)`的所有排列的种类数。

首先基于第一点可以搭建一个基础的dfs框架：
```python
tiles = "xxxxx"
n = len(tiles)
counter = Counter(tiles)

def dfs(pos):
    if pos == n: return 1
    res = 0
    for ch in counter:
        if counter[ch] == 0: continue
        counter[ch] -= 1
        res += dfs(pos + 1)
        counter[ch] += 1

    return res

dfs(0)
```

注意dfs函数中，`res`的初始化值很关键。
当如上所示`res = 0`时，那么可以看到所有dfs的返回值唯一会发生增加的情况，是dfs探索到了最长的长度`n`。
换言之，当`res = 0`时，最终答案其实是求的 长度为`len(tiles)`的排列种类数。

那么如何将长度小于`len(tiles)`的排列也统计进去呢？
很简单，将`res = 1`即可。
这样，相当于每种长度的每种可能的排列开始向下dfs探索时，其本身都被算进去了。
从这个意义上来说，其实dfs最开头的`if pos == n`的判断也是不用的，因为到最后的时候`counter`中所有计数都为零，肯定不会进一步向下展开dfs了。
而此时的`res = 1`就表示长度为`len(tiles)`的一种排列。

但是改了之后发现还是不能AC。观察后发现输出答案总是比正确答案大了1。

原来，按照上述思路设计的算法，在第一层dfs的时候，`res = 1`也会生效，但是此时还没有选任何字母，
换言之，这个时候代表的情况其实是一个空字符串。而题目不把空字符串计入结果，所以最外层应当返回的事`dfs(0) - 1`。

以上。
