## 题目描述
你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。

如果文件夹 folder[i] 位于另一个文件夹 folder[j] 下，那么 folder[i] 就是 folder[j] 的 子文件夹 。

文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：'/' 后跟一个或者多个小写英文字母。

例如，"/leetcode" 和 "/leetcode/problems" 都是有效的路径，而空字符串和 "/" 不是。

示例 1：
```
输入：folder = ["/a","/a/b","/c/d","/c/d/e","/c/f"]
输出：["/a","/c/d","/c/f"]
解释："/a/b/" 是 "/a" 的子文件夹，而 "/c/d/e" 是 "/c/d" 的子文件夹。
```
示例 2：
```
输入：folder = ["/a","/a/b/c","/a/b/d"]
输出：["/a"]
解释：文件夹 "/a/b/c" 和 "/a/b/d/" 都会被删除，因为它们都是 "/a" 的子文件夹。
```
示例 3：
```
输入: folder = ["/a/b/c","/a/b/ca","/a/b/d"]
输出: ["/a/b/c","/a/b/ca","/a/b/d"]
```

提示：
```
1 <= folder.length <= 4 * 104
2 <= folder[i].length <= 100
folder[i] 只包含小写字母和 '/'
folder[i] 总是以字符 '/' 起始
每个文件夹名都是 唯一 的
```

### 解法 字典树
理解题意之后就不难想到字典树的思路了。

大体的框架就是围绕着所有folder进行一个字典树的构建。
注意虽然示例中每个文件夹名都是一个字符的，但是题目并没有明确给出这个限制。
因此可能是多字符的。

也就是说每个字典树节点`Trie`中的`children`不能以有限的数组形式给出了，而是要以哈希表的形式给出。

接下来就是要从字典树中判断出哪些是子文件夹了。
这个也很简单。
别忘了字典树节点有`end`这个属性。

从整个字典树的根节点沿着任意一条路径扫描。当碰到某个节点`end`是True的时候，
说明这个节点再往下构成的所有路径都是子文件夹，因此可以不用继续扫描，直接返回即可。

所以，构建完字典树之后，再用一次dfs扫描，扫到`end`是True的就停止返回，然后把各条路径拼接起来即可。
具体逻辑可以看代码注释。