## 题目描述
给你一棵二叉树，请按以下要求的顺序收集它的全部节点：

依次从左到右，每次收集并删除所有的叶子节点
重复如上过程直到整棵树为空

示例:
```
输入: [1,2,3,4,5]
  
          1
         / \
        2   3
       / \     
      4   5    

输出: [[4,5,3],[2],[1]]
 

解释:

1. 删除叶子节点 [4,5,3] ，得到如下树结构：

          1
         / 
        2          
 

2. 现在删去叶子节点 [2] ，得到如下树结构：

          1          
 

3. 现在删去叶子节点 [1] ，得到空树：

          []         
```

### 解法1 朴素dfs模拟
根据题目意思 遍历多次，每次遍历时摘取所有叶子节点。
有一个小问题是一次遍历过程中，针对叶子节点的父节点，如何告知它叶子节点已经被摘除了。
我的实现中采用了如下办法，一旦某个节点确定为叶子，在将其值收割到结果中后将其值置为None。

这样，针对一个节点，我dfs完其左右子节点后，进一步再检查一下左右子节点是否值被置None，若被置None，则`node.left = None`或者`node.right = None`，
做了剪节点操作。

很显然，这个做法是比较暴力的，因为每一轮遍历只能收割当前树中的叶子节点，
而比较靠近根节点的那些节点会被在多轮遍历中被扫描到很多次。

一个优化的办法是，在扫描过程中统计所有节点的深度（离叶子节点的距离）。
这样就可以在一次扫描中就确定某个节点会在原上述方法的第几轮被收割，从而确定将其放到具体哪个子数组中。
因此可以一次扫描便获得完整结果。

不过我懒得写了所以就写了暴力doge