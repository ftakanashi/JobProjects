## 题目描述
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

![](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png) 

示例 1：
```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```
示例 2：
```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```
提示：
- 树中节点数目在范围 [2, 105] 内。
- -109 <= Node.val <= 109
- 所有 Node.val 互不相同 。
- p != q
- p 和 q 均存在于给定的二叉树中。

### 解法 递归（后序遍历）
一开始想了一会儿没想到什么好办法，就写了个DFS出到p和q的两条路径，然后比对两条路径找到第一个分叉点。
虽然AC了，但是果然耗时耗空间都比较大。

于是看了眼答案。用递归可以更快更好地解决这个问题。

我们发现，所谓的最近公共祖先，其实就是唯一一个可以做到，p和q一个存在于其左子树，一个存在于其右子树的节点。

于是我们可以整一个DFS函数用来判断p或q是否在某个子树内。如果是，则返回p或q节点，否则返回None。

递归地探索过程中，如果递归到左右子树分别都返回了节点，那么当前递归层的节点node就是所求节点，可以将其返回出去。
如果左右子树只有一个返回了p或者q节点，说明此时该子树内只有一个目标节点，公共祖先应该在更高层，因此直接将这个p或q节点返回出去。

递归终止条件，显然当节点本身是None时应该返回None。
另外，如果节点本身就是p或q时，自然就返回节点本身。这可能会导致另一个节点如果再当前节点的子树内就无法被遍历到，比如上例中的2，4。
但是根据定义，此时公共祖先就是层数更小的2，所以不去遍历4没有问题，加之其他地方的子树都是返回None的，不会影响到结果。最终可以获得正确答案。

由于dfs是先后进行了左右子树的遍历，最后再根据左右子树返回情况处理当前节点，所以这也是一个后序遍历的变体。