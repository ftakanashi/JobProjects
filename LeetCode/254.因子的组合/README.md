## 题目描述
整数可以被看作是其因子的乘积。

例如：
```
8 = 2 x 2 x 2;
  = 2 x 4.
```
请实现一个函数，该函数接收一个整数 n 并返回该整数所有的因子组合。

注意：
```
你可以假定 n 为永远为正数。
因子必须大于 1 并且小于 n。
```
示例 1：
```
输入: 1
输出: []
```
示例 2：
```
输入: 37
输出: []
```
示例 3：
```
输入: 12
输出:
[
  [2, 6],
  [2, 2, 3],
  [3, 4]
]
```
示例 4:
```
输入: 32
输出:
[
  [2, 16],
  [2, 2, 8],
  [2, 2, 2, 4],
  [2, 2, 2, 2, 2],
  [2, 4, 4],
  [4, 8]
]
```

### 解法 DFS
虽然一看就知道用DFS，但具体怎么DFS，这题乍一看可能还有点难。

一开始我的思路是先求出输入数字的所有因子，然后将这些因子做组合。
这种做法很难的一个地方在于如何不重复地统计结果。另外求所有因子虽说有现成算法，但是真要自己写，也还是有点费脑。

看了眼答案后转换思路。
统计本身可以在求因子的过程中完成，且无需太优化，先暴力求解再说。

具体的，定义一个DFS函数`def dfs(num, part)`。这个函数递归地将n进行因数分解。
`num`表示尚未被分解的部分，而part表示分解到当前位置已经获得的一个部分结果。

函数体内的核心逻辑，是遍历所有可能的因子`for i in range(2, int(sqrt(num)) + 1)`。
碰到`num % i == 0`的情况，就进一步地探索`dfs(num // i, part + [i, ])`。
上述遍历结束后，别忘了将`part + [num,]`这个结果加入到最终结果集合中。

不过以上做法还存在一个问题，比如输入是60为例，
我们可能会探索到`dfs(10, [2,3])`这样一种情况，按照上述逻辑，下一个探索的将会是`dfs(5, [2,3,2])`，从而会把
`[2,3,2,5]`这个结果收割。
但问题是我们之前会已经收割了`[2,2,3,5]`，而这两种结果在这题中属于重复的结果。

为了保证不重复，我们需要保证每个结果的因子都是从小到大排序的。
为了保证这一点，我们需要限制遍历因子时的范围，即上下限。
上限`int(sqrt(n)) + 1`保证我们遍历的都处于`num`的前半区因子，而下限不能是2，应当是当前part结果中的最大值，或者说`part[-1]`。

换言之，上述逻辑只需要改动`range`中的下限，就可以获得正确结果。

最后别忘了一些小细节的处理，比如最上层的dfs时part是空的，因此需要一些特别处理避免报错。