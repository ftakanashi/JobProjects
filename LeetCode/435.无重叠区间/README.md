## 题目描述
给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意:

可以认为区间的终点总是大于它的起点。

区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

示例 1:
>输入: [ [1,2], [2,3], [3,4], [1,3] ]
>
>输出: 1
>
>解释: 移除 [1,3] 后，剩下的区间没有重叠。

示例 2:
>输入: [ [1,2], [1,2], [1,2] ]
>
>输出: 2
>
>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。

示例 3:
>输入: [ [1,2], [2,3] ]
>
>输出: 0
>
>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。


### 解法1 贪心
最先想到，如果问题只是判断有没有重叠区间，那么一个解法是先排序（左端点升序，长度升序）再依次扫描判重叠即可。

那么按照这种做法，单纯地，碰到新扫描到的一个区间，和已经扫描过的区间发生重叠时直接舍弃新扫描到的这个区间行不行？
乍一看没毛病，但是碰到如下例子就会gg
```text
[[1,5],[2,3],[3,4],[4,5]]
```
显然，按照上述算法被舍弃的是后三个区间而不是第一个区间。

因此修正想法，当发生重叠时，不是直接舍弃扫描到的新区间，而是比较新旧区间，取其中较短的那个，或者说是右端点较小的那个。

仔细想想这么做的根据也是有贪心思想在里面：尽可能为右边还没扫描过的区间保留空间。

实现上，由于已经经过排序，所以扫描过程中只关心已扫描过的区间中最靠右的区间，因此设置双指针指向这个区间并时刻更新即可。

### 解法2 DP
dp数组`dp[i]`表示，在已经排好序的区间序列中，到第`i`个（包括）为止，前面所有区间集合中，最多用几个区间可以形成一个互相不重叠的并集。

显然，`dp[0] = 1`

一般动态规划，某一个位置的dp值通过上一个位置以及状态转移方程可以得到。

但是在这题里，如果前一个区间和本区间有重叠，那么就不能用单纯的前一个区间的dp
值+1的办法来获得本区间的dp值。

换言之，我可能需要找到，之前所有区间中那些和本区间不形成重叠的，用他们的dp值+1来推算本区间的dp值。
如果找不到任何一个不重叠的前序区间，那么只能将本区间的dp值置为1，表示如果要用本区间，那么就只能就使用单个本区间，形成不重叠结果。

推算完所有dp值后，要注意也不是取用`dp[-1]`作为结果。因为要考虑可能最优结果中不包含最后一个区间。

所以应该取用`max(dp)`作为结果。

当然别忘了题目问的是要删除几个区间，所以最终返回值应该是`len(intervals) - max(dp)`。

注意，这个DP显然在状态更新的时候有两层循环，所以O(n^2)，耗时整体较长。