## 题目描述
给定四个整数 sx , sy ，tx 和 ty，如果通过一系列的转换可以从起点 (sx, sy) 到达终点 (tx, ty)，则返回 true，否则返回 false。

从点 (x, y) 可以转换到 (x, x+y)  或者 (x+y, y)。

示例 1:
```
输入: sx = 1, sy = 1, tx = 3, ty = 5
输出: true
解释:
可以通过以下一系列转换从起点转换到终点：
(1, 1) -> (1, 2)
(1, 2) -> (3, 2)
(3, 2) -> (3, 5)
```
示例 2:
```
输入: sx = 1, sy = 1, tx = 2, ty = 2 
输出: false
```
示例 3:
```
输入: sx = 1, sy = 1, tx = 1, ty = 1 
输出: true
```

提示:
```
1 <= sx, sy, tx, ty <= 10^9
```

### 解法 模拟 反向 辗转相除
这题乍一看好像不难，但是仔细一想还是有点难度的。也不愧为hard题了。

第一直觉，我们可以从`sx, sy`出发进行一次BFS，来找是否能够到达`tx, ty`。
但是显而易见的，探索范围很大，会很耗时。

这是就需要一个巧妙的思想，反向思维。
由于题目限制了所有出现的数字都是正整数，并且操作也只有加法。
因此我们知道在整个操作过程中，数字只会越来越大。反过来说，从终点向起点看，数字随着一次次逆向操作会越来越小。
而逆向操作并不是多分支的。

对于任意一个中间状态的`x, y`，假设其前序状态是`x', y'`。那么必然会有如下结论：
- 若`x > y`，则必然有`x = x' + y' 且 y == y'`
- 若`x < y`，则必然有`y = x' + y' 且 x == x'`
- 若`x == y`，则说明不存在前序状态`x', y'`，此时只需要看`x, y`和`sx, sy`的对等情况即可。

上述就是这种方法最核心的思想。
有了这个思想之后，我们只需要按部就班地从`tx, ty`向`sx, sy`逆向推导，看是否能够走到即可起点即可。
具体来说就是不断循环，判断当前`x`和`y`哪个大，用大的减去小的并将新值覆盖大的数字即可。
这其实也就是辗转相除的做法。可以证明最终两个数会收敛到两者相等。
在减小过程中可以随时判断`tx ty`与`sx, sy`的对等情况，而在最终相等后可以跳出循环，最后再判断对等情况来返回结果。

这么看来这题似乎水的一批，但是实际上实现后发现部分case超时了。比如`sx, sy, tx, ty = 1, 1, 1, 1000000`这样的例子。
显然，在这个例子中，`ty`始终大于`tx`，因此会有不断的`ty -= tx`的操作。
奈何两者之间相差太大，导致操作数过多复杂度过大，从而超时。

既然是纯数字操作，那么就将加法改为乘法，一次减掉能减的所有`tx`呢？即取余`ty = ty % tx`。
这样的做法会遇到另一个问题，比如例子`9, 10, 9, 19`。
这里，明明19减去一次9，就可以得到起点的数字对，但是由于应减尽减了，反倒过头了。
所以这里还需要更加精确的操控。

由于`ty`减过头会引起判断失误，而这个头从直觉上来说就是`sy`。
所以，这里我们将策略改成，将`ty`一次性减尽量多的`tx`，但是要保证减后`ty`仍然大于等于`sy`。
用代码来说就是`ty -= (ty - sy) // tx) * tx`。

但是上述策略仍然有问题。
当`ty`和`sy`的差距较小，小于`tx`的时候，上述等式右边始终是零。这也就会导致程序死循环。
遵从面向bug编程的原则，在加上一个兜底的1，最终这个式子变成了：
`ty -= max(1, (ty - sy) // tx) * tx`。

这样的逻辑终于可以过了。
虽然仔细思考一下就知道，这个逻辑并不优雅。
因为在`ty`不断减小的过程中，他可能会小于`sy`，但是仍然大于`tx`，此时`ty`只能一个一个`tx`地减少，很没有效率。
官方答案似乎更加优雅一些，用了一些略复杂的逻辑条件判定，有待日后研究。