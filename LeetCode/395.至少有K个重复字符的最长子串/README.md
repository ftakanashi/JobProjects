## 题目描述

找到给定字符串（由小写字符组成）中的最长子串 T ， 要求 T 中的每一字符出现次数都不少于 k 。输出 T 的长度。

示例 1:
```
输入:
s = "aaabb", k = 3

输出:
3

最长子串为 "aaa" ，其中 'a' 重复了 3 次。
```
示例 2:
```
输入:
s = "ababbc", k = 2

输出:
5

最长子串为 "ababb" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。
```

### 解法1 非朴素的滑动窗口
>直接用朴素的滑窗思想做比较困难，但是可以人为追加一些限制条件，将问题化成有限个小问题。
>
>每个小问题用滑窗思想做，最后综合所有小问题结果得到最终结果。

这题乍一看显然用滑窗做。
但是仔细想其实没那么简单。滑窗最最核心的，左右指针移动的条件没那么好想。

答案给出的方案是这样的：
直接整个解决这个问题有点困难。我们给这个问题添加一点限制。

限制就是，给出一个最多的字符种类`type_num`。比如3。这就表示，我们去找最长的子串，使得这个子串满足两个条件，
第一，就是题目给出的条件，每个字符至少出现K次。
第二是我们追加的，字符种类是3个。即`len(set(T)) = 3`。

因为题目说字符全是小写字母，所以这个`type_num`的取值范围就是`range(1, 27)`。
此外如果`type_num * k > len(s)`，那么显然就没必要继续向上遍历`type_num`。

而这个小问题又该怎么解决？
显然可以滑窗，设立一个counter计数窗口内字母。只要counter本身的length等于`type_num`且
计数的最小值大于等于`k`就记录结果并右指针移动。

当counter的length大于`type_num`时就左指针移动。

右指针移动条件还有一个优化点。`min(counter.values()) > k`这个操作还是要线性扫描整个counter。
其实可以在counter之外额外维护一个`save_count`。每当某个字符的计数值到达k之后这个`save_count += 1`。
相反，左指针移动，每一个字符掉出窗口时，计数如果是`k`，此时计数减一，相应的`save_count -= 1`。

### 解法2 递归分治
上面的滑窗真是烦。
其实这题有个更加巧妙的办法。

注意到，对于字符串s，如果事先遍历一遍，知道哪些字符的计数没有到达k，那么这些字符肯定不能被答案的子串包含。

因此可以基于这个字符将源字符串分割成若干个子字符串。
这些子字符串都是潜在的最终答案。那么到底是不是呢，递归地去检查这些子字符串即可。

借助python的collection.Counter以及split函数可以很方便地写出代码。