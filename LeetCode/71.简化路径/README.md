## 题目描述
以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。

在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；

两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径

请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。

此外，规范路径必须是表示绝对路径的最短字符串。 

示例 1：
>输入："/home/"
>
>输出："/home"
>
>解释：注意，最后一个目录名后面没有斜杠。

示例 2：
>输入："/../"
>
>输出："/"
>
>解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。

示例 3：
>输入："/home//foo/"
>
>输出："/home/foo"
>
>解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。

示例 4：
>输入："/a/./b/../../c/"
>
>输出："/c"

示例 5：
>输入："/a/../../b/../c//.//"
>
>输出："/c"

示例 6：
>输入："/a//b////c/d//././/.."
>
>输出："/a/b/c"

### 解法 分步处理
总结一下需要处理的特殊情况是，
- 多个`/`重叠
- 当前目录的`.`
- 上一级目录的`..`
- 上级目录不能突破根目录
- 最后不能带`/`

显然最后一个不是什么大问题。同时第一个可以通过`re.sub`轻松解决。

第一个如果能得到解决，那么剩余就不难了。
剩下的就是由有效层级目录以及两种特殊目录`.`和`..`，由`/`join出来的字符串而已。

由于从左到右扫描过程中，后面出现的`..`会影响前面的目录的有效性，因此很明显可以用栈来扫描。

即，对于被`/`join起来的字符串，先split掉，然后扫描各个目录名。如果是一般目录则入栈，如果是`.`则无视，如果是`..`则pop出栈顶。
注意栈为空时不pop任何东西，这样第四点也得到了解决。

实际上针对第一个操作，不用`re.sub`预处理，用栈也能解决，只要加个新元素和栈顶都是`/`时抛弃新元素之类的判断即可。