## 题目描述
用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。

箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。

将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。

将球导向左侧的挡板跨过右上角和左下角，在网格中用 -1 表示。

在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 "V" 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。

返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。

示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/26/ball.jpg)
```
输入：grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]
输出：[1,-1,-1,-1,-1]
解释：示例如图：
b0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。
b1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 "V" 形里。
b2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 "V" 形里。
b3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 "V" 形里。
b4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 "V" 形里。
```
示例 2：
```
输入：grid = [[-1]]
输出：[-1]
解释：球被卡在箱子左侧边上。
```
示例 3：
```
输入：grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]
输出：[0,1,2,3,4,-1]
```

提示：
```
m == grid.length
n == grid[i].length
1 <= m, n <= 100
grid[i][j] 为 1 或 -1
```

### 解法 DFS 模拟
这道题其实倒也不难。

最开始的时候，下意识地用了并查集做。但是写到一半发现并查集是行不通的，因为题目是需要考虑重力的。
比如如果将示例1中的第一行去掉，然后从`0,4`位置放下一个球，在重力的影响下，求会停留在`2,3`和`2,4`交界的V字形处。
尽管这个格子与最底部的出口是相通的，但是球并走不过去。

看了眼数据规模也不是很大，就像能不能暴力模拟。然后发现可行。

具体来说，当球来到某个格子时，可以根据格子的挡板方向决定其下一步行动，直到求进入V字形或者到达底部出口。

在分析过程中发现了一个比较有意思的点。
球进入的，实质上是一个直角三角形的半个格子。而由于有两个方向的挡板，所以这类半个格子总共有四种。
然而四种中，只有包含了格子顶边的两种是具有参考价值的。

因为当求进入到包含格子底边的那些半格时，球接着就是做一个简单的自由落体运动，进入下一行而已，根本无需进行逻辑判断。
因此，在DFS过程中，我们只需判断当前格子的挡板方向。

若当前格子`x,y`的挡板是1型，即左上右下的，那么只要该格子右边不是墙或者一个-1型的，
那么球就可以直接进入`x+1,y+1`，而不用经过`x,y+1`这个中间步骤。
同理，`x,y`是-1型时，只要其左边不是墙或者1型的，就可以进入`x-1,y+1`。

递归出口当然是`x == m`了。

以上。