## 题目描述
在 LeetCode 商店中， 有 n 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。

给你一个整数数组 price 表示物品价格，其中 price[i] 是第 i 件物品的价格。另有一个整数数组 needs 表示购物清单，其中 needs[i] 是需要购买第 i 件物品的数量。

还有一个数组 special 表示大礼包，special[i] 的长度为 n + 1 ，其中 special[i][j] 表示第 i 个大礼包中内含第 j 件物品的数量，且 special[i][n] （也就是数组中的最后一个整数）为第 i 个大礼包的价格。

返回 确切 满足购物清单所需花费的最低价格，你可以充分利用大礼包的优惠活动。你不能购买超出购物清单指定数量的物品，即使那样会降低整体价格。任意大礼包可无限次购买。

示例 1：
```
输入：price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]
输出：14
解释：有 A 和 B 两种物品，价格分别为 ¥2 和 ¥5 。 
大礼包 1 ，你可以以 ¥5 的价格购买 3A 和 0B 。 
大礼包 2 ，你可以以 ¥10 的价格购买 1A 和 2B 。 
需要购买 3 个 A 和 2 个 B ， 所以付 ¥10 购买 1A 和 2B（大礼包 2），以及 ¥4 购买 2A 。
```
示例 2：
```
输入：price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]
输出：11
解释：A ，B ，C 的价格分别为 ¥2 ，¥3 ，¥4 。
可以用 ¥4 购买 1A 和 1B ，也可以用 ¥9 购买 2A ，2B 和 1C 。 
需要买 1A ，2B 和 1C ，所以付 ¥4 买 1A 和 1B（大礼包 1），以及 ¥3 购买 1B ， ¥4 购买 1C 。 
不可以购买超出待购清单的物品，尽管购买大礼包 2 更加便宜。
```

提示：
```
n == price.length
n == needs.length
1 <= n <= 6
0 <= price[i] <= 10
0 <= needs[i] <= 10
1 <= special.length <= 100
special[i].length == n + 1
0 <= special[i][j] <= 50
```

### 解法 记忆化DFS
题目有点长。整理一下题意：
有`n`个商品，原价由长度为`n`的数组`price`表示。
完了还有一些礼包package，这些package的集合由`special`数组表示。每个package长度是`n+1`，其中`[:-1]`表示package中有各个商品的数量，
而`[-1]`表示这个package本身的价格。

现在给出一个长度为`n`的数组`needs`表示要购买的目标数量，求最少能够买齐needs的价格。

这之中，所有的原价物品单品和package的数量都是可无限次购买的。
但是另一方面，要求任何商品最终购买后的不能超过`needs`中规定的数量。

首先一个比较容易想到的预处理，是去除掉special中一些不合算的package。
显然，当package中包含的商品的单品总价小于等于package本身价格时，就没必要买package了。

另一方面，其实就是一个选择哪个package，或者一个都不买全买单品的情况。
此时可以使用DFS暴力搜索。

具体的，构建dfs函数，参数接受一个rest元组（构建元组是为了加记忆化方便）表示当前情况还需要购买哪些商品各几个。
定义函数的返回为买齐`rest`需要的最少的钱。
显然，当`sum(rest) == 0`时，已经无需购买，此时直接返回0即可。

函数主体，首先需要设定一个基准的当前最低价，也就是当前needs如果完全不买package只买单品会花多少钱，这是可以计算出来的。
接着就是买package的情况，依次尝试买下各个package。当某个package中某些商品数量超过当前needs需求时，根据要求会超限所以不能买。
否则就可以从rest中减去相应数量，然后进行下一层递归。

注释写在代码里了。

这里多说一句，说实话第一次看到这题，以为是用背包做，但是想了一下感觉没啥好的具体方案，就没继续想看答案了。
但是答案中也有不少人提到可以用背包或者说DP的思路做。这里就不多写了。