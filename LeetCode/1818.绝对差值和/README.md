## 题目描述
给你两个正整数数组 nums1 和 nums2 ，数组的长度都是 n 。

数组 nums1 和 nums2 的 绝对差值和 定义为所有 |nums1[i] - nums2[i]|（0 <= i < n）的 总和（下标从 0 开始）。

你可以选用 nums1 中的 任意一个 元素来替换 nums1 中的 至多 一个元素，以 最小化 绝对差值和。

在替换数组 nums1 中最多一个元素 之后 ，返回最小绝对差值和。因为答案可能很大，所以需要对 109 + 7 取余 后返回。

|x| 定义为：
- 如果 x >= 0 ，值为 x ，或者
- 如果 x <= 0 ，值为 -x

示例 1：
```
输入：nums1 = [1,7,5], nums2 = [2,3,5]
输出：3
解释：有两种可能的最优方案：
- 将第二个元素替换为第一个元素：[1,7,5] => [1,1,5] ，或者
- 将第二个元素替换为第三个元素：[1,7,5] => [1,5,5]
两种方案的绝对差值和都是 |1-2| + (|1-3| 或者 |5-3|) + |5-5| = 3
```
示例 2：
```
输入：nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]
输出：0
解释：nums1 和 nums2 相等，所以不用替换元素。绝对差值和为 0
```
示例 3：
```
输入：nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]
输出：20
解释：将第一个元素替换为第二个元素：[1,10,4,4,2,7] => [10,10,4,4,2,7]
绝对差值和为 |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20
```

提示：
```
n == nums1.length
n == nums2.length
1 <= n <= 10^5
1 <= nums1[i], nums2[i] <= 10^5
```

### 解法 排序 + 二分查找
读了一遍题之后，第一个想到的方案是这样的：

既然要求最终的绝对值的和最小且只能替换一次，那么很自然就想到把绝对值最大的那对数字中num1里的那个给替换掉。
接下来就是替换成什么的问题，显然要替换成尽量接近nums2中对应数的那个，于是就要将nums1排序，再二分查找，找到最接近的数。

顺便一提，用二分查找找最接近的数的步骤是，先查找到某个下标，看其是否等于target，若等于，那最接近的数就是相同的数。否则，就需要检查
当前这个下标与前一个下标（假设用的`bisect.bisect_left`查找）的情况。当然还要考虑是否越界。

但是这样够了吗？想了一会儿想到一个反例：
```text
5 102 101
1 100 101
```
这两组数，最大的差出现在5和1之间，是4。而在nums1中查找与1最接近的数，是5，意思是不需要做替换。可是实际上，我可以将第二个102换成101，
这样可以让总的差的绝对值减少1。
换言之，上述贪心思想：找到差绝对值最大的对，是错误的。

既然如此，我们就只能老老实实扫描所有对`n1, n2`，统计："如果将n1替换成nums1中n2最接近的数可以带来的贡献是多少？"。
这里，"贡献"是指通过替换，可以将原有 差的绝对值 减小的量。

比如上面那个例子，5和1来说，本来就不替换，因为5就是nums1中最接近1的数。
102和100，将102替换成101，带来的贡献是`abs(102-100) - abs(101-100)`。
101和101也不需要替换。

扫描所有对，实时维护最大的贡献值，最后只要将原有的差的绝对值的和，减去最终得到的全局最大贡献值，就是答案了。

实现的细节上：
因为涉及到二分查找的同时还需要维护原来的`n1,n2`对，因此排序后的nums1只能单独再设立一个数组保存。
另外，统计贡献和计算差的绝对值的和两个操作互相独立，因此可以一次扫描就搞定。