## 题目描述
给你一个长度为 n 的整数数组 nums ，和一个长度为 m 的整数数组 queries 。

返回一个长度为 m 的数组 answer ，其中 answer[i] 是 nums 中 元素之和小于等于 queries[i] 的 子序列 的 最大 长度  。

子序列 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。

示例 1：
```
输入：nums = [4,5,2,1], queries = [3,10,21]
输出：[2,3,4]
解释：queries 对应的 answer 如下：
- 子序列 [2,1] 的和小于或等于 3 。可以证明满足题目要求的子序列的最大长度是 2 ，所以 answer[0] = 2 。
- 子序列 [4,5,1] 的和小于或等于 10 。可以证明满足题目要求的子序列的最大长度是 3 ，所以 answer[1] = 3 。
- 子序列 [4,5,2,1] 的和小于或等于 21 。可以证明满足题目要求的子序列的最大长度是 4 ，所以 answer[2] = 4 。
```
示例 2：
```
输入：nums = [2,3,4,5], queries = [1]
输出：[0]
解释：空子序列是唯一一个满足元素和小于或等于 1 的子序列，所以 answer[0] = 0 。
```

提示：
```
n == nums.length
m == queries.length
1 <= n, m <= 1000
1 <= nums[i], queries[i] <= 106
```

### 解法 前缀和 二分查找
首先应当意识到，`queries`数组是一个假象，实际上其中每个元素都是一个独立的query，因此大的框架肯定是对`queries`做一个循环求解。

另外不要被子序列三个字骗了。 虽然这题要思考的是子序列，但是只需要关注子序列的和。
而子序列的和，实际上就是一个数组中可以拿掉一部分数字凑出来的任意的和。

因此，这道题实际上变成了，给定一些数字，然后给定一个`query`值。让你求从数字中最多可以拿出多少个数字，其和是小于等于`query`的。

很明显，只需要对数字做排序然后从小到大取即可。
由于有多个`query`，每次都重新加一遍不太明智，所以可以预处理出一个已排序数组的前缀和数组，然后在前缀和数组中找`query`值的位置即可。

比如示例1中`nums = [4, 5, 1, 2]`，排序并前缀和数组，去掉最前面的0后得到`[1, 3, 7, 12]`。
于是很显然，`query`分别是`[3, 10, 21]`的时候，二分（`bisect.bisect`的返回）的下标分别是`[2, 3, 4]`。这也就是答案。