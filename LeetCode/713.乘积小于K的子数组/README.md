## 题目描述
给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。

示例 1：
```
输入：nums = [10,5,2,6], k = 100
输出：8
解释：8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。
```
示例 2：
```
输入：nums = [1,2,3], k = 0
输出：0
```

提示:
```
1 <= nums.length <= 3 * 104
1 <= nums[i] <= 1000
0 <= k <= 106
```

### 解法 滑动窗口
这题一看就知道得用前缀和或者滑窗哪个技巧来做。
仔细看一番后觉得还是得用滑窗。

然而滑窗的框架好搭，问题在于有了滑窗之后在哪里以什么方式收割结果。

当确定一个窗口内的所有数的乘积严格小于k时，设窗口长度为`n`，显然我们可以从中提取出`n + n-1 + n-2 + ... + 1`个符合要求的子数组。
但是如果真的这样计算就会有另一个问题。
比如示例1中，对于`10, 5`这个窗口，我们可以计入`[10,] , [5,] , [10, 5]`这样三个子数组。
但是窗口移动一格后，对于`5, 2`这个窗口，`[5,]`会被重复计数。

为了避免重复计数，需要对计数规则做一定限制。
具体来说，由于是从左到右扫描的，针对每个具体的窗口，左边界可能会在之前的扫描中被计数过。
那么就以右边界为基准。

即，针对下标为`i, j`的窗口，固定`j`，看`i`最小能取到多少，于是我们就可以知道一共有多少个右边界是`j`的子数组符合要求。
而对于那些右边界在`i,j`之间的，这些在之前的扫描中就已经统计过了，这样就不会重复计数。
也就说针对`i,j`这个窗口，需要`ans += (j - i + 1)`。

另外还需要注意的一个细节是，当`i==j`的时候，此时相当于是一个单个数字的子数组。
此时不能无脑加上`j - i + 1`，因为此时还需要看`nums[j]`和`k`之间的大小关系。
比如示例2就是一个很好的说明这个问题的例子。

在综合考虑以上限制后，套入经典的滑窗模板即可。
因为有段日子没写过滑窗了，所以模板的一些重点我写在了代码的注释里。