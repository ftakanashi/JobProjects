## 题目描述
存在一个由 n 个节点组成的无向连通图，图中的节点按从 0 到 n - 1 编号。

给你一个数组 graph 表示这个图。其中，graph[i] 是一个列表，由所有与节点 i 直接相连的节点组成。

返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。

示例 1：

![](https://assets.leetcode.com/uploads/2021/05/12/shortest1-graph.jpg)
```
输入：graph = [[1,2,3],[0],[0],[0]]
输出：4
解释：一种可能的路径为 [1,0,2,0,3]
```
示例 2：

![](https://assets.leetcode.com/uploads/2021/05/12/shortest2-graph.jpg)
```
输入：graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]
输出：4
解释：一种可能的路径为 [0,1,4,2,3]
```

提示：
```
n == graph.length
1 <= n <= 12
0 <= graph[i].length < n
graph[i] 不包含 i
如果 graph[a] 包含 b ，那么 graph[b] 也包含 a
输入的图总是连通图
```

### 解法1 多源BFS
因为是求图中的某个最短路径，所以想到用BFS。
此外因为没有规定起点是哪儿，而且求的是全局的最小值，所以可以在队列中初始化所有节点作为出发点，即多源BFS。
常规思路的BFS，队列中每个元素是节点以及到达该节点的距离值。另外为了避免重复探索，需要额外安排一个哈希集保存已经经过过的节点。

而这题不同之处就在于，允许了重复途径一个节点。这就有点僵硬了。

实际上，需要意识到这样一个点：
我们使用哈希集保存已经访问过的节点，根本的目的是为了避免循环探索。即之前从某个节点出发的探索，不能第二次再从这个节点出发，否则迟早有一天会
第三次来到这个节点，周而复始。
而"从某个节点出发"这件事，在所有节点只能访问一次的前提下，是系统的"状态"。

不拘泥与保存访问过的节点，而是想到保存访问过的"状态"，则这题就很好做了。

因为允许节点的重复访问，所以单纯的一个节点已经无法代表此题中系统的状态，
拔高一点视角我们可以知道，这题的状态应该是"当前所在节点以及已经访问过的节点的组合"。
换言之，只要哈希集保存的是`(node, visited)`，那么就可以避免重复访问。

意识到了这点，这题就不难了。

再一个优化点，由于n最大也只有12，所以可以使用位图法而不是哈希集来表示visited这个变量，同时也避免了哈希集的copy。

具体的，队列中保存`(node, mask, dist)`元组。初始化所有节点进队列，对节点`i`进队列的东西是`(i, 1<<i, 0)`。
然后开始BFS，并维护`(node, mask)`这类元组进seen。
当pop出的`node, mask`已经处于seen中，那么无需以此为起点再次搜索，否则就会循环搜索。

而对于下一批节点`graph[node]`，入队`(nxt, mask | (1 << nxt), dist + 1)`即可。

当某次pop出来发现`mask`值等于`(1 << n) - 1`，即n个1时，说明所有节点都已经到访过。可以直接返回dist。

综上，这题主要需要意识到的点包括了
- 最短路径用BFS
- 未明确起点的全局最短路径，多源BFS
- 节点可重复访问，所以用`node, mask`元组标识避免循环探索