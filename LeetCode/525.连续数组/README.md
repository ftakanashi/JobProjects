## 题目描述
给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。

示例 1:
```
输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量0和1的最长连续子数组。
```
示例 2:
```
输入: nums = [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。
```

提示：
```
1 <= nums.length <= 105
nums[i] 不是 0 就是 1
```

### 解法 前缀和 + 哈希
由于在扫描过程中，不知道后面会出现什么，所以很难用DP或者滑窗之类的办法做。

另一方面，其实这道题和`LC.523`很像。
在那道题里，判断条件是子数组 的和是否能被k整除。首先，子数组的性质，想到了用前缀和。其次为了避免O(n^2)的计算，
将前缀和对k的余数保存在哈希表中。

而这题也是类似的。
第一时间或许可以想到使用一个二元组保存每个位置的"前缀和"，即到此位置为止，前面所有0和1的计数。
显然当这个二元组`(x, y)`能够找到前面的某个二元组`(a, b)`，使`x - a == y - b`即可。
而类比上面的思路，这个条件其实可以等价变换成`x - y == a - b`，即二元组两个元素的差。
此时就将这个条件转化为一个"前缀和"内部的性质，因此可以像`LC.523`的思路那样做了。

具体的，初始化哈希表为`{0: -1}`。
然后扫描数组并维护一个0的计数减去1的计数的差值，其初始值当然是0。
每扫描到一个0时，差值+1，否则差值-1。
然后检查新差值是否在之前出现过，如果是，则记录此时观测到的最大子数组长度；否则将新差值和下标的对应存入哈希。

以上，只扫描一遍数组即可。
时间和空间都用了O(n)。