## 题目描述

给你一个按升序排序的整数数组 num（可能包含重复数字），

请你将它们分割成一个或多个子序列，其中每个子序列都由连续整数组成且长度至少为 3 。

如果可以完成上述分割，则返回 true ；否则，返回 false 。

示例 1：
>输入: [1,2,3,3,4,5]
>
>输出: True
>
>解释:
>
>你可以分割出这样两个连续子序列 : 
>
>1, 2, 3
>
>3, 4, 5
 

示例 2：
>输入: [1,2,3,3,4,4,5,5]
>
>输出: True
>
>解释:
>
>你可以分割出这样两个连续子序列 : 
>
>1, 2, 3, 4, 5
>
>3, 4, 5

示例 3：
>输入: [1,2,3,4,4,5]
>
>输出: False


### 解法 模拟
显然，存在一个"子序列池"，当我拿到一个数的时候，优先应该考虑，能否将这个数append到某个子序列后面，即是否存在
某个子序列的最后一个数是n-1。

如果没有，那么就只能新建一个子序列并将其入池。

如果有，且有多个，那么如何选择是个问题。显然，为了尽量避免出现短的子序列，可以选择候选子序列中最短的那个进行append。

当所有数都处理完毕，扫描整个子序列池，看是否所有的子序列都满足要求，即长度>=3。

以上就是最基本简单的模拟思路了。但是，这个模拟还存在很多问题。下面一步步来优化。

首先，每次拿到新数都要扫描一遍子序列查看其末尾数是不是n-1。这个操作太费事了。
可以用一个哈希表，时刻维护每个子序列末尾数与其的对应。这样就可以O(1)时间定位到候选子序列。
这里要注意，显然当append操作完成后，这个子序列的末尾数就变了，也要相应地在哈希表里做增减工作。
比如：
```text
mp = {1: [[1,]], 2: [[1,2], [2,]]}
```

其次，对每个子序列，我们只关注其末尾值和长度，事实上有相当一部分空间被浪费了。所以完全可以抽象化子序列。
哈希表中维护的，可以是子序列末尾数和子序列长度之间的关系。
比如：
```text
mp = {1: [1], 2: [2, 1]}
```

最后，当候选子序列有多个时，我们要扫描所有候选子序列找到最短的那个。
既然总是找最短的那个，那么候选子序列的信息可以用堆的形式来构建。这样只要pop一下就能获取到最短的那个长度。
针对大小为m的候选子序列集合，操作可以从O(m)降低到O(logm)。
最终变成：
```text
mp = {1: heap(1), 2: heap(1, 2)}
```