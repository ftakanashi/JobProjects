## 题目描述
编写一个程序，找到两个单链表相交的起始节点。

示例 1：
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png)
```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```
 

注意：
- 如果两个链表没有交点，返回 null.
- 在返回结果后，两个链表仍须保持原有的结构。
- 可假定整个链表结构中没有循环。
- 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。


### 解法1 哈希set
直观解法。

先把链表A全扫一遍，碰到的节点全部都入哈希集。

接着再扫一遍链表B，碰到的第一个已经存在于哈希集的结果就是答案。
如果全程没有就返回None

代码很简单就不写了。

### 解法2 双指针
和`LC142.环形链表II`类似的，让两个指针同时在链表中动，有时会有一些奇妙的性质。

这道题，我让i,j两个指针同时从A,B两个链表的头出发，分别向后遍历。
当然，除非A和B非公用部分同长，否则两个指针会一前一后到达终点。

反过来说，两者不能同时到达终点就是因为非公用部分两个链表不同长。
比如上面图中，i先于j到达终点，因为在非公用部分他少走了一步。

既然如此，我让i再走一遍B的非公用部分，j再走一遍A的非公用部分，这样的结果就是
i和j可以在相交点相遇。

再说一遍算法，i,j同时从A，B的head出发。到达终点时i回到B的起点，j回到A的起点继续让他们走。
当他们相遇时，相遇的节点就是相交点。

以上算法还有一个小问题，当两个链表没有交点的时候该怎么办。
注意到，即使没有交点，我还是让两个指针按照上述方法操作的话，他们最终会同时到达彼此的末尾。
而只要有交点，两个指针势必不会同时到达末尾。

因此可以基于i和j是不是同时是None来判断究竟是重置到头还是链表本身就没有交点。