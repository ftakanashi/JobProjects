## 题目描述
给你一个整数数组 nums，返回 nums 中最长等差子序列的长度。

回想一下，nums 的子序列是一个列表 `nums[i1], nums[i2], ..., nums[ik]` ，且 0 <= i1 < i2 < ... < ik <= nums.length - 1。并且如果 seq[i+1] - seq[i]( 0 <= i < seq.length - 1) 的值都相同，那么序列 seq 是等差的。

示例 1：
```
输入：nums = [3,6,9,12]
输出：4
解释： 
整个数组是公差为 3 的等差数列。
```
示例 2：
```
输入：nums = [9,4,7,2,10]
输出：3
解释：
最长的等差子序列是 [4,7,10]。
```
示例 3：
```
输入：nums = [20,1,15,3,10,5,8]
输出：4
解释：
最长的等差子序列是 [20,15,10,5]。
```

提示：
```
2 <= nums.length <= 1000
0 <= nums[i] <= 500
```

### 解法 DP
注意，求的是形成等差数列的子序列，而不是子数组。

第一时间想到了用DP，但是仔细一想似乎不太好做，因为对于一个位置`i`，必然是要扫描前面的所有`j`的。
而扫描`j`的过程中，对于特定的`j`，虽然`i`和`j`可以确定一个等差数列（的差）。那么又该如何确认`j`前面是否有合法的同样差的前置项呢。

不过好在数据最大就500，所以这里就可以发挥DP的降低不确定性的特点，加维度…

我们可以先遍历一次nums，获取到其中的最大值和最小值，令`diff = max_v - min_v`。
而在这样一个数组中寻找等差数列，最大和最小差值分别就是`-diff`和`diff`了。

然后构建一个`n * (diff * 2)`的DP数组，其中`dp[i][d]`表示前`i`项数字公差为`d`的等差数列的最大长度。
显然，对于`nums[i]`，可以扫描所有`nums[j], j < i`，令`d = nums[i] - nums[j]`，然后`dp[i][d] = dp[j][d] + 1`就行了。

由于任意两个数都可以形成一个等差数列，所以就这点来讲，dp中的所有初始值都应该是1。

此外，题目并没有要求原数组的最后一项要在答案中，所以最终要返回二维数组中全局的最大值，即`max(max(dp[i][d] for d in range))`。

在实际的代码实现中，我并没有真的用二维数组，而是用了默认值为1的defaultdict作为数据的承载。这样其实可以使用范围更广的情况，即数组中的最大最小值
差很大也不会发生DP数组空间爆炸的情况。
看代码。