## 题目描述
在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。

对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是 安全 的。

返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。

该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph 的节点数。图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i, j) 是图的一条有向边。

示例 1：

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png)
```
输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]]
输出：[2,4,5,6]
解释：示意图如上。
```
示例 2：
```
输入：graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
输出：[4]
```

提示：
```
n == graph.length
1 <= n <= 104
0 <= graph[i].length <= n
graph[i] 按严格递增顺序排列。
图中可能包含自环。
图中边的数目在范围 [1, 4 * 104] 内。
```

### 审题
注意题目的要求是"从某个节点出发，无论走哪条边，都可以在有限步内达到安全节点"。

换言之，只要有一条出边联想了不安全的节点，那么这个节点本身也不安全了。

那么哪些节点才是不安全的节点呢？
很简单，在环中的那些节点都是不安全的。

虽然没有严格证明，但是脑补一下可以发现，只要图中没有环，所有节点都会是安全的。

于是这题就变成了这样一个问题：定位有向图中成环的所有节点以及那些有出边连向环内节点的节点。

### 解法1 DFS（基于拓扑排序思想，即三色标记法
将节点标记为三类：第一，尚未遍历；第二已经开始遍历但未完成；第三，已经完成遍历。

设计一个dfs函数`dfs(node)`表示节点node是否是安全的，返回一个布尔值。
显然，可以用三色标记进行探索。对于下一层探索，只要有一个后续节点返回了False，本节点也返回False。

另外，由于一个节点是否安全是确定的值，所以可以给这个dfs加上记忆以优化速度。

### 解法2 BFS GC算法
另一种奇思妙想，也是Python等进行自动化GC时，解决循环引用问题的那个算法！

我们先将图的所有边都反转，得到一个逆图。这个逆图具有这样一个性质：原图中的安全节点，在逆图中，都是出度为0的节点。
同时，那些原图中连向的所有节点都是安全的节点也是安全的，在逆图中就变成了，所有入边的源头是安全节点的节点是安全的。

于是有这么一种解法：
我从逆图的所有入度为0的节点出发进行BFS扫描，这些节点在最开始就是安全的。
接着，每扫描到一个新节点时，将新节点的入度-1。若-1后新节点的入度为0，那么可以确定这个节点的所有入边对应的源头都是安全节点。
（因为能入BFS队列的节点必然是安全节点）
所以我们将这些入度归零的节点也加入队列。继续扫描。

等到BFS完成，再次扫描全图节点，把那些入度归零的节点挨个统计出来即可。

注意到，这其实就是Python的自动GC机制中标记-清除法的标记阶段的前期工作。
这题中每个节点的入边可以看做是对某个对象的引用计数，出边则是对象对其他对象的引用。
按照上述算法，遍历图的过程中，来到一个节点后将所有其引用的对象的入度（即引用计数）-1。
遍历完后将所有入度已经归零的对象，归入不可达链表。

当然，GC的标记-清除中上述算法只是标记阶段的前半部分，后半还需要从入度尚未归零的对象出发扫描图，把能够到达的节点
重新拉回可达链表中。

顺便一提，清除也就是直接将不可达链表中的对象全部垃圾回收了。