## 题目描述
给你一个长度为 n 的 3 跑道道路 ，它总共包含 n + 1 个 点 ，编号为 0 到 n 。一只青蛙从 0 号点第二条跑道 出发 ，它想要跳到点 n 处。然而道路上可能有一些障碍。

给你一个长度为 n + 1 的数组 obstacles ，其中 obstacles[i] （取值范围从 0 到 3）表示在点 i 处的 obstacles[i] 跑道上有一个障碍。如果 obstacles[i] == 0 ，那么点 i 处没有障碍。任何一个点的三条跑道中 最多有一个 障碍。

比方说，如果 obstacles[2] == 1 ，那么说明在点 2 处跑道 1 有障碍。
这只青蛙从点 i 跳到点 i + 1 且跑道不变的前提是点 i + 1 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 同一个 点处 侧跳 到 另外一条 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。

比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。
这只青蛙从点 0 处跑道 2 出发，并想到达点 n 处的 任一跑道 ，请你返回 最少侧跳次数 。

注意：点 0 处和点 n 处的任一跑道都不会有障碍。

示例 1：

![](https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex1.png)
```
输入：obstacles = [0,1,2,3,0]
输出：2 
解释：最优方案如上图箭头所示。总共有 2 次侧跳（红色箭头）。
注意，这只青蛙只有当侧跳时才可以跳过障碍（如上图点 2 处所示）。
```
示例 2：

![](https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex2.png)
```
输入：obstacles = [0,1,1,3,3,0]
输出：0
解释：跑道 2 没有任何障碍，所以不需要任何侧跳。
```
示例 3：

![](https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex3.png)
```
输入：obstacles = [0,2,1,0,3,0]
输出：2
解释：最优方案如上图所示。总共有 2 次侧跳。
```

提示：
```
obstacles.length == n + 1
1 <= n <= 5 * 105
0 <= obstacles[i] <= 3
obstacles[0] == obstacles[n] == 0
```

### 解法 DP 状态压缩
题目不是特别难，可以看出来要用DP。稍微有点绕的是DP的状态转移方程如何定义。

为了叙述方便，我们将题目中的1、2、3号跑道定义为0，1，2号跑道。
初步的想法，我们可以设立一个大小为`n * 3`的二维DP数组，其中`dp[i][j]`表示青蛙跳到下标`i`距离的`j`号跑道处所需要的最少侧跳次数。

显然，`dp[0] = [1, 0, 1]`。

一般的，对于`dp[i][j]`来说，要走到这个点，有几种不同的走法。

第一种，从`dp[i-1][j]`直接前进一步。这种走法可以直接让`dp[i][j] = dp[i-1][j]`，但是有个前提条件是`obstacles[i-1] - 1 != j`。
即前一个位置的`j`处不能是障碍物，否则无法走到`dp[i-1][j]`。

第二种， 从`dp[i-1][o]`（`o`表示012中除了`j`的另外两个下标）前进一步然后进行一次侧跳。
显然此时，`dp[i][j] = dp[i-1][o] + 1`。不过这种走法也有一个限制，就是`obstacles[i] - 1 != o`，即当前位置的`o`不能是障碍物。

最后，以上情况其实没有考虑当前位置的`j`本身是障碍物的情况，为了逻辑上统一，如果是障碍物，建议最后将`dp[i][j]`置为无穷大。

按照以上的状态转移规则进行代码编写即可。
另外不难发现，上面所有状态转移过程，实际上最早的也都只用到了`dp[i-1]`的信息，因此可以放弃二维数组，只用两个长度为3的一位数组即可。

有一个比较奇怪的是代码写出来后发现效率很低，但是复杂度和官方代码是一样的…
看来有比较大的可以优化的地方，不过我懒得看了。