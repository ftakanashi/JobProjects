## 题目描述
给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。

整数除法仅保留整数部分。

 

示例 1：
```
输入：s = "3+2*2"
输出：7
```
示例 2：
```
输入：s = " 3/2 "
输出：1
```
示例 3：
```
输入：s = " 3+5 / 2 "
输出：5
```

提示：
```
1 <= s.length <= 3 * 105
s 由整数和算符 ('+', '-', '*', '/') 组成，中间由一些空格隔开
s 表示一个 有效表达式
表达式中的所有整数都是非负整数，且在范围 [0, 231 - 1] 内
题目数据保证答案是一个 32-bit 整数
```

### 解法 栈
题目还是比较温柔的，输入的字符串只有数字，空格和加减乘除四个符号，且不带括号。

计算器模拟类题目大多可以用栈来做。这题很明显的数字可以累积扫描然后形成一个int数入栈。

只是问题在于，对于一个子算式比如`a + b`，我必须扫描到b的最后一位才能得到完整信息。
此时a恰好是栈顶，问题不大，而中间的符号是加号，该如何保存这个信息。

一个很直接的想法当然就是，设置一个prev变量保存这个加号，当b扫描完之后查看这个变量，发现是加号，于是做加法运算。

接下来考虑真正的难点，乘除法的优先级问题。
比如`a + b * c`这个式子，按照上述描述，当扫描完b之后，prev是加号，栈顶是a。如果后面没东西了直接计算a+b是合理的。
但是问题是后面乘以了c。

这导致不能直接做加法。这里就有了最关键的想法：
- 对于乘除法，由于题目输入没有括号，其优先级总是大于加减法，所以我可以直接将乘除法的结果计算出来后入栈。
- 对于加减法，我们不直接计算结果，而是将两端数字保存在栈中。加法当然可以直接保存，对于减法，在减号右边的数保存其相反数。

比如扫描`14 - 2 * 3`的过程中，栈是这样变化的：
```text
14
14 -2
14 -6
```

最终返回结果时，返回整个栈中所有元素的和即可。

还有一些细节问题。
比如为了能够扫描进最后一个数字，我在扫描序列的末尾添加了一个加号。
因为算法是每扫描到一个运算符号时，认为刚扫描完前一个数字，然后判断prev的运算符进行运算的，为了将最后一个数字也计入计算，需要额外多扫一次。

还有就是除号的问题。一开始除法运算我直接用的`//`运算。
但是Python中有一些问题，比如`-3 // 2`是`-2`。但是按照题意这里应该是`-(3//2) = -1`。
为了处理这个情况，我在prev是除号的分支中增加了对两端数字是否同号的判断以及分别的处理。