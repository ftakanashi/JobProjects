## 题目描述
给你一个在 X-Y 平面上的点构成的数据流。设计一个满足下述要求的算法：

添加 一个在数据流中的新点到某个数据结构中。可以添加 重复 的点，并会视作不同的点进行处理。
给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个 面积为正 的 轴对齐正方形 ，统计 满足该要求的方案数目。
轴对齐正方形 是一个正方形，除四条边长度相同外，还满足每条边都与 x-轴 或 y-轴 平行或垂直。

实现 DetectSquares 类：
```
DetectSquares() 使用空数据结构初始化对象
void add(int[] point) 向数据结构添加一个新的点 point = [x, y]
int count(int[] point) 统计按上述方式与点 point = [x, y] 共同构造 轴对齐正方形 的方案数。
```

示例：

![](https://assets.leetcode.com/uploads/2021/09/01/image.png)
```
输入：
["DetectSquares", "add", "add", "add", "count", "count", "add", "count"]
[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]
输出：
[null, null, null, null, 1, 0, null, 2]

解释：
DetectSquares detectSquares = new DetectSquares();
detectSquares.add([3, 10]);
detectSquares.add([11, 2]);
detectSquares.add([3, 2]);
detectSquares.count([11, 10]); // 返回 1 。你可以选择：
                               //   - 第一个，第二个，和第三个点
detectSquares.count([14, 8]);  // 返回 0 。查询点无法与数据结构中的这些点构成正方形。
detectSquares.add([11, 2]);    // 允许添加重复的点。
detectSquares.count([11, 10]); // 返回 2 。你可以选择：
                               //   - 第一个，第二个，和第三个点
                               //   - 第一个，第三个，和第四个点
```

提示：
```
point.length == 2
0 <= x, y <= 1000
调用 add 和 count 的 总次数 最多为 5000
```

### 解法 哈希表 计数
这真是冥冥中有什么力量…（`LC.593`），今天的每日一题就也是一道正方形…

不过需要注意，这题中的正方形限定为所谓的轴对齐正方形，即每一条边和X或者Y轴平行，这样问题就简化了很多。

拿到一个点`x, y`之后，判断以这个点为顶点的正方形是哪些，由于边长暂时未知，很自然地，想到了先确定和其在同一条纵边
上的另一个点是什么。
只要确定那样的点`x, y'`，自然边长就有了(`y-y'`的绝对值)，接着就可以定位另外两个顶点。

于是，在`add`的时候，考虑将点`x,y`以`x`为键，`y`为值保存起来。值放进一个列表，从而通过键值对维护了
相同`x`值的所有点。

进一步的，由于题目要求多个相同点要计数多次，所以统计可能的正方形数目时需要遍历所有`y'`。
考虑到可能有大量重复的`y'`，如果遍历时间太长，所以将列表直接改成一个计数器，这样相同值`y'`的情况只需要计算一次，再乘以计数值即可。

具体的，构建一个`map = defaultdict(Counter)`。
`add`的时候，针对点`x, y`，维护`map[x][y] += 1`。

而在`count`的时候，首先找到`map[x]`中的那些`y'`（和`y`相等的情况直接跳过），
接着计算边长`e = abs(y' - y)`，最后只需要检查剩余两个点的存在性即可。
剩余两个点可能在已经定位两点的左边或者右边，即`(x-e, y), (x-e, y')`和`(x+e, y), (x+e, y')`。

为了统计数量，将上面三个点的计数值相乘，便是确定了`(x, y)`和`(x, y')`之后合法正方形的数量。