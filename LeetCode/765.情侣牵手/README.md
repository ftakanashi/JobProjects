## 题目描述

N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 
一次交换可选择任意两人，让他们站起来交换座位。

人和座位用 0 到 2N-1 的整数表示，情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2N-2, 2N-1)。

这些情侣的初始座位  row[i] 是由最初始坐在第 i 个座位上的人决定的。

示例 1:
```
输入: row = [0, 2, 1, 3]
输出: 1
解释: 我们只需要交换row[1]和row[2]的位置即可。
```
示例 2:
```
输入: row = [3, 2, 0, 1]
输出: 0
解释: 无需交换座位，所有的情侣都已经可以手牵手了。
```
说明:
- len(row) 是偶数且数值在 [4, 60]范围内。
- 可以保证row 是序列 0...len(row)-1 的一个全排列。

### 解法 并查集
题目里涉及到的数字太多了，有点混乱，我们不妨先用a1a2, b1b2, c1c2这样的方式来表示情侣。

另外，给数组中的数字两两分组时注意，其实下标来说只可能分为(01)(23)(45)的分组。而不能0(12)(34)等。
因为后者显然会多出头尾两个多余的数字。

为了不那么抽象，我们将一个"分组"看做是一个"沙发"，这样每个下标都位于其//2之后编号的沙发上。

接下来分析案例。假设输入`a1b1 a2b2 c1c2`这样的序列。
显然交换1次即可，因为c1c2本身都已经处于2号沙发上。
相应的，如果输入时`a1b1 b2c2 a2c1`，三者互相间都要交换，至少需要两次。

以此类推，其实可以发现，如果将每个沙发视为一个节点，而将每对情侣x1和x2所在的沙发节点互相连接。
最终形成某个连通分量后，这个联通分量的节点个数-1就是要交换的次数。

下面是个规模稍微更大些的例子：`a1e2 b1d1 b2c1 c2d2 a2e1`，这里面有两个连通分量，可以感受一下。

既然是基于连通分量的做法，那就好办了，上并查集。

具体实现时由于最后关心连通分量的大小，所以根据以前的经验可以再并查集中维护size实时更新大小记录。

由于x1和x2可能相距很远比如上例中的a1和a2，为了可以先遍历一遍输入，将所有人和他们所在的沙发统计到一个哈希表里。