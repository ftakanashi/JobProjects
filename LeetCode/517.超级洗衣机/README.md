## 题目描述
假设有 n 台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。

在每一步操作中，你可以选择任意 m (1 <= m <= n) 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。

给定一个整数数组 machines 代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的 最少的操作步数 。如果不能使每台洗衣机中衣物的数量相等，则返回 -1 。

示例 1：
```
输入：machines = [1,0,5]
输出：3
解释：
第一步:    1     0 <-- 5    =>    1     1     4
第二步:    1 <-- 1 <-- 4    =>    2     1     3    
第三步:    2     1 <-- 3    =>    2     2     2   
```
示例 2：
```
输入：machines = [0,3,0]
输出：2
解释：
第一步:    0 <-- 3     0    =>    1     2     0    
第二步:    1     2 --> 0    =>    1     1     1     
```
示例 3：
```
输入：machines = [0,2,0]
输出：-1
解释：
不可能让所有三个洗衣机同时剩下相同数量的衣物。
```

提示：
```
n == machines.length
1 <= n <= 104
0 <= machines[i] <= 105
```

### 解法 贪心
老实说，这题我是直接看答案的，而且看完之后也没太理解，并且也不觉得答案有多"贪心"…
总之先记录一下，以后有机会再仔细研究吧。

首先，由于最终要让每个洗衣机中的衣服数量相同，所以第一步可以先求出衣服总数，然后看其能不能被洗衣机数量整除。
若不行，直接返回-1即可。
若可以，那么除的结果就是最终洗衣机的衣服数量。

接着很自然的，结合最终洗衣机的衣服数量以及初始时的数量，可以求出每个洗衣机的"净给出衣物数量"。
这个概念在下面的具体解法中非常重要。
既然定义为"净给出"，则显然其求法是`machines[i] - avg`，`avg`就是最终的均值，而若"净给出数量"是负数，则说明是需要接收其他地方来的衣物。
我们定义"净给出衣服数量"数组为`out`。

接着，还需要意识到一点。
从位置为`i`的洗衣机中拿出`n`件衣服补充到`j`中，按照题设的要求，最少应该是`n`步。
这点或许有些难理解，但是要这么想：若`i`和`j`刚好相邻，这没有异议。若不相邻，那么其实就是`i`给`i+1`，`i+1`给`i+2`...（假设`i < j`)
以此类推，也可以做到衣服的补充。而上述过程在题设中是一步。所以`n`件衣服就是`n`步。

这里还有一点小疑问，你可能会说，如果`i`和`j`中间全是0怎么办，0不能变成-1啊。
确实如此，但是因为这题要求所有洗衣机都达到平均衣服数，所以在操作给`j`衣服之前，率先给这些0衣服即可。
虽然操作顺序上有所不同，但是总的操作步数不会变。

在明白上面这一点之后，采取如下的思路：
将machines这些洗衣机以下标`i`为分界线，分割成`machines[:i+1]`和`machines[i+1:]`两组。
这两组自然有对应的"净给出"数据的分组，`out[:i+1]`和`out[i+1:]`。

定义`sum[i] = sum(out[:i+1])`，即对`out`数组求前缀和。得到的`sum[i]`，意义是前`i`个洗衣机"净给出"衣服的数量和。
若`sum[i]`是`k`（假设`k > 0`)，说明前`i`个洗衣机要向后面剩余洗衣机总共输出`k`件衣服，根据上面说过的那点，总共需要`k`步。

我们遍历所有的`i`作为分隔点，求出其中最大的`k`，这可能就是我们要做到均衡所有洗衣机的最小步数。
当然这里还要注意，因为题设并没规定转移的顺序，所以可以有`k < 0`，即后向前转移的情况，此时取绝对值即可，即取`max(abs(sum))`即可。

到这里还没完。
比如示例`4 2 11 3 3 1`这样的有相对极端大的元素时，显然上述最大的`sum[i]`的绝对值是`abs(sum[2]) = 5`。
然而，即便前三个洗衣机向后三个转移5个衣服后，前三个组内依然没有配平。
这时策略应该是选取最大的`out`，即`max(out) = out[2] = 7`。

综上，分两种情况取最大值，以确定最终的答案。
原理可能有点难懂，但是代码倒是很好写…代码逻辑直接看代码吧。。