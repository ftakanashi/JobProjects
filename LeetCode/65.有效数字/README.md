## 题目描述
验证给定的字符串是否可以解释为十进制数字。

例如:
```text
"0" => true
" 0.1 " => true
"abc" => false
"1 a" => false
"2e10" => true
" -90e3   " => true
" 1e" => false
"e3" => false
" 6e-1" => true
" 99e2.5 " => false
"53.5e93" => true
" --6 " => false
"-+3" => false
"95a54e53" => false
```

说明: 我们有意将问题陈述地比较模糊。

在实现代码之前，你应当事先思考所有可能的情况。

这里给出一份可能存在于有效十进制数字中的字符列表：
- 数字 0-9
- 10的指数 - "e"
- 正/负号 - "+"/"-"
- 小数点 - "."

当然，在输入中，这些字符的上下文也很重要。

### 解法1 简单的分类讨论
最简单朴素的一种办法，就是if/else简单讨论。

当然，合理地设计分支路线间的逻辑关系可以简化讨论的可能性。

比如，显然对于所有非1234567890+-.eE的字符，如果扫描到了直接可以返回False。

然后第一个应该被讨论的是e和E，因为他可以将字符串分成base和10的次幂两部分。

而每一部分的判别，其实是互相独立的。这个判别函数也可以拿出来用来判断，字符串s中本身就没有e的整体合法情况。

代码里写了注释。

### 解法2 有限状态机（DFA)
解法1虽然能过，但是代码不优雅。

有限状态机DFA在这题里也能做。
>参考https://leetcode-cn.com/problems/valid-number/solution/biao-qu-dong-fa-by-user8973/
>
>![](https://pic.leetcode-cn.com/0683d701f2948a2bd8c235867c21a3aed5977691f129ecf34d681d43d57e339c-DFA.jpg)
>
>另一个：https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/


#### 2021/06/17 追加笔记
上次做到这题时，DFA基本属于照抄代码。这次尝试着自己从零开始定义转移图。记录一点心得。

首先应该意识到，DFA的核心是那张状态之间互相转换的有向图。
在类似于这题还有`LC.8`之类的题目中，这张图的节点是所谓的"状态"，但是状态是抽象的，需要人脑来考虑的。
而字符种类并不是状态即图的节点。相反，种类应该定义的是边。

可以将其想象成：输入字符串是一连串指令，而我是一个机器人从图的起点按照定义的规则开始走。
指令输入完之后我必然位于图中的某个节点，而位于哪个节点就可以决定，最终的状态合法or非法。

接着，如何定义DFA对应的图是本体最难的地方，也是核心。
首先第一步要做的是罗列出所有可能的字符种类，这些也是定义边的关键。这道题中，可能的字符种类有以下这些：
```text
blank即空格
+,-
0-9
e,E
.
```
当扫描过程中出现非上述字符，则可以直接返回False。

于是我知道了，如果用邻接矩阵来表示这个图，那么这个矩阵共有五列。
另一方面，确定几行是最难的。

这次做下来我的经验是设计一堆用例先整出一个大概的图的框架，然后修正细节部分。
比如最开始的0状态，如果加一个空格，还是0状态自己。
如果加正负号，可以到达一个新状态，如果加数字，可以到达另一个新状态。

上述两个新状态，一开始我将他们混为一谈因为到达新状态之后似乎后面的行为准则都是一样的。
但是后来意识到，我们最终目的是要找出一些合法的状态。显然`"+"`是非法的而`"1"`是合法的。
但如果按照上面的规则，相当于0通过两条边都连到1状态，无法区分两者（事实上这本来就违背了有向图的定义，两个节点之间只能有一条有向的边）
所以，我将正负号连出的边上增加一个中间节点2，再用一个 0-9 边从2连到1。

如此，有了中间节点之后，`"+"`就被区分开了。此时终止节点在2，而2可以定义为非法节点。

通过以上"发现问题后添加中间节点"的技巧，不断修正图的细节部分，最终拿到一个正确的图。
最终还需要再过一次图，看看哪些节点才是结束时合法的节点。

这次自己做的代码记录如下：
```python
class Solution:
    def isNumber(self, s: str) -> bool:
        # [blank, +-, 0-9, eE, .]
        transfer = [
            [0, 1, 2, -1, 8],
            [-1, -1, 2, -1, 8],
            [3, -1, 2, 5, 4],
            [3, -1, -1, -1, -1],
            [3, -1, 4, 5, -1],
            [-1, 6, 7, -1, -1],
            [-1, -1, 7, -1, -1],
            [3, -1, 7, -1, -1],
            [-1, -1, 4, -1, -1]
        ]

        state = 0
        valid_states = [2, 3, 4, 7]
        for ch in s:
            if ch == ' ': state = transfer[state][0]
            elif ch in '+-': state = transfer[state][1]
            elif ch.isdigit(): state = transfer[state][2]
            elif ch in 'eE': state = transfer[state][3]
            elif ch == '.': state = transfer[state][4]
            else: state = -1

            if state == -1: return False

        return state in valid_states
```

另外上述推导图的草稿纸照片也附上了。