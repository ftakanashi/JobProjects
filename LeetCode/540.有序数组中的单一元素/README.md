## 题目描述
给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。

请你找出并返回只出现一次的那个数。

- 你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。

示例 1:
```
输入: nums = [1,1,2,3,3,4,4,8,8]
输出: 2
```
示例 2:
```
输入: nums =  [3,3,7,7,10,11,11]
输出: 10
```

提示:
```
1 <= nums.length <= 105
0 <= nums[i] <= 105
```

### 解法 二分
看到题目，首先想到的是异或一波，不过既然要求满足O(logn)，那么二分没跑了。

问题是二分的关键，如何决定二分后下一步的搜索范围呢？
在观察一阵数据后，发现了如下规律。

首先，由于题目保证数组中有且仅有一个只出现一次的数字，其余都是两次，这说明我们第一次二分找到的必然是数组的中点。
在中点的基础上，左右两边的数字个数相等。
于是，只需要观察中点的数字是和左边的数字相同还是和右边的数字相同。

若和左边的数字相同，类似于示例2的情况，此时我们看到唯一的数字10在中点右边，如何才能在算法中判断到这一点呢？
观察到，由于当前中点的左边算上中点，恰好是偶数个数字。且中点和左边一个的数字相等，这就说明中点左边全部都是成对的。

用更数学的语言来描述就是，
当`mid`与`mid-1`相等，且`mid`为奇数时，要找的唯一数字在`mid`右侧，所以`l = mid + 1`。
若`mid`是偶数，则说明唯一数字在`mid`左边，所以`r = mid - 2`（一口气跳两格，因为已经知道`mid-1`不是唯一的数字了）

同理，若中点和右边数字相同，也会有类似但是相反的结论。
以上规律总结成代码就是像下面这样的：
```text
mid = (l + r) // 2
if nums[mid] == nums[mid-1]:
    if mid & 1 == 1:
        l = mid + 1
    else:
        r = mid - 2
elif nums[mid] == nums[mid+1]:
    if mid & 1 == 1:
        r = mid - 1
    else:
        l = mid + 2
else:
    return nums[mid]
```
深入分析一下还可以发现，上面`l`和`r`的每一次移动，都会保持搜索范围仍然是一个奇数长度的范围，
因此可以迭代地套用上面的代码二分查找直到找到唯一数字。