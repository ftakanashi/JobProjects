## 题目描述
给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。

返回所有可能的结果。答案可以按 任意顺序 返回。

示例 1：
```
输入：s = "()())()"
输出：["(())()","()()()"]
```
示例 2：
```
输入：s = "(a)())()"
输出：["(a())()","(a)()()"]
```
示例 3：
```
输入：s = ")("
输出：[""]
```

提示：
```
1 <= s.length <= 25
s 由小写英文字母以及括号 '(' 和 ')' 组成
s 中至多含 20 个括号
```

### 解法 BFS
其实这题并没有想象得那么难。
注意到，删除最小数量括号这个前提条件，这本质上就是一个求最短路径问题，所以想到可以使用BFS。

具体的，我们首先定义一个`check`函数用于检查某个字符串是否是一个合法的括号字符串。
这可以通过简单的计数法首先。类似的题目见`LC.20`等。

接着就是对源字符串S进行一个BFS的搜索。
搜索过程中，依次扫描每个字符并且进行字符的去除，并将去除后的字符串入队。

随着队列迭代的进行，必然会在某个时刻碰到一个合法的子串（极端的情况，可能s本身就是合法的，此时无需删除任何字符；或者s全是左/右括号）。
此时就可以收割结果并记录下来。
为了保证结果的不重复并且节省时间，在BFS外设置一个seen就有必要了。

另一方面还需注意，由于题目要求给出的是删除最小数量字符的多个答案，换言之，我们不需要搜索到底。
当搜索到一个合法的子串时，就可以马上记录下他的长度，之后搜索到的子串若长度小于这个值，那么就没有任何继续搜索的必要，直接continue掉即可。

以上。