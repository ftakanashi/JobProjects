## 题目描述
给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。

注意：

数组大小可能非常大。 使用太多额外空间的解决方案将不会通过测试。

示例:
```java
int[] nums = new int[] {1,2,3,3,3};
Solution solution = new Solution(nums);

// pick(3) 应该返回索引 2,3 或者 4。每个索引的返回概率应该相等。
solution.pick(3);

// pick(1) 应该返回 0。因为只有nums[0]等于1。
solution.pick(1);
```

### 解法1 哈希表
第一种基于哈希表的解法没啥可说的，就是最直接的思路。

用一个哈希表记录所有数字与下标的对应情况。考虑到重复数字，所以下标应该用一个列表来保存。

然后每次调用pick时，都从相应的列表中随机选出一项即可。

### 解法2 蓄水池抽样
首先必须说明，怎么看都觉得解法2不如解法1有效率，但是不知道为什么LC的判定就是解法2比解法1快很多。

看到这道题再看到蓄水池抽样几个字，我第一时间想到的办法是，维护一个`int: int`的哈希，在构造阶段就进行全数组扫描，然后碰到重复的数字的时候，
用蓄水池抽样的原则进行保留或替换，这样扫描完成后可以保证某数字的所有下标都被等概率的选中。

但是这样的问题是，每次调用pick并且参数是同一个数字时，输出也永远是同一个，并不符合题意。

想了一会儿感觉没啥头绪，看了一眼答案后我傻了…
答案的意思是，构造阶段根本没必要做任何工作，而每次pick的时候都进行O(n)的全数组扫描并且基于蓄水池抽样进行下标的选出。

比较一下两个解法，虽然最高时间复杂度都是O(n)（当然解法1中的空间复杂度会更大一些），但是解法1只在构造时O(n)，解法2每次pick都要O(n)。
就这，解法2还是吊打了解法1，为什么呢…