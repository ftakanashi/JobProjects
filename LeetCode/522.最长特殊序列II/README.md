## 题目描述
给定字符串列表，你需要从它们中找出最长的特殊序列。最长特殊序列定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。

子序列可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。

输入将是一个字符串列表，输出是最长特殊序列的长度。如果最长特殊序列不存在，返回 -1 。

示例：
```
输入: "aba", "cdc", "eae"
输出: 3
```

提示：
```
所有给定的字符串长度不会超过 10 。
给定字符串列表的长度将在 [2, 50 ] 之间。
```

### 解法 排序后扫描
其实这题可行解法都是挺暴力的，无非就是稍微优化了一点。

借鉴`LC.521`的思路，可以知道，如果输入数组中存在某个特殊序列，那么这个序列一定是某个字符串本身。
又因为我们需要这个序列尽可能长，很自然就想到了，将所有字符串按照长度逆序排序，然后从长扫描到短。

显然，不是随便拿出一个字符串就是答案的。那么哪些字符串才是答案呢？
首先，这个字符串应该满足要求是不重复。因为一旦有一模一样的字符串存在在数组中，那么无论你是多长的字符串，立马gg。
是否有重复这个点，显然可以用一个counter来搞定。

其次，这个字符串不能是其他字符串的一个子序列，否则就不满足题意了。
关于这个第二点，其实没有太好的办法，只能挨个判断其他字符串是否包含本字符串作为子序列。
不过由于这里的"其他字符串"一定是长度大于本串的，在排序好的基础上，我只要搜索之前扫描过的位置的那些字符串就行了。

按照以上思路写代码。