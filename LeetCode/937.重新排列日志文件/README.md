## 题目描述
给你一个日志数组 logs。每条日志都是以空格分隔的字串，其第一个字为字母与数字混合的 标识符 。

有两种不同类型的日志：
- 字母日志：除标识符之外，所有字均由小写字母组成
- 数字日志：除标识符之外，所有字均由数字组成

请按下述规则将日志重新排序：
- 所有 字母日志 都排在 数字日志 之前。
- 字母日志 在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序。
- 数字日志 应该保留原来的相对顺序。

返回日志的最终顺序。
 

示例 1：
```
输入：logs = ["dig1 8 1 5 1","let1 art can","dig2 3 6","let2 own kit dig","let3 art zero"]
输出：["let1 art can","let3 art zero","let2 own kit dig","dig1 8 1 5 1","dig2 3 6"]
解释：
字母日志的内容都不同，所以顺序为 "art can", "art zero", "own kit dig" 。
数字日志保留原来的相对顺序 "dig1 8 1 5 1", "dig2 3 6" 。
```
示例 2：
```
输入：logs = ["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"]
输出：["g1 act car","a8 act zoo","ab1 off key dog","a1 9 2 3 1","zo4 4 7"]
```

提示：
- 1 <= logs.length <= 100
- 3 <= logs[i].length <= 100
- logs[i] 中，字与字之间都用 单个 空格分隔
- 题目数据保证 logs[i] 都有一个标识符，并且在标识符之后至少存在一个字

### 解法1 普通解法
扫描一遍原日志列表，判断是否是数字日志。

如果是数字日志收割进数字日志结果数组，由于保持原序，直接append即可。

如果是字母日志，由于内容排序优先标识符排序，所以倒过来保存，即保存`(内容， 标识符)`元组。

之后直接sort字母日志的数组后，再extend数字日志的数组。


### 解法2 自定义排序
题目明确说了就是要重排。既然有规律，那完全可以自定义排序的key判断规则然后调用库函数的sort即可。

说到自定义排序key，容易想到通过重载类的`__lt__`方法来实现实例间排序的重新定义。
但是这里比对的直接是字符串，如果要这么搞还需要自己定义一个Log类。

其实一般问题中自定义排序key的关键是返回一个元组，元组中是各个属性的优先级。

像这道题可以返回一个类似于`(type, content, key)`的元组。

`type`是0或1，字母为0，数字为1。
`contetn`和`key`自然就是日志的内容和标识符了。

但这样还有一个问题，像所有的数字log，其要保持原序，但是这里加入了content和key的判断就不一定保持原序了。

幸好python内置的sort函数是稳定的，所以在想要保持原序的时候就只返回`type`，去掉另外两个返回即可。

所以综合起来看，自定义排序的key函数应该是：
```python
def myorder(log: str):
    key, con = log.split(' ', 1)
    return (1, ) if con[0].isdigit() else (0, con, key)
```