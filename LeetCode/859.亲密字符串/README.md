## 题目描述
给你两个字符串 s 和 goal ，只要我们可以通过交换 s 中的两个字母得到与 goal 相等的结果，就返回 true ；否则返回 false 。

交换字母的定义是：取两个下标 i 和 j （下标从 0 开始）且满足 i != j ，接着交换 s[i] 和 s[j] 处的字符。

例如，在 "abcd" 中交换下标 0 和下标 2 的元素可以生成 "cbad" 。

示例 1：
```
输入：s = "ab", goal = "ba"
输出：true
解释：你可以交换 s[0] = 'a' 和 s[1] = 'b' 生成 "ba"，此时 s 和 goal 相等。
```
示例 2：
```
输入：s = "ab", goal = "ab"
输出：false
解释：你只能交换 s[0] = 'a' 和 s[1] = 'b' 生成 "ba"，此时 s 和 goal 不相等。
```
示例 3：
```
输入：s = "aa", goal = "aa"
输出：true
解释：你可以交换 s[0] = 'a' 和 s[1] = 'a' 生成 "aa"，此时 s 和 goal 相等。
```
示例 4：
```
输入：s = "aaaaaaabc", goal = "aaaaaaacb"
输出：true
```

提示：
```
1 <= s.length, goal.length <= 2 * 104
s 和 goal 由小写英文字母组成
```

### 解法 扫描模拟 + 哈希表
这道题…说难吧，是一点都不难。但是说简单吧，还真没能一发ac…

首先，考虑最简单的思路。两个指针分别扫描`s`和`goal`两个字符串。统计其中字母不同的位置。
如果其中刚好有两个位置不同且两个位置能够互相和对方的另一个位置相同，那么就可以返回True。
除此之外的一切情况都应该是False。

然而这个思路有一个漏洞，就是像示例3那样的，两个相同的字母进行交换。
实际上他可以进行一次交换但是单纯扫描判是否想同无法识别这种情况。

此时，针对这种情况可以特事特办。
在`s == goal`的前提下，设置一个counter统计字母的出现次数。
只要有任意一个字母的出现次数达到两次，说明就可以将其作为交换的字母，从而`s`和`goal`可以返回True。

以上思路具体化之后就是代码了。

最后忘了，题目没有给出`s`和`goal`长度一定相等的前提条件。因此如果不等记得最开始直接返回False即可。