## 题目描述

我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “山脉”：

- B.length >= 3
- 存在 0 < i < B.length - 1 使得 B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]
（注意：B 可以是 A 的任意子数组，包括整个数组 A。）

给出一个整数数组 A，返回最长 “山脉” 的长度。

如果不含有 “山脉” 则返回 0。

示例 1：

>输入：[2,1,4,7,3,2,5]
>
>输出：5
>
>解释：最长的 “山脉” 是 [1,4,7,3,2]，长度为 5。

示例 2：

>输入：[2,2,2]
>
>输出：0
>
>解释：不含 “山脉”。
 

提示：

- 0 <= A.length <= 10000
- 0 <= A[i] <= 10000

### 解法1 枚举山顶
一个简单直观的解法就是，从第二个元素开始扫描数组至倒数第二个元素（首尾元素不能作为山顶）。
确定该元素是不是山顶（左侧严格递减，边界为0，右侧严格递减，边界为len(A)-1）

如果是山顶那么其具有一个长度，如果不是则继续扫描下一个。

同时注意，如果其实山顶，那么以为这在这座山的范围内，无需继续扫描（当然左侧都扫描过了，即山顶向右直到右侧山脚为止所有元素都可以不用扫描了）。
此时扫描游标可以直接指向右侧山脚+1。

官方题解中启用了两个等长数组left和right分别记录各个位置作为山顶时其左侧山脚和右侧山脚的位置，
因此空间用了O(n)，但是其实只需要求最长长度，因此可以动态更新max_len，从而做到空间O(1)。

时间方面，不算优化的话，枚举每个山顶肯定是O(n)，此外在每个山顶向左右探索边界最坏情况也是O(n)，
所以没有任何优化的时候是O(n^2)的…

不过经过优化，在Leetcode上居然也能击败95%/55%。