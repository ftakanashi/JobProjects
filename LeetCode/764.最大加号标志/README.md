## 题目描述
在一个 n x n 的矩阵 grid 中，除了在数组 mines 中给出的元素为 0，其他每个元素都为 1。mines[i] = [xi, yi]表示 grid[xi][yi] == 0

返回  grid 中包含 1 的最大的 轴对齐 加号标志的阶数 。如果未找到加号标志，则返回 0 。

一个 k 阶由 1 组成的 “轴对称”加号标志 具有中心网格 grid[r][c] == 1 ，以及4个从中心向上、向下、向左、向右延伸，长度为 k-1，由 1 组成的臂。注意，只有加号标志的所有网格要求为 1 ，别的网格可能为 0 也可能为 1 。

示例 1：

![](https://assets.leetcode.com/uploads/2021/06/13/plus1-grid.jpg)
```
输入: n = 5, mines = [[4, 2]]
输出: 2
解释: 在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。
```
示例 2：
```
输入: n = 1, mines = [[0, 0]]
输出: 0
解释: 没有加号标志，返回 0 。
```

提示：
```
1 <= n <= 500
1 <= mines.length <= 5000
0 <= xi, yi < n
每一对 (xi, yi) 都 不重复
```

### 解法 暴力（DP）
其实就是暴力可以做，硬要说的话带一点DP的意思。

题意中还有一些细节需要注意，比如对于一个1的孤岛，其实也视作是一个长度为1的加号。
还有题目没有给出完整地图`grid`，而是给出了`mines`数组，其中每个位置都是0，其余地图中的所有都是1。

针对某个特定的位置，以其作为中心的加号最大长度，其实就是上下左右四个方向上1延伸出的最大长度。
而在某个特定方向上，其能延伸的最大长度显然就是这个方向上的前序的格子的长度+1。

于是就有了大概的思路。
我们可以创建一个`n * n * 4`的DP数组。其中`dp[i][j][k]`表示位置`i,j`处某个特定方向上延伸的最长长度的1的个数。`k`的0123分别对应了左上右下。
初始状态，所有原值是1的位置`dp[i][j] = [1, 1, 1, 1]`，否则就是`[0, 0, 0, 0]`。

至于状态转移方程，就是
```python
dp[i][j][0] = dp[i][j-1][0]
dp[i][j][1] = dp[i-1][j][1]
dp[i][j][2] = dp[i][j+1][2]
dp[i][j][3] = dp[i+1][j][3]
```
注意上述四个递推式子都要在两个循环中实现，必须保证等号右边的值先于左边的值更新。

总的看下来复杂度是`N^2`。