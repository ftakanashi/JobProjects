## 题目描述
给定一个从1 到 n 排序的整数列表。

首先，从左到右，从第一个数字开始，每隔一个数字进行删除，直到列表的末尾。

第二步，在剩下的数字中，从右到左，从倒数第一个数字开始，每隔一个数字进行删除，直到列表开头。

我们不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。

返回长度为 n 的列表中，最后剩下的数字。

示例：
```
输入:
n = 9,
1 2 3 4 5 6 7 8 9
2 4 6 8
2 6
6

输出:
6
```

### 解法 用等差数列模拟
这题像极了约瑟夫环。
当然，如果真的有像约瑟夫环那样一步到位的快速解法的话凭自己想是无论如何也想不出来的。
这里也可以预告一下，并不是用约瑟夫环那种投机取巧的解法。

另一方面，若是直接模拟呢？
题目没有给出数据范围。这里有一个LC小技巧，可以点击题目信息中的中英文转换，将题干显示变成英文原文。
英文原文中就有范围了，`1 <= n <= 10^9`。
OK，看来直接模拟也没戏了。

于是尝试写了一下几个稍大一点的例子。发现，任意一个时刻，当我不论正向或者逆向做完一次消除后，剩下的数列一定是一个等差数列。
这就很好了，因为只要你是等差数列，我就可以用首项、项差、项数，三个要素就可以描述你的整个数列。
因此就不需要开辟O(n)的数组保存整个数列，以及真的去不断的扫描消除数字了。

具体的，最开始时首项a0、项差d、项数n分别是`a0, d, n = 1, 1, n`。
而做一次消除操作，结合是否逆向的flag变量rev，可以有以下规律：
```text
n = n // 2
d = d * 2
a0 = a0 或者 a1 
```
前两个变化基本没什么疑问，问题在于第三个的分类讨论。
通过写几个例子我们知道，仅当`rev is True and n & 1 == 0`时，a0才会被保留下来，其他情况都是取a1。
至此，题目就可以做了。

实际实现中，为了能通过d和a0取到a1，对于这三个变量进行变化的顺序还需要注意一下。

进一步可以分析一下这种做法。
原本如果完全模拟，显然空间需要O(n)，时间接近于O(2n)。
而通过等差数列三要素进行模拟时，n是指数减小的，所以时间是O(logn)。