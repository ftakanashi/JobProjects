## 题目描述
给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明：

- 所有数字（包括目标数）都是正整数。
- 解集不能包含重复的组合。 

示例 1:
>输入: candidates = [10,1,2,7,6,1,5], target = 8,
>
>所求解集为:
>```
>[
>  [1, 7],
>  [1, 2, 5],
>  [2, 6],
>  [1, 1, 6]
>]
>```
示例 2:
>输入: candidates = [2,5,2,1,2], target = 5,
>
>所求解集为:
>```
>[
>  [1,2,2],
>  [5]
>]
>```

### 解法 DFS（回溯）
和`LC39.组合总和`基本类似。

按照39的思路，写出第一版DFS代码。
和39题不同的地方，在于这题每个数字只能用一次。
显然，在探索的时候，已经得到的序列和小于target的情况时，下一轮递归的start参数应该是`i+1`而不是`i`了（详情见39题代码）。

乍一看好像没问题，但是一跑发现了问题。
比如示例1这个情况，跑出的结果里会有两个`[1, 2, 5]`和两个`[1, 7]`。

显然，39题中保证了candidates中无重复元素，但是这题不保证。由于有两个1存在，所以每个1都可以看做互相独立的一个起点，因此整出了两套带有一个1
的答案。

最朴素的一个解决办法就是把结果变成一个set，采用自动去重的办法。
但是试了之后发现一来代码很不简洁，二来在一些极端case比如27个1的candidates，target是27的时候，这时候会超时。

于是再来细细分析，到底问题出在哪。

以`[1, 2, 2, 5]  8`为例。
显然正确答案是`[[1,2,5]]`。因为上面说到的原因，目前算法给出的答案有两个`[1,2,5]`。

大概可以感觉到，只要扫描时碰到的数字是重复的，直接跳过就可以避免重复结果的出现。
只是具体什么情况下可以跳过呢。

单纯在扫描过程中全部跳过是不行的。万一target是5，那`[1,2,2]`是正确答案。

其实面对这两个2，递归的结果中带有第一个2的那些递归都不能舍弃，因为至少要探索结果中带2的可能性。
只有带第一个2的情况扫描结束，进入递归的部分结果是只带第二个2的情况下，才可以放弃。
（可能有点拗口，建议看代码再体会一下……）

因此，只需要扫描加上这一行代码即可：
```python
if i > start and candidates[i-1] == candidates[i]:
    continue
```