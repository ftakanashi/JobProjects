## 题目描述
给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。合法的代码片段需要遵守以下的所有规则：

1. 代码必须被合法的闭合标签包围。否则，代码是无效的。
2. 闭合标签（不一定合法）要严格符合格式：<TAG_NAME>TAG_CONTENT</TAG_NAME>。其中，<TAG_NAME>是起始标签，</TAG_NAME>是结束标签。起始和结束标签中的 TAG_NAME 应当相同。当且仅当 TAG_NAME 和 TAG_CONTENT 都是合法的，闭合标签才是合法的。
3. 合法的 TAG_NAME 仅含有大写字母，长度在范围 [1,9] 之间。否则，该 TAG_NAME 是不合法的。
4. 合法的 TAG_CONTENT 可以包含其他合法的闭合标签，cdata （请参考规则7）和任意字符（注意参考规则1）除了不匹配的<、不匹配的起始和结束标签、不匹配的或带有不合法 TAG_NAME 的闭合标签。否则，TAG_CONTENT 是不合法的。
5. 一个起始标签，如果没有具有相同 TAG_NAME 的结束标签与之匹配，是不合法的。反之亦然。不过，你也需要考虑标签嵌套的问题。
6. 一个<，如果你找不到一个后续的>与之匹配，是不合法的。并且当你找到一个<或</时，所有直到下一个>的前的字符，都应当被解析为 TAG_NAME（不一定合法）。
7. cdata 有如下格式：<![CDATA[CDATA_CONTENT]]>。CDATA_CONTENT 的范围被定义成 <![CDATA[ 和后续的第一个 ]]>之间的字符。
8. CDATA_CONTENT 可以包含任意字符。cdata 的功能是阻止验证器解析CDATA_CONTENT，所以即使其中有一些字符可以被解析为标签（无论合法还是不合法），也应该将它们视为常规字符。

合法代码的例子:
```
输入: "<DIV>This is the first line <![CDATA[<div>]]></DIV>"

输出: True

解释: 

代码被包含在了闭合的标签内： <DIV> 和 </DIV> 。

TAG_NAME 是合法的，TAG_CONTENT 包含了一些字符和 cdata 。 

即使 CDATA_CONTENT 含有不匹配的起始标签和不合法的 TAG_NAME，它应该被视为普通的文本，而不是标签。

所以 TAG_CONTENT 是合法的，因此代码是合法的。最终返回True。

输入: "<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>"

输出: True

解释:

我们首先将代码分割为： start_tag|tag_content|end_tag 。

start_tag -> "<DIV>"

end_tag -> "</DIV>"

tag_content 也可被分割为： text1|cdata|text2 。

text1 -> ">>  ![cdata[]] "

cdata -> "<![CDATA[<div>]>]]>" ，其中 CDATA_CONTENT 为 "<div>]>"

text2 -> "]]>>]"

start_tag 不是 "<DIV>>>" 的原因参照规则 6 。
cdata 不是 "<![CDATA[<div>]>]]>]]>" 的原因参照规则 7 。
```
不合法代码的例子:
```
输入: "<A>  <B> </A>   </B>"
输出: False
解释: 不合法。如果 "<A>" 是闭合的，那么 "<B>" 一定是不匹配的，反之亦然。

输入: "<DIV>  div tag is not closed  <DIV>"
输出: False

输入: "<DIV>  unmatched <  </DIV>"
输出: False

输入: "<DIV> closed tags with invalid tag name  <b>123</b> </DIV>"
输出: False

输入: "<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>"
输出: False

输入: "<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>"
输出: False
```
注意:
```
为简明起见，你可以假设输入的代码（包括提到的任意字符）只包含数字, 字母, '<','>','/','!','[',']'和' '。
```

### 解法 暴力分类 栈
这题的解法倒没啥可说的，就是要想对思路，然后疯狂分类讨论即可。

首先应该意识到，由于标签有起始标签和闭合标签，为了能够特定两个标签中间的部分，我们需要借用栈作为数据结构来解题。
接着是具体思路：

挨个扫描字符，当碰到字符`code[i] == "<"`的时候，按照`code[i+1]`的具体值分下几类讨论：

第一，`i`已经是最后一个字符即`i == n-1`。此时显然没有一个合法的标签了，所以直接返回False。

第二，`code[i+1]`为一般字符（非`<>/!`等）时，此时应该考虑找到字符串中下一个`>`，显然中间的片段是一个起始标签。
当然这个标签名要符合要求，即长度在1-9之间，并且所有字符都是大写字母。
最后将这个标签入栈即可。

第三，`code[i+1] == "/"`时，此时也找字符串中下一个`>`，中间的片段是一个终止标签。
此时只需要检查栈顶是否和当前的标签匹配。只要匹配，那么也就意味着终止标签中的标签名也是合法的。

第四，`code[i+1] == "!"`，此时是寻找cdata的情况。由于cdata部分的语法比较固定，所以检查步骤如下。
首先找到接下来的7个字符，即`code[i+2:i+9]`是否恰好是`"[CDATA["`，若是，说明这才可能是一个合法的cdata标签。
接着再寻找cdata部分的终止标识，即`]]>`。中间部分就是cdata的内容。
根据题意，我们不需要检查cdata的内容部分。

除了上面几种情况，其他所有字符都是非法的，可以直接返回False。

至此，扫描到某个字符为`<`时，已经细致地讨论了所有情况（能够形成标签或者cdata的情况）。
看似好像工作只做了一小点，但是实际上已经完成了一大半了。
因为在经过上述讨论之后，在外层扫描碰到的所有其他字符，都可以按照合法内容字符和非法内容字符两类看。

所以，当碰到非`<`字符时，只要此时stack为空，就可以直接返回False，因此此时内容不存在于任何一对标签内。
否则，就可以直接`i += 1`。

综上，更多细节请看代码注释。