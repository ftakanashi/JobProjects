## 题目描述
给定一个 没有重复 数字的序列，返回其所有可能的全排列。

示例:
>输入: [1,2,3]
>
>输出:
>
>```
>[
>  [1,2,3],
>  [1,3,2],
>  [2,1,3],
>  [2,3,1],
>  [3,1,2],
>  [3,2,1]
>]
>```


### 解法1 （自己瞎JB写的）回溯DFS
不解释了

### 解法2 基于交换的回溯法
上面的解法1，是不断地选取未被选取的数字进结果集然后收割结果。

下面介绍一种基于交换的办法。

在知道一个字符串s以及其各个字符的列表chars时，
可以定义一个DFS函数，`dfs(pos: int)`。这个参数`pos`是指当前函数我们需要确定排列中下标为pos的位置放什么数字。
在那之前的所有数字排列都已经固定。

除了解法1中维护seen的办法，另一个办法也可以知道哪些数字还没有被用，就是遵从排列的定义，将pos以后的各个数字依次和pos位置当前数字互换。
每互换一次就生出了一个可能的分支，然后继续dfs即可。dfs完了之后别忘了再交换回去，这是回溯法的模式。

这种基于交换的回溯法用的空间更少。