## 题目描述
给你一个大小为 m x n 的整数矩阵 grid ，表示一个网格。另给你三个整数 row、col 和 color 。网格中的每个值表示该位置处的网格块的颜色。

当两个网格块的颜色相同，而且在四个方向中任意一个方向上相邻时，它们属于同一 连通分量 。

连通分量的边界 是指连通分量中的所有与不在分量中的网格块相邻（四个方向上）的所有网格块，或者在网格的边界上（第一行/列或最后一行/列）的所有网格块。

请你使用指定颜色 color 为所有包含网格块 grid[row][col] 的 连通分量的边界 进行着色，并返回最终的网格 grid 。

示例 1：
```
输入：grid = [[1,1],[1,2]], row = 0, col = 0, color = 3
输出：[[3,3],[3,2]]
```
示例 2：
```
输入：grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3
输出：[[1,3,3],[2,3,3]]
```
示例 3：
```
输入：grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2
输出：[[2,2,2],[2,1,2],[2,2,2]]
```

提示：
```
m == grid.length
n == grid[i].length
1 <= m, n <= 50
1 <= grid[i][j], color <= 1000
0 <= row < m
0 <= col < n
```

### 解法 DFS
这题本质上和`LC.200`是类似的。
而这题稍微难一点的地方在于，如何识别某个位置是否恰好是某个"岛屿"的边界。

这个难点也很好解决。一开始我尝试在DFS过程中做出判断，不过发现这么做可能代码会比较难看。

那么干脆就分开做，进行两次遍历。
第一次，使用DFS从指定位置开始进行扫描，将所有当前"岛屿"上的位置全部设置成一个默认值，比如0。
第二次，再次遍历每个位置，判断其是否是第一次扫描的"岛屿"上的某个点，且是否是这个"岛屿"的边界。
后者可以通过定义一个额外的方法，判断其是否周围四个都是0，就可以轻松得到结果。