## 题目描述
城市用一个 双向连通 图表示，图中有 n 个节点，从 1 到 n 编号（包含 1 和 n）。图中的边用一个二维整数数组 edges 表示，其中每个 edges[i] = [ui, vi] 表示一条节点 ui 和节点 vi 之间的双向连通边。每组节点对由 最多一条 边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是 time 分钟。

每个节点都有一个交通信号灯，每 change 分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。所有信号灯都 同时 改变。你可以在 任何时候 进入某个节点，但是 只能 在节点 信号灯是绿色时 才能离开。如果信号灯是  绿色 ，你 不能 在节点等待，必须离开。

第二小的值 是 严格大于 最小值的所有值中最小的值。

例如，[2, 3, 4] 中第二小的值是 3 ，而 [2, 2, 4] 中第二小的值是 4 。
给你 n、edges、time 和 change ，返回从节点 1 到节点 n 需要的 第二短时间 。

注意：
```
你可以 任意次 穿过任意顶点，包括 1 和 n 。
你可以假设在 启程时 ，所有信号灯刚刚变成 绿色 。
```

示例 1：

![](https://assets.leetcode.com/uploads/2021/09/29/e2.png)     
```
输入：n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5
输出：13
解释：
上面的左图展现了给出的城市交通图。
右图中的蓝色路径是最短时间路径。
花费的时间是：
- 从节点 1 开始，总花费时间=0
- 1 -> 4：3 分钟，总花费时间=3
- 4 -> 5：3 分钟，总花费时间=6
因此需要的最小时间是 6 分钟。

右图中的红色路径是第二短时间路径。
- 从节点 1 开始，总花费时间=0
- 1 -> 3：3 分钟，总花费时间=3
- 3 -> 4：3 分钟，总花费时间=6
- 在节点 4 等待 4 分钟，总花费时间=10
- 4 -> 5：3 分钟，总花费时间=13
因此第二短时间是 13 分钟。      
```
示例 2：

![](https://assets.leetcode.com/uploads/2021/09/29/eg2.png)
```
输入：n = 2, edges = [[1,2]], time = 3, change = 2
输出：11
解释：
最短时间路径是 1 -> 2 ，总花费时间 = 3 分钟
最短时间路径是 1 -> 2 -> 1 -> 2 ，总花费时间 = 11 分钟
```

提示：
```
2 <= n <= 104
n - 1 <= edges.length <= min(2 * 104, n * (n - 1) / 2)
edges[i].length == 2
1 <= ui, vi <= n
ui != vi
不含重复边
每个节点都可以从其他节点直接或者间接到达
1 <= time, change <= 103
```

### 解法 BFS找次短路径
这道题要素过多…我们一点一点来解开这团乱麻。

#### 审题
首先，这是一道图的题目，以示例1为例。
我们的起点是1，而终点是5。

在从起点走向终点的过程中，每经过一条边需要time(即3)个单位的时间，我们不妨假设这个单位是分钟以方便理解。

显然，在没有任何限制的情况下，最快的走法是`1 -> 4 -> 5`，走过两条边，共花费6分钟时间。
而次快的走法，是`1 -> 3 -> 4 -> 5`，共花费9分钟时间。

接着，题目引进了红绿灯系统进行限制。虽然描述的很复杂，但是其实理解起来并不太难。
在第0分钟的时候，默认是绿灯。此时可以无限制地走出去。
不论是走到2，3，4哪个节点，都经过3分钟，而根据change参数，红绿灯5分钟才会切换一次。
因此到达第二个节点后仍然可以继续走。
比如我们到达了3号节点，接着往4号走。在这段路上，红绿灯变色了（因为第5分钟在3和6之间的区间内）。

到达4号节点时，此时时间是6分钟，且红绿灯已经变红，因此我们不能马上出发，而是需要等待。
那么等多久呢？change告诉我们，在第10分钟，红绿灯会再次变绿，因此我们需要等待4分钟，或者说等到第10分钟，就可出发。
再花3分钟走一条边，走到5号节点。总共花费13分钟。这便是示例1的返回，即`1 -> 3 -> 4 -> 5`这条路径的总耗时。

再看一眼示例2，记住题目不限制经过同一节点的次数。
比如示例2中最短路径显然是直接1走到2，就完事了。
而次短的，则是`1 -> 2 -> 1 -> 2`这样一条路。只要最终落脚点在终点，中间的路径可以很自由。

#### 正式解法
一般来说，用BFS求图中的最短路径已经是一个很常见的套路了。
通常情况下，在不允许重复经过节点的时候，我们可以通过一个visited哈希集维护已经到访过的节点。

但是这题明确讲了可以重复经过节点，这要怎么办呢？
如果放任不管，由于BFS的特点，虽然总是会慢慢向终点逼近，只要给够时间，总是能探索到终点，但是中间可能会出现很多无谓的计算。
比如一个很长的链表当做一个图时进行BFS搜索，纸上写一下你就知道，中间会有多少重复的无意义的节点入队了。
（当然这和图的实现也有关，即某个节点的下一个节点们是以什么顺序组织起来的）

此时其实可以借鉴Dijkstra算法中的一些思想。
因为你要求的，是最短路径（严格来说这题是求次短路径，不过原理是一样的，至于区别下面会说），因此我可以维护一个
到达各个节点时最短路径长度的数组。
当BFS搜到某个节点，并且附带着到达此节点的路径累计长度时，只需要比较最短路径数组中到达该节点的路径长度的大小即可。

若数组中的值更小，说明之前的探索中已经确认了比当前探索到此节点更短的路径，因此当前探索的这个分支就没有继续下去的必要。
相反，若是数组中的值更大，那么说明当前路径才是最短路径，因此将当前路径的长度更新到数组中去。

上面这个借鉴了Dijkstra的dist数组的套路，可以说是以前做BFS最短路径探索时没有注意到过的一个盲点。
相比于哈希集，这种办法更加通用。这就体现在下面这种改造上：

这题求的是次长路径，因此我们可以给每个节点设置两个值，一个最短值一个次短值。
比较时自然比较当前路径长度与最短、次短综合的大小关系。比如设三者分别为`d, d1, d2`。
当`d < d1`时，就`d2 = d1; d1 = d`；当`d1 < d < d2`时，就`d2 = d`。
注意本题要求严格的次短，因此`d == d1`或者`d >= d2`时都无需做任何操作。

上面说了一大通，但是都是在说路径长度的事情，而这题要求的是时间。
不过因为路径上花费的时间总是正值，所以这两者本质上一样。
具体的，我们还需要考虑红绿灯的影响。这部分的思路就不细说了，仔细观察观察脑补一下就能得到如下规律：
设到达某个节点时花费的累计时间为`t`，那么从该节点出发走到下一个节点的累计时间是
```text
t + time        -> 当 t // change 是偶数时
change * (t // change + 1) + time   -> 当 t // change 是奇数时
```

在综合了"最短路径长度数组 代替哈希集避免无限循环"，"扩充最短路径长度数组到次短路径"，"考虑红绿灯对总耗时的影响"
这三个点之后，就可以写出正确的代码了。

借鉴BFS求最短路径中early stop的技巧，代码中还设置了一个`first_arrive`变量用于判断是否是第一次搜索到终点。对于第二次搜索到终点的情况进行early stop。

在做完题目之后又仔细思考了一会儿，下面再追加一点思考的笔记。

#### 求次短路径与最短路径之间的区别与联系
如果有一道求最短路径，但是允许重复经过节点的题目，（限制与本题一样，两节点间最多只有一条边且边的权值都一样）
那么显然，还是可以用哈希集来避免走回头路的。
因为最短路径必然不包括回头路，因此只要是求最短路径，那么就和不允许重复经过节点本质上是一样的。

而另一方面，求最短路径的时候，最短路径长度数组起到的作用其实和哈希集也是一样的。
（当然最短路径长度数组还可以顺便求出到所有节点的最短路径而非仅仅到终点，而这就变成了Dijkstra算法）

#### 本题与Dijkstra的联系
用BFS求图中最短路径，总和Dijkstra有千丝万缕的联系。
这里稍微认真比较一下。

一个很不同的点在于要不要用堆优化。即进行BFS的队列，是一个普通的FIFO队列还是一个优先队列。
在Dijkstra的设定中，由于边的权重不一定全相同，所以可能会有绕了远路（走过的边数量更多）但权重和更小的情况。
加之Dijkstra本身的目标就是获取某个点到所有点的最短路径，因此用优先队列总是优先考虑当前可走的边中权重最小的边是一件很自然的事情。

而在一般的BFS探索最短路径的题设中，（比如这题）
边的权重往往是大家都一样，这就导致先扫描到的节点，其累计的权重和总是更小。
换言之，FIFO队列中左边的权重和总是比右边的小，冥冥之中就已经带有了优先队列的特点。
另外有明确的终点则可以不需要维护前面说的那种路径长度数组，而只需要碰到终点就停止搜索并返回即可。

在这题里，由于为了求次长路径，第二点，维护一个路径长度数组不可避免，但是第一点用堆代替FIFO队列可以不必做。
实际上，如果将代码中的queue换成一个以到达节点的累计时间长度作为排序依据的小顶堆，其耗时会稍微有所增长。