## 题目描述
给你两个字符串 a 和 b ，它们长度相同。请你选择一个下标，将两个字符串都在 相同的下标 分割开。由 a 可以得到两个字符串： aprefix 和 asuffix ，满足 a = aprefix + asuffix ，同理，由 b 可以得到两个字符串 bprefix 和 bsuffix ，满足 b = bprefix + bsuffix 。请你判断 aprefix + bsuffix 或者 bprefix + asuffix 能否构成回文串。

当你将一个字符串 s 分割成 sprefix 和 ssuffix 时， ssuffix 或者 sprefix 可以为空。比方说， s = "abc" 那么 "" + "abc" ， "a" + "bc" ， "ab" + "c" 和 "abc" + "" 都是合法分割。

如果 能构成回文字符串 ，那么请返回 true，否则返回 false 。

注意， x + y 表示连接字符串 x 和 y 。

示例 1：
```
输入：a = "x", b = "y"
输出：true
解释：如果 a 或者 b 是回文串，那么答案一定为 true ，因为你可以如下分割：
aprefix = "", asuffix = "x"
bprefix = "", bsuffix = "y"
那么 aprefix + bsuffix = "" + "y" = "y" 是回文串。
```
示例 2：
```
输入：a = "abdef", b = "fecab"
输出：true
```
示例 3：
```
输入：a = "ulacfd", b = "jizalu"
输出：true
解释：在下标为 3 处分割：
aprefix = "ula", asuffix = "cfd"
bprefix = "jiz", bsuffix = "alu"
那么 aprefix + bsuffix = "ula" + "alu" = "ulaalu" 是回文串。
```

提示：
```
1 <= a.length, b.length <= 105
a.length == b.length
a 和 b 都只包含小写英文字母
```

### 解法 双指针
这题可有点把双指针玩出花来了…

首先很容易想到，a和b两个字符串是没有绝对关系只有相对关系的，所以可以设想一个通用判断函数`helper(s1, s2)`。
先后调用`helper(a, b)`和`helper(b, a)`，只要其中有一个是True即可。

另外，题目也明确说了如果a或者b本身是回文的，那就直接返回True。所以可以额外设计一个判断单个字符串回文性的函数`simpleCheck`。
在一切逻辑开始之前预判断一下即可。

接着就是看`helper`逻辑具体如何实现了。
不妨将此函数定义为，`s1`的前缀和`s2`的后缀拼接，即`s1_p + s2_s`是否能得到回文串。

要让这个东西是回文的，最基本的一个特性就是得`s1`和`s2`的开头/结尾一部分子串是轴对称的。这个可以通过一对双指针扫描。
此时有两种扫描结果。假设双指针分别是`i`和`j`。
只要`s1[i] == s2[j]`，就让两者互相往中间靠近。一旦不相等则先break出来。

由于题目给出的实例具有一定误导性，很容易陷入一个思维定式就是根据`i >= j`来直接判断回文性。
诚然，若双指针扫出`i >= j`了，说明`s1_p`和`s2_s`恰好是最终回文串的前后两个部分。

但是别忘了，回文串还有 `xxx yyyyy xxx` 这种套路。
也就是说，即使扫描出`s1_p`和`s2_s`互相堆成，但是此时`i < j`时，仍然存在`s1[i:j+1]`或者`s2[i:j+1]`本身就是一个回文串的可能。
此时可以将分割点设置在`i`或者`j`，也可以满足题目要求的。

举个例子：
```python
a = "abcxyzzyx***"
b = "*********cba"
```
其中`*`表示无关紧要的字符。不难看出，此时`s1_p`和`s2_s`分别是`abc`和`cba`。所以尝试扫描的时候`i == 3 and j == 8`时就会停下来。
但是如果在下标8处分割，那么a的前缀和b的后缀仍然可以组成回文串 `abcxyzzyxcba` 。

综上，总的思路框架就是。
先判断a和b本身的回文性，如果任意一个已经是回文串，就直接True。
接着用双指针分别从a的开头和b的结尾往中间扫。
当碰到`i >= j`或者`a[i] != b[j]`时结束循环。
如果`i >= j`，说明a前缀和b后缀已经可以构成回文串。
否则还需要进一步判断`a[i:j+1]`和`b[i:j+1]`的回文性，任意一个回文也可以返回True。
当然以上是a前缀+b后缀，别忘了反过来的可能性，即第二次helper的调用。

按照以上思路写代码。