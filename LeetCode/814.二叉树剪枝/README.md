## 题目描述
给你二叉树的根结点 root ，此外树的每个结点的值要么是 0 ，要么是 1 。

返回移除了所有不包含 1 的子树的原二叉树。

节点 node 的子树为 node 本身加上所有 node 的后代。

示例 1：
```
输入：root = [1,null,0,0,1]
输出：[1,null,0,null,1]
解释：
只有红色节点满足条件“所有不包含 1 的子树”。 右图为返回的答案。
```
示例 2：
```
输入：root = [1,0,1,0,0,0,1]
输出：[1,null,1,null,1]
```
示例 3：
```
输入：root = [1,1,0,1,1,0,1,0]
输出：[1,1,0,1,1,null,1]
```

提示：
```
树中节点的数目在范围 [1, 200] 内
Node.val 为 0 或 1
```

### 解法 DFS
没啥可说的，就用DFS遍历树并及时做出修改就可以了。

具体的，面对`dfs(node)`的时候，如果是空节点，返回0。否则返回当前子树是否是全0子树，是返回0，否则返回1。
判断`dfs(node.left)`和`dfs(node.right)`。如果某一边的子树返回的是0，说明这个子树要不是空，要不是全零子树。
所以可以直接将这个子树置为None。

另一方面，返回本子树的dfs结果时，则要看是否上述两个子树都返回了0。
若都返回0，那么本子树返回的值由本节点的值决定，直接返回`node.val`即可。（题目规定了所有节点的值是0或者1）
否则无脑直接返回1。

最后还有一个小细节。
外面的处理肯定是`dfs(root)`之后返回`root`。但是需要注意当给出的输入全部都是0的时候，也就是说整个树都要被剪枝的时候，
此时应当直接返回None。
所以需要额外做一个判断，即在`dfs(root)`后当`root.val == 0 and root.left is None and root.right is None`时，直接返回None。