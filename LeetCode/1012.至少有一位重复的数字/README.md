## 题目描述
给定正整数 n，返回在 [1, n] 范围内具有 至少 1 位 重复数字的正整数的个数。

示例 1：
```
输入：n = 20
输出：1
解释：具有至少 1 位重复数字的正数（<= 20）只有 11 。
```
示例 2：
```
输入：n = 100
输出：10
解释：具有至少 1 位重复数字的正数（<= 100）有 11，22，33，44，55，66，77，88，99 和 100 。
```
示例 3：
```
输入：n = 1000
输出：262
```

提示：
```
1 <= n <= 109
```

### 解法 DFS
题意不难理解。这里提供一种比较直观暴力的DFS做法。

要求至少有一个重复数字的，DFS起来有点困难，但是如果反过来求没有任何一个重复数字的就相对简单了。最后拿`n`减一下就好了。

最基本的一个思路框架，是从前向后填各个位置的数字。尝试填写0-9这10个数字，当某个数字已经在之前被使用过，
就不能用，否则就尝试填写然后进入下一层DFS。
不过仔细思考一下，还有几个需要注意的点。

首先是对于不超限制的注意。比如给出`n = 567`，那么显然第一位不能填超过5的，第二位在第一位是5时不能超过6，第三位在第一位是5且第二位是6时不能超过7。

其次是对于前导零的处理。比如`n = 567`时，如何将两位数和一位数也都计入结果。
最简单的思路就是把前导零也当做一种有效的填入手段进行处理。但此时前导的零不应该计入"已经被使用的数字"中。

综上，设计一个DFS函数是`dfs(pos, used, tight)`。
`pos`表示当前正要填写的从左到右位置（下标）。
`used`用二进制位维护了到目前为止已经被使用过的数字。
`tight`表示填写到当前位置前为止，是否之前每个位置的数字都是和`n`各个位置相等。如果是，则说明当前位置能够填写的最大数字是`n`对应的位置，否则就是9。

其中`tight`参数是比较妙的，也是容易被忽略的一个。
举个例子，比如`n = 5678`，而`pos = 3`时，进入dfs时前面三位数字分别填写了`567`时，此时当前位置不能填9。最大只能填8。
是否做这个限制，就由`tight`参数决定。

在dfs中，我们先通过tight决定当前位置的上限。
然后遍历 0-上限 之间所有数字`num`尝试填入。
当`tight`是`True`且`num`等于`n[pos]`时，保持`new_tight`为`True`。
特别的，当`num == 0`时且`used == 0`时，此时说明之前没有用到任何数字并且当前位置可以作为前导零。因此可以选择填入`num == 0`作为前导零并保持`new_used`为零。
然后进入`dfs(pos + 1, used | (1<<num), new_tight)`。

发现dfs的参数都是可哈希的，并且dfs计算没有依赖dfs外的任何数据结构，所以可以直接加个`@cache`以优化速度。

最后，别忘了以上dfs求的是没有重复数字的数字个数，并且包括了0。
而而题目要求的是反过来的，并且从1开始。
所以返回答案的应该是`n - dfs(0, 0, True) + 1`。

以上。更多细节代码注释。

