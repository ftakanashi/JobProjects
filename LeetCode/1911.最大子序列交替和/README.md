## 题目描述
一个下标从 0 开始的数组的 交替和 定义为 偶数 下标处元素之 和 减去 奇数 下标处元素之 和 。

比方说，数组 [4,2,5,3] 的交替和为 (4 + 5) - (2 + 3) = 4 。
给你一个数组 nums ，请你返回 nums 中任意子序列的 最大交替和 （子序列的下标 重新 从 0 开始编号）。

一个数组的 子序列 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的一个子序列（加粗元素），但是 [2,4,2] 不是。

示例 1：
```
输入：nums = [4,2,5,3]
输出：7
解释：最优子序列为 [4,2,5] ，交替和为 (4 + 5) - 2 = 7 。
```
示例 2：
```
输入：nums = [5,6,7,8]
输出：8
解释：最优子序列为 [8] ，交替和为 8 。
```
示例 3：
```
输入：nums = [6,2,1,2,4,5]
输出：10
解释：最优子序列为 [6,1,5] ，交替和为 (6 + 5) - 1 = 10 。
```

提示：
```
1 <= nums.length <= 105
1 <= nums[i] <= 105
```

### 解法 DP
一道典型的DP题目。而且是近期来少有的没有看任何提示直接自己手撸出来的题目了…

首先考虑DP值的定义。既然原数据是数组，很自然的就想到先用一个长度也为`n`的DP数组。
`dp[i]`定义为以`nums[i]`数字为结尾的某个子序列的交替和。
但是这里也比较容易发现，某个数字结尾时其交替和还和当前选择的序列长度是奇数还是偶数有关。
所以引入一个第二维，`dp[i][0]`表示以`nums[i]`为结尾且子序列长度为奇数（也就是`nums[i]`是加上去的）的情况，`dp[i][1]`则是偶数情况。

然后就是状态转移方程。
不难看出，`dp[i][0]`会依赖于所有`dp[0]`到`dp[i-1]`的值，并且由于`dp[i][0]`子序列长度为奇数，所以依赖于前面长度为偶数的情况。

用代码表示，就是`dp[i][0] = max(row[1] for row in dp[:i]) + nums[i]`。
另一边的`dp[i][1]`也是类似的。

但是直接这么写会超时。毕竟`O(n^2)`了。
这时发现DP值从左到右填充，所以实际上在填充过程中可以实时维护`dp[k][0]`和`dp[k][1]`的最大值。
这样就不用每次计算max函数，于是就AC了。

然后看了下答案发现还是被答案爆了…
其实DP值可以定义为`dp[i][0]`表示前`i`个数字的最大子序列交替和，即不一定要选择`nums[i]`。
此时状态转移方程中分成了，是否选择`nums[i]`的两个分支。
如果选，则和上面类似。
若不选，则直接`dp[i][0] = dp[i-1][0]`就行了。

采取答案的方案的话，完整的状态转移方程就是：
```python
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + nums[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - nums[i])
```

最后，加上`dp[i]`只和`dp[i-1]`有关，直接状态压缩优化。