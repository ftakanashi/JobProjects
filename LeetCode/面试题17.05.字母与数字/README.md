## 题目描述
给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。

返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。

示例 1:
```
输入: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7","H","I","J","K","L","M"]

输出: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7"]
```
示例 2:
```
输入: ["A","A"]

输出: []
```
提示：
```
array.length <= 100000
```

### 解法 前缀和
一开始看到这道题以为得用滑窗来做了。
但是稍微仔细想一下就知道，滑窗很难适用，因为没有一眼就可以确认的右边界伸展和左边界收缩的策略。

于是转而思考前缀和的可能性。
这里由于要统计字母和数字两种类型的情况，所以可以设计前缀和是两个值。
即`presum[i] = [a, b]`表示到下标为止`i`为止，左侧的字母总共有`a`个，数字总共有`b`个。

而一段子数组中字母和数字个数相同，转化成前缀和的背景下，就是指`a - b`的值相同。

于是思路就很明显了。
从左到右遍历的过程中，一边维护前缀和数组，一边维护一个哈希表`diff2pos`用于记录扫描过的所有位置中，`a - b`的值`diff`与该位置下标的对应关系。

这样，当扫描到`presum[i]`时，只需要计算`diff = presum[i][0] - presum[i][1]`，然后看`diff`是否在`diff2pos`中出现过即可。

另外只需要注意一些细节即可。
比如`presum`的初始值是`[0, 0]`，而对应的`diff2pos`的初始值就是`{0: -1}`。

由于题目要求的相同长度时取最左边的值，所以维护哈希表时采取不update的策略。
而收割答案时也要求当前候选长度必须严格大于已有答案时才能更新答案。