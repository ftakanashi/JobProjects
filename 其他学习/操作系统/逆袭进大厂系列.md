>参考资料https://blog.nowcoder.net/zhuanlan/zjby9m
>
>这里记录一些看文章的笔记心得，不是完整记录。完整记录直接戳原链接

### 1
- 每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。

- 协程是用户态的轻量级线程。不会进入内核态。是线程内部的基本调度单位。

### 2
- 同一个进程的线程共享堆、全局变量、静态变量、指针、文件等，但是独自拥有栈

### 3
- 一个进程最多可以创建多少线程主要由内存大小限制。
一般情况下一个进程最大用户态可以用到2G空间（另一种说法是3G）。如果是2G，而每个线程默认又要有1M的栈，所以最多就2048个线程。

### 5
- 每一次进程的调度都由内核发起，本质上是内核选择了相应进程的"进程控制块"，其中包含了所有进程的基本状态信息。

- 进程调度时，内核读取进程控制块中的基本状态信息，然后进行上下文切换。上下文切换本质就是指加载这些信息到当前状态中。

### 6
- 进程调度算法：指站在CPU视角，通过怎样的策略将蜂拥而至的各种进程处理。大概分成以下集中
```text
先来先服务（FCFS）：非抢占式。按请求顺序处理
短作业优先（SJF)：非抢占式。选择时总选择估计运行时间最短的进程处理。
最短剩余时间优先（SRTN）：抢占式，一个新作业到达时，如果其估计运行时间比当前运行中的进程的剩余运行时间更短，则挂起当前进程，优先处理新进程
时间片轮转：非抢占式。固定一个时间片，以FCFS的方式处理，但是每次只处理一个时间片。时间到了之后相应进程放到队列末尾去
优先级调度：为每个进程分配一个优先级，按照优先级进行调配
多级反馈队列：略
```

### 7
- Linux下进程间的通信方式
```text
管道：
    无名管道（内存文件）：数据单向流动，只能在具有亲缘关系的进程间使用（父子、兄弟进程）
    有名管道（FIFO文件，通过文件系统实现）：可双向通信，允许非亲缘进程间通信
共享内存：由某个进程创建，供多个进程访问。是最快的进程间通信（IPC）方式。
消息队列：克服了信号传递信息少，管道只能承载无格式的字节流等缺点
套接字：通常适用于不同机器隔网络的通信，也适用于本地两个进程间的通信
信号：通知一个进程某个事件已经发生的
信号量：注意区别"信号"和"信号量"两个完全不同的概念。信号量本质上是一个带有计数器的锁，但这个计数器的增减都是原子操作。
计数器计的通常是可用资源数量。其用于控制多个进程对共享资源的访问。某种意义上也是进程间通信方式。注意，线程间也可以用信号量控制同步以及互斥访问。
```

### 8
- 同步与互斥
多任务，无论是多进程还是多线程的情况，一般我们都要考虑如下两点问题。
第一，任务有前后顺序关系但工作者不按照这个顺序来做任务。 -> 同步问题
第二，工作者同时对同一资源读写，造成混乱 -> 互斥问题

- Linux的同步机制
```text
POSIX信号量: 可用于进程间或者线程间同步
POSIX互斥锁+条件变量：仅可用于线程间同步
```

### 12
- 虚拟技术指将一个物理实体转化成多个逻辑实体的计数。主要分成时分复用的虚拟和空分复用的虚拟。
时分的典型例子是多进程&多线程。
空分的典型例子是虚拟内存。虚拟内存是将进程地址空间的页映射到物理内存中。当要使用某些页但其并非真的存在于物理内存中时，就通过页面置换算法，
将其从虚拟内存置换到物理内存中。

### 13
进程主要三大状态是就绪、运行、阻塞。
就绪和运行之间可以互相转换。通过调度算法获得CPU时间后，就绪->运行；CPU时间用完后，运行->就绪。
和阻塞相关的转化都是单向的。运行->阻塞，因为有I/O或者事件等待；阻塞->就绪，因为I/O或者事件完成。

### 15
- 操作系统通过页为单位管理内存。在一个进程的地址空间内，存在很多很多页，这些页是逻辑的。
进程内部维护一个页表，记录逻辑页和物理页之间的对应关系。
通过得知逻辑页对应物理页以及逻辑页内偏移量，可以得到物理地址。

### 16
- 临界资源指一次只能被一个进程/线程使用的资源。比如打印机，磁带机等。
临界区指代码中要使用临界资源的部分。为了保证互斥，同一时刻只能有一个worker进入临界区工作。

- 信号量是一个带计数器的锁。每当信号量减小到0，进程/线程就会被挂起。
增减操作被设计成原子操作因此不会在增减本身的时候出现矛盾。

- 如果信号量取值被限制只能取0或1，那么这也叫互斥量(Mutex)。 -> 这就是一个简单的锁了。

### 17
针对内存，操作系统需要
- 控制内存的分配与回收
- 可以从逻辑上对内存进行扩充
- 提供逻辑地址和物理地址相互转换的计算
- 提供内存保护，保证各个进程之间互不干扰

### 18
Linux进程间通信方法包括信号、信号量、无名/有名管道、消息队列、共享内存、Socket。
线程间通信方法包括信号、条件变量(Condition)、锁(Lock)、信号量(Semaphore)。

>关于几种不同类型的锁：自旋锁、互斥锁、条件变量锁、读写锁：
>
>https://www.zhihu.com/question/66733477/answer/246535792

### 19
注意上面说的进程间通信用到的比如信号量、共享内存、消息队列等，都不是第三方组件。总不能没装第三方组件就不能进程间通信了吧。
因为进程由操作系统统一管理，所以这些东西都由操作系统自身实现。

`ipcs`命令可以看到各项进程间通信载体的使用情况。

### 20
虚拟内存只能解决内存够不够，但不能解决内存快不快。甚至因为要进行页的切换操作，肯定是更慢的。

### 24
各种锁：（本质上是各种信号量）
```text
自旋锁：如果进线程无法获得锁，就一直循环尝试获取锁。若一个进线程长期占有锁，其他人尝试获取锁的过程将耗费大量CPU无用功。
互斥锁：在一个进线程无法获取锁的时候，直接将其挂起，直到锁被释放。由于挂起该进线程，让出CPU给其他任务时涉及到运行状态的改变，所以互斥锁由操作系统自己管理。
条件变量：带有条件的锁。当条件变量不符合某个进线程要求时，该进线程被挂起。同时如果某个进线程改变了条件变量，那么同时会去唤醒一个或多个当前
变量符合要求的进线程
读写锁：多个读者可以同时读，写者必须互斥。写者总是优先于读者。
```

### 27&28
- 内存覆盖：一个进程不会每个时刻都要访问所有它所有的数据。内存覆盖机制是将进程的地址空间划分为固定区和覆盖区。
将一些比较常用的数据放入固定区快速取用，而不常用的放在外存，每当要使用时再读入内存。虽然工序上多了，但是可以避免一次性读入所有数据进内存耗费内存空间。
- 内存交换：内存空间比较紧张时，将一些正在等待的进程对应的内存页交换到外存，腾出空间给需要的其他进程。是进程在内存和磁盘间的动态调度。

### 35
- 孤儿进程：一个进程退出了但是其子进程还在运行，此时这些子进程会被过继到PID是1的init进程下，这些进程也被称为孤儿进程。
- 僵尸进程：通常子进程退出后需要将其一些信息比如退出状态，pid等提供给父进程。这个过程会在父进程调用wait方法后发生。在子进程已经结束但是父进程
还未调用wait前，这段时间的子进程处于僵尸状态。如果父进程因为一些问题无法再调用wait，为了避免浪费pid资源，可以直接杀了父进程。此时僵尸进程变成
孤儿进程，由init接管，init后续调用wait将其释放。

### 40
- 中断：最初是由硬件设备发出的物理信号，传达给CPU之后，CPU再将其通知操作系统的内核，由内核执行中断操作
- 异常：与硬件无关，而是在CPU执行指令的过程中发生意想不到的情况，此时将之发送给内核，由内核执行异常处理

在操作系统的层面，中断和异常通常通过同一个流程来处理。但是究其根本，两者发起者不同。一个是硬件主动发出的信号，另一个是CPU执行指令时发生的错误。

### 41&42&43
进程的内存分布：Linux中地址从小到大分别是
```text
程序文件
已初始化的数据
未初始化的数据
堆
文件映射
栈（栈的使用，地址从高往低走）
内核空间（后1/4）
```
栈空间一般是固定大小的。默认Linux中的栈空间是8M大 ，可以通过`ulimit`命令查看、修改。

### 44
从堆中动态分配内存时，如果有需要可以将实际的空间划在磁盘上，而通过页表（PTE，维护内存和虚拟内存之间页对应关系）将这个对应关系维护进去。

### 46
Swap会在物理内存被塞满时使用。系统将物理内存中一些不活跃的页换到swap中，腾出空间来。
狭义的虚拟内存指windows上的磁盘空间内存化技术。

### 49
常见的内存分配方式。
(1)从静态区域分配，通常在编译的时候就分配好，用于存储全局变量，静态变量等。这些内容在整个运行期间都稳定存在
(2)从栈上创建，由CPU指令集直接执行。用于存放局部变量等。因为CPU直接执行，速度很快，但是通常能分配的空间很小
(3)从堆上分配，程序员自己用代码申请内存，并且可以自己释放内存。内存有效期可以自定义，很灵活。

### 52
发生内存交换时，可以优先换出属于以下类型的进程的页
- 优先级低的进程
- 阻塞的进程
- 在内存中已驻留时间不长的进程

注.进程地址空间的内核空间中有PCB即进程控制块，包含了进程最重要的信息。这部分不会被换出去。

### 53
```text
ASCII码是最早的，用一个字节表示人类语言字符的编码。因为只有一个字节，所以只能表示127个字符。
英语还好说，如果是中文，127个肯定不够用。因此中文有一套自己的编码系统，用两个字节表示一个常用汉字，形成了GB2312系列编码。其他语言也有类似的解决方案。

因为每种语言都出现了自己的编码，为了多语言软件的方便，推出了Unicode作为统一标准。
Unicode规定两个字节(16位)表示一个字符。这样全世界都可以统一用一套编码系统了。
但是这样又出现了一个问题，统一是统一了，但是像英语这种，若将纯英语文本从ASCII编码变成Unicode编码，占用空间将增加一倍，不合适。

为了解决上述问题，UTF-8出现了。这是一个可变长的编码。对于英文字母，它采用ASCII方案，一个字节一个字符。而对于汉字，通常在UTF-8中被编码成三个字节。
而UTF-8最多支持到6个字节的编码。这样一来就很灵活了。
```

```text
在知道上述编码的由来之后看哪里使用什么编码。
首先，内存相对较大，所以不那么计较一点大小，因此现代计算机规定了在内存中统一使用unicode对人类语言的字符进行编码。

但是在碰到要将文本数据进行传输的时候或者保存的时候，通常选用UTF系列编码比较好。
因此在保存、传输前，内存中数据会从Unicode转化到UTF-8；同理，在读取、接收数据后，会将数据从UTF-8转化到Unicode再加载进内存。
包括Python中的print也是类似，需要注意。
```

### 56
- 并发：指宏观上一段时间内可以同时运行多个程序。一般采用时分虚拟化技术得到的系统都是并发系统
- 并行：指同一时刻真的有多个指令在运行。通常需要硬件支持比如多核处理器，分布式计算系统等。

### 59
死锁的形成条件有以下四个
1. 互斥条件：进程不能使用已经被其他进程使用的资源
2. 不剥夺条件：进程正在使用的资源只能自己释放，不会被其他进程抢走
3. 请求和保持条件：进程当前持有的资源在其请求其他新资源时，仍然由自己占用
4. 循环等待条件：多个进程间形成一种进程资源循环等待链。这个链中每个进程都持有一些资源which被链条中的下个进程所请求。

死锁的一般处理策略是鸵鸟策略：因为死锁发生概率不大，所以与其想办法花费时间和精力解决它，不如不管他。。

死锁检测：
各个进程和进程持有的资源是节点，互相请求/持有的关系是边，这样就形成一个图。
当这个图有环时，就是死锁了。因此通过一个DFS或者BFS探索图，就可以检测出死锁。

死锁恢复：
- 利用抢占恢复（允许资源抢占，打破不剥夺和请求保持条件）
- 利用回滚恢复
- 通过杀死进程恢复（打破图里的环）

死锁预防（特指所有进程运行前的措施）：
1. 破坏互斥条件：允许若干个进程同时使用一个资源。通常可以再资源外部包一层管理壳。
2. 破坏不剥夺条件：允许抢占资源
3. 破坏请求保持条件：规定进程必须在开始前就申请所有需要的资源
4. 破坏循环请求等待：给资源编号，进程只能按编号顺序请求资源

