# 【旧】~~容器与虚拟机~~

容器和虚拟机都是用来做环境隔离的基本单位。通常我们都把容器看做一种轻型的虚拟机，因为容器和虚拟机的架构区别如下：

![img](https://upload-images.jianshu.io/upload_images/12979420-a562cd670f2b8b02?imageMogr2/auto-orient/strip|imageView2/2/w/529/format/webp)

不论是用什么隔离体系，最终我们的目的都是要让程序利用硬件进行计算。而利用硬件都要通过操作系统内核。
这里，虚拟机的做法，是带起一个自己的操作系统，通过自身操作系统的内核去访问硬件。而硬件本身也不是直接暴露给虚拟机OS，而是通过虚拟机管理软件，即上图中的hypervisor进行了虚拟化。
另一方面，容器的做法是所有容器共享宿主机操作系统的内核，从而访问硬件。因此容器内部不需要自己的OS。容器通过Docker Engine管理程序与宿主机OS内核打交道。

开启一个新虚拟机时，需要加载庞大的虚拟机的操作系统，同时虚拟机运行时其操作系统肯定也要运行，因此会占据较多的CPU、内存资源。
而启动一个容器很快，往往只要几毫秒即可。容器通过Namespace技术将不同容器的各种资源隔离开，但由于容器专注于应用代码本身，没有多余的操作系统等，因此占用资源也不多。

# 容器

> 容器这个概念的出现其实比Docker要早。基于Linux内部的一些技术如Namespace以及Cgroup等，可以实现进程之间运行环境的隔离，就是容器。由于基于Linux实现，也称Linux Container，简称LXC。
>
> 而Docker只不过是在外围开发了更多功能，让容器在工业上得以方便快速地应用。

## 容器与虚拟机

我们经常把容器看做是一个轻型虚拟机。一句话来解释两者的区别：
虚拟机从操作系统层面开始虚拟化。虚拟机管理软件对硬件资源进行虚拟化并提供给虚拟机使用。
容器则是从运行环境层面进行虚拟化， 容器管理软件如Docker引擎对操作系统直接进行虚拟化并提供给容器使用，换言之多个容器共用同一个操作系统内核。

如图：

![img](https://upload-images.jianshu.io/upload_images/12979420-a562cd670f2b8b02?imageMogr2/auto-orient/strip|imageView2/2/w/529/format/webp)

由于架构上的不同，容器和虚拟机在运行使用上差别也很大：

| 比较点           | 虚拟机                                                       | 容器                                                         |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 系统资源利用效率 | 低，因为要额外运行维护一个OS，相当一部分资源被浪费在非核心任务上 | 高                                                           |
| 启动时间         | 慢                                                           | 快，容器启动只需利用内核做好环境隔离与资源限制即可启动，无需启动操作系统 |
| 隔离性           | 高，完全的OS级别的隔离                                       | 低，有些共通的东西无法隔离                                   |

而结合Docker实现的其他技术，容器还具有易迁移、易维护扩展等特性。下面细说。

上面描述看起来容器好像吊打VM。但是实际上两者并不是哪个更先进，而只是两个各有用途的东西。
比如容器因为没有虚拟化OS，所以容器依赖于宿主机的OS内核。若我想在Linux上跑Windows的程序，那么显然容器是无论如何也做不到了，这时候还是得使用VM从OS层面进行虚拟化。

## ⭐️虚拟化技术

因为容器共享一个OS，可以想象，==容器的本质应该就是一个OS上的特殊进程而已。而这个进程的目的，是为其下属的子进程们，提供一个独立的运行环境==。那么怎么样才算独立的运行环境？大概要实现下面两个维度的隔离：

- 文件系统的隔离。如`chroot`命令或者配置sftp服务器时那样，可以让某个进程的可以看见的最上层根目录是实际系统中某个非根目录，从而限制了该进程能访问的文件系统的范围。
- 资源隔离。资源隔离又分两个角度来看。一是资源可视性，不同进程能够看到的资源不同，看不到的自然就使用不了；二是资源限制，对进程可以使用的资源，能让他使用多少。

==Docker通过了UnionFS技术实现了容器间的文件系统的隔离。又用了Namespace和Cgroup技术分别实现了资源隔离的上述两个角度。
除了这三个，还通过容器引擎，实现了对容器的综合管理。==
以上提到的四大技术，就是Docker核心的四个虚拟化技术了。下面来细说。

### Cgroup

> https://zhuanlan.zhihu.com/p/127312824

Cgroup最初的设计目的，是先将进程分组，然后将各个不同组的进程可以使用的资源进行限制，限制的角度包括CPU使用个数/使用率、内存使用空间/使用率、IO吞吐量、带宽等等。由于容器本质上是一个特殊的进程及其所有子进程。那么将这些视为一个进程组并通过Cgroup加以限制，就可以做到Docker的通过Cgroup对资源使用进行限制的目的。

一般而言，有了限制，我们肯定期望其在超出限制的时候做一些事情，因此Cgroup还具有 监控进程组的资源使用情况 以及 对进程组做出控制操作如挂起、重启等。

Cgroup中一个重要的概念称为子系统。不同的子系统对不同种类的资源作出限制。
每个子系统都对应到系统中某个目录文件下，通常是`/sys/fs/cgroup/`中的一些目录。可以通过`mount -t cgroup`命令进行查看。
子系统列表如下：

<img src="https://img2020.cnblogs.com/blog/1977753/202004/1977753-20200412224046852-870716976.png" alt="img" style="zoom:50%;" />

#### docker容器与Cgroup的关联性

以cpu子系统为例，该子系统位于`/sys/fs/cgroup/cpu`。如果服务器装了docker，其中会有一个名为docker的子目录。代表其中维护这docker子组的一些信息。

如果有正在运行的容器，则docker子目录下还会有容器ID作为名称的子目录，代表其中维护着docker子组下的该容器子组的一些信息，也就是容器内所有进程形成的组了。
其中的各个文件则是这个子系统用来进行资源控制的参数内容。这些文件不是真实存在磁盘上的，因此大小是0。其中有个叫做`tasks`的文件保存了这个进程组内（容器内）所有进程映射到宿主机上的PID，算是指出了这个进程组的范围吧。

```
# 在 /sys/fs/cgroup/cpu/docker/ee61...(容器名) 中
-rw-r--r-- 1 root root 0  8月 14 21:38 cgroup.clone_children
-rw-r--r-- 1 root root 0  8月 15 15:55 cgroup.procs
-rw-r--r-- 1 root root 0  8月 14 21:38 cpu.cfs_period_us
-rw-r--r-- 1 root root 0  8月 14 21:38 cpu.cfs_quota_us
-rw-r--r-- 1 root root 0  8月 14 21:38 cpu.shares
-r--r--r-- 1 root root 0  8月 14 21:38 cpu.stat
-r--r--r-- 1 root root 0  8月 14 21:38 cpuacct.stat
-rw-r--r-- 1 root root 0  8月 14 21:38 cpuacct.usage
-r--r--r-- 1 root root 0  8月 14 21:38 cpuacct.usage_all
-r--r--r-- 1 root root 0  8月 14 21:38 cpuacct.usage_percpu
-r--r--r-- 1 root root 0  8月 14 21:38 cpuacct.usage_percpu_sys
-r--r--r-- 1 root root 0  8月 14 21:38 cpuacct.usage_percpu_user
-r--r--r-- 1 root root 0  8月 14 21:38 cpuacct.usage_sys
-r--r--r-- 1 root root 0  8月 14 21:38 cpuacct.usage_user
-rw-r--r-- 1 root root 0  8月 14 21:38 notify_on_release
-rw-r--r-- 1 root root 0  8月 14 21:38 tasks
```

举个实操例子，比如`cpu.cfs_period_us`是对CPU整体使用率限制的参数，默认是`100000`，表示100000个单位。如果将其改成`10000`，那么再去容器中开启CPU密集进程，此时会发现，其CPU使用率最大最大不会超过10%，这也就是Cgroup在起作用了。

#### 【旧】~~Cgroup具体机制与使用~~

Cgroup机制中有以下这些比较重要的概念。

- 进程（task），或者叫任务，即系统中的一个进程。
- 控制组（control group），按照某种标准划分的进程组，指出了限定量的系统资源供组内进程使用。
- 层级（hierarchy），多个控制组之间以层级的方式组织。可以将其理解为一棵树，子控制组会继承父进程组的一些属性。
- 子系统（subsystem），子系统指出一类特定的需要控制的系统资源。将一个子系统attach到某个层级上后，该层级（树）中所有控制组使用子系统相关资源时都会受到其限制。

上述概念有如下逻辑关系

- 进程，即使在开始运行后，也可以根据需要被移动到不同的控制组。
- 父进程创建子进程时，子进程自动被加入到父进程所属的控制组中。后续子进程可以根据需要再被移动到其他组里。
- 一个进程可以是多个控制组的成员，但这多个控制组必须分属于不同的层级。
- 一个层级可以被attach多个子系统，一个子系统最多只能attach到一个层级。

## Namespace

Namespace也是Linux内核自带的一个机制。Namespace的基本生效单位是进程。==其作用是，将原来一个整体的系统（比如网络资源、用户系统、进程系统等），分成若干个互相独立的部分，使互相的进程之间不影响对方==。换言之，一个进程只能感知到相同Namespace下的其他进程，而不能感知到以外的。

Linux内核中实现的Namespace总共有下面这几种：

| Namespace | 作用                                    |
| --------- | --------------------------------------- |
| IPC       | 隔离进程通信的共享内存以POSIX消息队列等 |
| Network   | 隔离网络资源                            |
| Mount     | 隔离文件系统挂载点，即文件系统隔离      |
| PID       | 隔离进程PID，即隔离进程系统             |
| UTS       | 隔离主机以及域名                        |
| User      | 隔离用户以及用户组，即隔离用户系统      |

一个进程可以同时属于若干个不同类型的Namespace。对于多个同一类型的Namespace，一个进程只能从属于其中的一个。
以上这些进程 - Namespace的对应关系，可以在`/proc/<pid>/ns`中查看，如：

```
lrwxrwxrwx 1 root root 0  8月 15 17:09 cgroup -> 'cgroup:[4026531835]'
lrwxrwxrwx 1 root root 0  8月 15 17:09 ipc -> 'ipc:[4026533159]'
lrwxrwxrwx 1 root root 0  8月 15 17:09 mnt -> 'mnt:[4026533157]'
lrwxrwxrwx 1 root root 0  8月 15 17:09 net -> 'net:[4026533162]'
lrwxrwxrwx 1 root root 0  8月 15 17:09 pid -> 'pid:[4026533160]'
lrwxrwxrwx 1 root root 0  8月 15 17:09 pid_for_children -> 'pid:[4026533160]'
lrwxrwxrwx 1 root root 0  8月 15 17:09 user -> 'user:[4026531837]'
lrwxrwxrwx 1 root root 0  8月 15 17:09 uts -> 'uts:[4026533158]'
```

软链指向内容括号中的数字是具体的Namespace编号。不同进程若指向的编号一样，那么就是指他们俩在同一个Namespace中。

至于Docker容器，显然每个容器都应该拥有独立的一套上述各种类型的Namespace，因此，容器启动时就会初始化一套上面所有的Namespace供容器中的进程使用。

需要指出，==Namespace机制从进程系统、网络系统、用户系统等角度做到了一定程度的资源隔离，但是也有一些资源没能隔离。比如时间，当某个容器修改了容器内部的时间，由于对时间并没有隔离，所以会导致宿主机以及其他容器也一并被改变。==

## UnionFS

> https://zhuanlan.zhihu.com/p/115659428

在Linux启动的时候，初始化文件系统时，最开始会建立一个叫做rootfs的文件系统。这个系统内容与磁盘中整个文件系统一样，但是只有读权限。之后，Linux会将rootfs的权限修改为读写，于是文件系统初始化就完成了。

而在Docker中借鉴了类似的思路。第一步先启动挂载一个只读的rootfs，这个文件系统内包含的是镜像的文件内容。之后，和Linux不同的是，容器中的rootfs一直保持只读状态，在此基础上容器内部新创建一个空的读写的文件系统。==只读部分的rootfs和可读写部分的文件系统，共同组成了联合文件系统，即UnionFS。==

<img src="/Users/wyzypa/Pictures/TyporaImages/Docker相关笔记.asset/image-20210722110433707.png" alt="image-20210722110433707" style="zoom:50%;" />

### UnionFS中的层

Docker中的镜像（也就是上图中的rootfs部分）基于层的概念进行构建。层可以简单理解为增量内容。一个镜像，从最基础的只包含最最基本的那些系统组件的状态，加入各种东西到适应各种应用场景的状态，中间每加一次东西，那些==**新增的**==，就会被以层的形式记录。

具体的层的实现方式等与Docker使用的存储驱动形式有关。按照较新的Overlay2为例。
在存储驱动的安装目录（默认是`/var/lib/docker/overlay2`）中，我们可以发现很多代表着一个个层的目录。而每个层目录下面都会有一些类似的子目录or文件，含义如下：

- `diff`子目录：==用于保存相比于所有下级的层，该层独有的文件（指新增的或者修改过的），并且维护的是这个文件的完整路径。==
- `lower`文件：以特定的格式记录了该层下方所有层的顺序关系。这部分内容中，层以短名展示。
- `link`文件：一个指向短名链接（位于overlay2下的`l`目录中）的软链接。

如上所述，每个层的目录名是一个一长串由16进制数组成的东西，这也是该层的一个代号，我叫他长名。与之相对的，为了展示起来好看一些，还有一个短名。比如上述的`lower`中都是用短名表示层。
长名和短名的对应关系在`overlay2/l`目录下维护。同时层内的`link`也是指向了这里面相应的短名链接。

![](https://pic4.zhimg.com/80/v2-f522452ff1c111dae6bc564e5b56f0b7_720w.jpg)

### 镜像层和容器层

如上所说，rootfs部分其实是对应了镜像，而镜像又是由层构成的，这些层称为镜像层。由于rootfs只读，所以可以说镜像层是只读的层。
另一方面，可读写部分的FS也是由层构成，但由于其可读写，为了区别，我们可以不严谨地称之为容器层。

用镜像启动一个容器后，再观察`overlay2`目录，会发现多了两个层。一个是名为`xxx`的容器层，另一个是名为`xxx-init`的容器init层。
看下两者的lower就可以知道，容器层位于容器init层上面，而init层下面才是镜像层们。
顶层容器层很好理解，是一个可读写的层。而init层其实是docker内部自动创建的一个，维护了镜像层中原来的`/etc/hosts`，`/etc/resolv.conf`等文件的层。创建这个层的目的，是因为启动容器时这些文件八成会被修改，要留个备份。

### 层的读与写

上面我们说了，==每个层的`diff`中其实只保存了相比之前新增的文件==。而多个层合在一起能够构建出一个镜像。那么如果相比于之前版本镜像，我删除或者修改了文件该怎么办？这就牵扯到了在Docker中，层的读写的规则。

读的问题很简单，如上所述，镜像层也是可读的。所以文件存在于镜像层就从镜像层读，当文件存在于容器层就从容器层读，若文件存在于两类层，则直接读取容器层，相当于屏蔽了镜像层的文件。总原则就是，高的层优先于低的层。（至于为什么会有一个文件在两种层的情况，下面细说

写的问题略复杂一些。以修改一个文件内容为例，试想，假如某个文件不存在于容器层，只存在于镜像层中，由于镜像层只读，肯定不能直接改。
实际上，Docker会将容器从镜像层复制到容器层，然后修改容器层的副本。这也是上面提到过的，一个文件在两种层的情况。此时很明显，为了让容器使用者能够获得最新的版本，这里肯定直接读取容器层，符合上述读的规则。

写还有更细节的，比如除了修改文件，删除文件怎么办，删除目录怎么办，修改文件名怎么办，等等。对于层的读写规则，总结如下：

- 读
  - 文件位于容器层中，直接读容器层（若镜像层中也有同名文件，则其被屏蔽
  - 文件只位于镜像层中，则直接读镜像层
- 写（修改文件）
  - 文件位于容器层中，直接修改容器层
  - ==文件只位于镜像层中，将其完整复制到容器层，并在容器层修改==
- 写（删除文件/目录）
  - 文件/目录只位于容器层中，直接删除即可
  - ==文件/目录还位于镜像层中，无论其是否存在于容器层中，都会在容器层的相关路径下创建一个同名的dummy标记（若存在于容器层，则先删除再创建标记）。文件的标记称为whiteout文件，目录的标记称为opaque目录。==这两个东西，直接到`overlay2`中的层的目录下去`ls`可以看到，但是`cat`等操作无法读取，并且在容器中，由于这两者的特殊形式，引擎不会显示之，从而在容器使用者看来，觉得文件被删除了。
- 写（重命名）
  - 重命名基本视为 删除 + 新建 两步走。
  - 有些资料指出重命名目录时，只有原路径和目标路径都在容器层中才能成功。但是做了下实验并不是啊…

#### 对挂载卷的读写

稍微再多提一句。挂载卷的原理，是创建一个宿主机和容器进程能共同使用的文件系统。因为独立与UnionFS，所以在容器内部对挂载卷进行读写就是直接对磁盘进行读写。
另一方面，如果挂载卷内容被添加到镜像中，基于镜像启动容器，再到容器中修改相关文件，显然要遵循UnionFS的规则，即先把文件复制到容器层，再在容器层做修改。显然后者的效率以及开销比前者大。

# ⭐️容器的网络模式

> https://www.jianshu.com/p/22a7032bb7bd

docker容器总共有四种网络模式

| 网络模式           | 命令                      | 描述                                                         |
| ------------------ | ------------------------- | ------------------------------------------------------------ |
| host模式           | -net=host                 | 容器与宿主机共享网络Namespace                                |
| container模式      | -net=container:NAME_OR_ID | 容器与其他容器共享网络Namespace，如k8s的一个pod内的容器就是container模式，互相共享网络namespace |
| none模式           | -net=none                 | 容器自身有独立的网络Namespace，但需要手动对其进行配置        |
| 【默认】bridge模式 | -net=bridge               | 容器自身有独立的网络Namespace，将其通过一个宿主机统一指定的网关接入一个docker子网络。类似虚拟机的桥接模式。 |

- bridge模式（默认）
  
默认情况下，docker采用bridge模式进行容器网络配置。docker主进程启动时，虚拟一个叫做docker0的网卡，并以此建立一个docker子网。
  之后每个容器建立时，都从这个子网中分得一个IP。宿主机内的所有容器都处于该子网中。容器间通信时，docker0被视作交换机进行通信中继服务，容器向外网访问时，则将宿主机视作网关路由器进行访问。

  <img src="https://upload-images.jianshu.io/upload_images/13618762-f1643a51d313a889.png?imageMogr2/auto-orient/strip|imageView2/2/w/1083/format/webp" alt="img" style="zoom:50%;" />

- host模式
  
==通过host模式建立的容器，其进程、文件系统等用Namespace等技术和宿主机隔离开，但是不进行网络的隔离==。由于容器本身就是一个进程而已，所以其可以和宿主机的任何进程一样使用宿主机的网卡。换言之，如果docker容器监听端口，那么是直接在宿主机IP上监听，外部访问这个端口也就访问了容器内部；反过来，容器内部也可以利用宿主机的IP访问外部网络。
  
==host模式可以最大限度地提升网络传输效率，并且配置直接方便，但是安全性、隔离性方面不好。==
  
<img src="https://upload-images.jianshu.io/upload_images/13618762-a892da42b8ff9342.png?imageMogr2/auto-orient/strip|imageView2/2/w/698/format/webp" alt="img" style="zoom:50%;" />
  
- container模式
  ==container模式下，容器建立时需要指定另一个已经配置好网络的容器。新容器与该容器共享网络Namespace。==通常被指定的这个容器是桥接模式的，即处于宿主机建立的docker0网络中。新容器可以通过该容器的IP与外界交互信息。而两个容器之间通信则可以通过local网卡进行。

  显然，此时新容器与既存容器形成一个容器集群。因此k8s等集群服务中采用这种模式。

  ==与桥接模式的子网不同，container模式的子网的网关是一个容器，而不是宿主机本身。==

  <img src="https://upload-images.jianshu.io/upload_images/13618762-790a69a562a5b358.png?imageMogr2/auto-orient/strip|imageView2/2/w/695/format/webp" alt="img" style="zoom:50%;" />
  
- none模式
  none模式下建立起的新容器，只有一个lo网卡。即在网络上其不与宿主机或其他容器有关联。可以通过手动配置进行关联。

  none模式可以保证容器在网络方面的绝对安全和绝对隔离。

  <img src="https://upload-images.jianshu.io/upload_images/13618762-3fd41778faebcef5.png?imageMogr2/auto-orient/strip|imageView2/2/w/723/format/webp" alt="img" style="zoom:50%;" />



# 镜像

> https://zhuanlan.zhihu.com/p/92802421

## 镜像原理

本来想把镜像的层等概念的介绍放在这里，不过上章全讲完了。正如上所述，镜像本质上是一个个层的堆叠。每个层保存的是增量信息，其好处很多，比如我有一个`v1.0`的镜像，现在我想要拉`v1.1`镜像用，`1.1`与`1.0`相比，肯定差别没那么大，所以其实大多数层都可以共用，我可以用很少的时间，把增量层拉过来，就构建起了`v1.1`的镜像了。

镜像相关的命令就不多说了。总的入口是`docker images`和`docker image`。

## Dockerfile

Dockerfile是一个文本文件，但是其内写了一行行用于构建docker镜像的指令。
这里，构建是指基于一个基础镜像，再加上自己想要往里加的内容、配置、挂载卷、进入点等。通过命令`docker build`可以根据指定Dockerfile的指令构建镜像。

使用Dockerfile进行镜像构建时，每一条指令都会建立一个新的层，不论这个指令是否引入了新的文件。

常用的Dockerfile中的指令包括

| 指令                                      | 说明                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| FROM 基础镜像                             | 指出该Dockerfile基于的基础镜像是什么                         |
| RUN 命令 或者 [命令, 参数1, 参数2, ...]   | 构建镜像过程中执行一些命令                                   |
| COPY [--chown=user:group] 源路径 目标路径 | 将本地某文件复制到镜像中                                     |
| ADD [--chown=user:group] 源路径 目标路径  | 将本地或者远程的文件复制到镜像中，如果文件是tar包还会自动解包 |
| ENV key1=value1 key2=value2 ...           | 设置镜像中的环境变量                                         |
| WORKDIR dir                               | 指定工作目录（必须是提前创建好的                             |
| USER user                                 | 切换执行后续命令的用户（必须是提前创建好的                   |
| CMD 命令 或者 [命令, 参数1, 参数2, ...]   | 指出 构建镜像完成后，用这个镜像启动容器时，启动的命令。即`docker run xxx(一堆参数) bash`里的那个`bash`。另，若`docker run`命令后面手动写了启动命令，那么以那个为准，CMD作废。<br />如果Dockerfile中有多个CMD，以最后一个为准。 |
| ENTRYPOINT [命令, 参数1, 参数2, ...]      | 和CMD很类似，只是<br />1. ENTRYPOINT指出的命令不会被`docker run`手动写的命令覆盖，而是将手动写的部分当做参数附加在ENTRYPOINT的后面。<br />2. ENTRYPOINT常和CMD结合起来使用。ENTRYPOINT作为固定参数，CMD指出动态参数 |

### 几个指令的辨析

- COPY和ADD

  两者区别在于COPY是只能将本地已有的文件拷贝到镜像中，而ADD可以添加远程URL指向的文件。
  此外ADD命令还能自动解开`.tar`文件。

- RUN和CMD

  RUN提示的命令是创建镜像时运行的，而CMD提示的命令是创建完镜像后，基于镜像启容器时运行的进入点命令。CMD常常和ENTRYPOINT配合起来使用。

- ENTRYPOINT和CMD
  1. ENTRYPOINT无法被`docker run`手动输入的命令覆盖，而CMD可以
  2. ENTRYPOINT用于指出定参，常和CMD配合来拼接命令。比如ENTRYPOINT写`["nginx", "-c"]`，而后CMD写`/etc/nginx.conf`之类的。结合起来就变成了完整命令`nginx -c /etc/nginx.conf`。
     CMD在不带ENTRYPOINT的时候，默认用`sh -c`作为前缀来执行相关命令。

# 【TODO】K8S

> https://blog.csdn.net/u012140251/article/details/114646671
>
> https://blog.csdn.net/u012140251/article/details/115294353



# 其他

## 关于数据卷

我们知道启动容器时`-v`参数可以绑定宿主机目录与容器内目录，即挂载数据卷。

`-v`参数的值中可以最后再加上`:ro`或者`:rw`这两个flag，分别标识只读挂载卷和读写挂载卷。如`-v test_con:/home/back:/root:ro`。

当有容器A挂载了若干个数据卷，此时通过`docker run`启动容器B，可以指定参数`--volumns-from A`来挂载和A中一模一样的几个数据卷。
在创建很多容器进行容器集群创建的时候，给所有容器都加上这个参数，便可以让多个容器有共同的挂载卷。==这也是一种实现容器间通信的办法==。

在容器内，写入挂载卷和写入非挂载卷目录的性能是有区别的。
写入挂载卷，由于和宿主机的目录直接同步，因此会直接写磁盘。
写入非挂载卷目录，根据上面说过的 rootfs + 可读写fs 的架构，首先要将相关文件从rootfs中复制到可读写fs中，再进行修改。因此步骤比直接写挂载卷多，因此性能稍差一些。