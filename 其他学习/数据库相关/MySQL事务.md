# 事务

## 事务的ACID四大特性
- 原子性：事务中包含的操作要么全部执行，要么全部回滚

- 一致性：事务执行前和执行后，无论成功与否，数据库内数据都是满足一致性的。
这点有点抽象，可以类比银行转账。A，B账户分别有800，200元。此时是初始化状态默认满足一致性。
A发起转账200到B，于是执行这个事务。这个事务包括A-200和B+200两个操作。
两个操作完成后，事务完成。此时A，B分别有600，400元。加起来仍然是1000，与原来一致。说明仍然满足一致性。
相反如果出账成功并且入账失败，总金额数与原来不一致，就不满足一致性了。

- 隔离性：若多个事务并行运行，某个事务发起的改变在最终生效之前，其做的改动对其他事务是不可见的。
这样避免了多事务同时执行时起冲突。
隔离性通过数据库的事务隔离机制实现。事务隔离有各种不同的级别。设置级别不同，隔离性的强度自然也不同。

- 持久性(Durability)：事务一旦提交，其做的改变将永久保存于数据库中。

## 事务隔离级别
从低到高依次为：
- 未提交读：即使事务A提交前，其修改对事务B可见。这也相当于没有任何隔离

- 提交读（Read Committed）：只有事务A提交后，其修改才对事务B可见。

- 可重复读 (Repeatable Read)：在事务B的生命周期内，一切读的结果都遵照第一次读到的结果，即A提交前的老版本。
因为解决了A提交前后读两次会数据不一致的问题，所以这个级别也叫"可重复读"。

- 串行化：最高级别，将所有事务串行化执行。能够杜绝所有因为并行发生的问题，但是效率低。

## 事务并发一致性问题与隔离级别的关系
事务并发时，由于一致性可能会产生如下问题：
- 脏读：A事务修改后B事务读到修改后的数据，而后A事务回滚了。导致B事务读到的是脏数据。
- 不可重复读：A事务修改数据时，修改前B事务读到一个值，修改后B事务又可以读到一个值。两个值不一致的问题成为不可重复读。
- 幻读：A事务试图插入一行新数据或者删除数据时，在RC隔离级别下操作前后B事务分别会可以读到两批不一致的数据，在RR级别下操作前后虽然能读到一致的数据（这和RR级别下的read view生成时机有关，参考MySQL锁那篇。），但是如果进行写操作，此时要进行当前读，读到最新的数据，此时就和读到的数据行数不匹配。总之不管在RC还是RR下，都存在幻读的问题。**而在RR下，只有当操作有快照读也有当前读的时候，才会发生幻读问题。**

上面提到的事务隔离级别从低到高，可以逐渐解决这几个问题。具体的对应关系是这样的：

| 隔离级别       | 可解决问题             |
| -------------- | ---------------------- |
| 未提交读       | 无                     |
| 已提交读（RC） | 脏读                   |
| 可重复读（RR)  | 脏读、不可重复读       |
| 串行化         | 脏读、不可重复读、幻读 |

默认情况下，InnoDB的隔离级别是不可重复读。

四个级别中，已提交读和可重复读可以通过MVCC实现。串行化可以通过锁实现。

查看当前数据库的事务隔离级别命令是：
```sql
SELECT @@tx_isolation;
```
设置事务隔离级别的命令是：
```sql
SET TRANSACTION ISOLATION LEVEL xxx;
```

## MVCC(多版本并发控制)
上面提到了，通过MVCC可以实现RC和RR两种隔离级别。而MVCC其实是一种机制，具体的他还牵扯到很多实体。下面来从头捋一下。

#### 数据行的隐藏字段

首先我们要知道，对于MySQL中的一行数据，除了我们定义的字段以外，还有不少不可见的内建字段。这些字段大概包括了`row_id`，`事务id`，`回滚指针`。

> 顺便一提，MySQL规定每一行数据必须有一个标识id。当有主键的时候，当然可以利用主键作为这个id，当没有主键时，MySQL寻找具有唯一值的列作为标识，如果连唯一值的列都没有，那么就自动生成一个6位的`row_id`，就是这里说的这个了。

`事务id`字段记录的，是最后一个对本行做出修改的事务的ID。（每个事务在开始时都会被分配一个ID，越早开始的事务ID越小）

`回滚指针`则是指向一个地址。每发生一次数据变动，在事务没提交之前，所有的历史数据不会丢失而是会保留下来，被保存在undolog中。而更新后的数据的回滚指针，就会指向其前一个版本的历史数据。直到事务提交后，所有历史版本数据会被清空。

以上提到的undolog，就是MVCC机制的核心内容。由于undolog对数据的多个版本进行了记录，可以借此层层回溯回滚，**因此还可以说，有了undolog就可以实现原子性**。

#### 当前读和快照读

接着说明一下什么是当前读和快照读。当前读是指SQL先对相应记录加锁，然后读取数据的行为。而快照读指不加锁读取数据，可以理解为快照读读的是数据的历史版本，即undolog。

每当进行快照读的时候，MySQL可以生成一个叫做read view的包含了事务层面一些信息的视图。这些信息包括，生成时的活跃事务ID，当前活跃事务的ID最小值，还未分配的下一个事务ID。

根据以上信息，结合当前发起快照读的当前事务的ID，可以依据一套规则来判断，当前事务能否读取到最新的数据。

#### 所以MVCC到底如何实现的那两种隔离级别

简单来说，MVCC通过设定不同的read view生成时机，来区别RC和RR这两种隔离级别。

在一个读取数据的事务中，如果设定其read view只在第一次快照读时就生成，并且之后在事务结束之前一直使用这个view的话，那么就是可重复读（RR）级别的；若每次快照读时，都让重新生成一次read view，那么这个事务每次都能读到最新的数据，所以是“读已提交”（RC）级别的。



