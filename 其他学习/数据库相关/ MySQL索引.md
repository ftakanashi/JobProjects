# MySQL索引
>参考
>
>https://zhuanlan.zhihu.com/p/352181863
>
>https://www.cnblogs.com/tianhuilove/archive/2011/09/05/2167795.html

## 索引是什么，干什么的？
索引的本质是一种结构巧妙的数据结构。
他的作用，是帮助快速检索。
更具体来说，当你在SQL中发出带有WHERE条件的SELECT语句时，没有任何索引辅助的情况下，最简单的思路就是一行一行搜索，
将符合条件的行全部返回。显然复杂度是O(n)的。

而有了索引之后，可以借助索引的辅助，依照给出的具体条件，有可能可以以更快的速度比如O(logn)甚至O(1)等获取到相关的行。

需要注意，索引虽然能够加快检索的速度，但是对写操作的性能是有损害的。因为写操作改变表中数据后就要额外更新索引。

## 其他索引类型以及前序知识
广义上的索引，根据其用来加速检索的数据结构的不同，而分成很多类型。
MySQL中最常用的索引类型是B+ Tree。
但是在说B+ Tree之前， 不妨先来讲讲其他类型。

### 哈希索引
根据上面对具体索引是干什么的描述，其实很容易想到哈希就是一个可能的索引。
比如针对一个学生信息表，我维护了一个学号到姓名的哈希。而后只要你SELECT 姓名 WHERE 学号=x的话，不用扫描表，直接通过这个哈希对应就可返回数据。

乍一看哈希索引似乎很好，但是其也有很明显的确定。
首先，上述哈希的加速只能用于单条数据查询，比如我现在想要来个学号 LIKE xxx的查找，哈希就不行了。
其次，哈希不具备顺序性。比如我想知道学号是xxx后三个人的姓名，（假设学号并不连续）哈希也不行。

事实上，常用的MySQL引擎InnoDB并不支持哈希索引。所以这里就看个乐吧。

### MySQL数据存储的底层实现
MySQL在存储方面，使用的最小存储单位叫数据页。
打个比方，一个数据页存放100行数据的话，那么显然为了存放第101个数据，需要开辟一个新的数据页。
数据页之间互相以双向链表的方式进行连接，因此通过一个数据页可以轻松地到达其后一个或者前一个数据页。

在数据页内部，行也是一个存储单位，内部具体结构根据不同的表定义而不同。但共通的一点是，数据页内的所有行，是根据主键的顺序从小到大排序的，并且
行之间通过单向链表的方式连接。
由于是单向链表，所以对行的遍历也是单向的。

除了数据页之外，我们还要引入一个概念叫主键目录。可以将其理解为一个特殊的数据页，内部每一行维护的，是指向一个数据页的指针、此数据页的编号、以及
此数据页的最小主键。
主键目录的意义在于，当我拿到一个主键后，想要搜索这条记录相关信息时，只要在住建目录上二分查找，就可以知道这个主键位于哪个数据页（根据数据页的最小主键确定范围），
进而快速地得到记录相关信息。
这个主键目录也被称为主键索引。泛泛来说这也算是索引的一种，且是最基础的一种索引。

上述结构如下图示：
![](https://pic3.zhimg.com/80/v2-774817ca13718769d799aaccc35463f2_720w.jpg)


## 索引页扩张以及B+树
从上面图中的状态，现在我们急剧扩大数据规模。假设主键从原来最大的6增大到30多。（当然这不是一个很大的量，这里只是比方说明）

这时引起一个问题，主键目录会变很长，从而导致即使二分查找也还是效率太差。
注意到主键目录本质上还是一个数据页，所以我们可以将其分页，然后创建一个新的特殊数据页用来指向这些被分开的主键目录。
这样的一个"主键目录的主键目录"称为索引页。这种索引页里，每一行维护的是指向每个"分主键目录"的指针以及该"分主键目录"的最小主键
而原先被分开的住建目录的各个页，也可以笼统地称为索引页。

但两种索引页不同的是，前者是主键目录的索引，后者是实际数据的索引。

上述方案可以以下面图示：
![](https://pic2.zhimg.com/80/v2-5f492391305b5a0971b28044b5f3fcc1_720w.jpg)

注意图中各个页都被标记成了索引页，但是索引页并不同。黑底的是索引页8是索引的索引（即二级索引），蓝底的索引页1和2是数据的索引。
按上图例子，比如现在我想找主键=20的数据在哪时，先在最上层的索引页找，发现20的索引被记录在索引页2，然后跳到索引页2，继续查找，发现20的数据在数据页5，
于是最后，到数据页5去找出想要的数据。

接着，如果数据进一步增多，导致二级索引页也过长了怎么办？分裂出一个三级索引呗。
以此类推，其实最终就会得到一个树形的结构。从根节点开始索引一级一级下降，到倒数第二层索引变成数据的索引，而叶子节点则是数据页。
整体图示如下：
![](https://pic1.zhimg.com/80/v2-e79c5057bed36c40ac34e265678eb38c_720w.jpg)

实际上，上面这棵树，是一个B+树。
这个多级索引页+数据页形成的树作为一个整体，被称为聚簇索引。

### 什么是B+树
二叉树大家都知道怎么回事。多叉树也是类似的。
下面针对一个多叉树的节点，我们对其内容物进行一个拓展。

一般来说，树节点的内容物就是一个简单的val值，而这里，我们将其定义为若干个指针块和数据块。这些块有顺序地排列在一起。
所有的叶子节点都是数据块。
对于一个节点如果其内部排序是`p1 d1 p2 d2`的话，那么所有`p1`指针指向的子节点及其所有后代节点的数据块的数据全部小于等于`d1`。
同理，`p2`指向的所有后代节点中的所有数据都大于等于`d1`但小于等于`d2`。
上面这样的一个树，叫做B树：
![](https://pic1.zhimg.com/80/v2-daf5fe2b640f9822a24b51210f8bed44_720w.jpg)

而把B树节点中的所有非叶子节点的数据块全部都去掉（或者说以合理的形式安排到其下属某个叶子节点中），得到的树就是B+树了。
显然，B+树每个非叶子节点只有指针，而指针之间又是互相有序的。前序指针的后代叶子节点中最大的数据，小于等于后续指针后代叶子节点中最小的数据。

### 为什么用B+树作为MySQL的索引？
- 相比于B树，B+树的节点只有指针，因此可以缩小树的高度，并且也方便统一管理
- B+树的所有数据都在叶子节点上，因此查找时遍历的层数总是稳定的，即查询速度稳定
- B+树所有数据都在叶子节点上，因此做全表扫描时只要把所有叶子节点拿出来就行，更方便高效

## 非主键索引与回表
上面我们都是默认以主键作为查询依据的情况，因此建立的索引也都称为主键索引。

但是实际上我们知道MySQL支持对非主键的列也建立索引。
比如对于学生表，我们假设对name和age两列建立索引时，我们期望的是当以name或者age作为搜索依据时能够加快检索。
比如`SELECT id WHERE age=1;`这样的句子。

此时，第一点不同之处在于，构建各级索引页以及数据页时的排序依据将会发生变化。原来是按照主键排序，现在则按照`name, age, id`的顺序排序。
是的，主键仍然要放在最后一个排序依据，以保底。
每个索引页中的键值自然也要改成这三个属性的值。

其次，数据页中不再存放完整的整行记录，而是只存放上述三个属性`name, age, id`。

综上，执行上面提到的那个SQL时，显然从root开始，根据age层层下行找数据页，找到数据页之后再去数据页找到相应记录。
将记录的id返回即可。

此时还有另一个问题，比如运行诸如`SELECT class WHERE age=1;`怎么办。
建立索引是，class并没有被包含在索引分析的列中，因此数据页中没有保存class的信息。
此时就会发生回表行为。顾名思义，我们要根据在索引中找到的记录，回溯到原表去找我们想要的信息。
由于主键id也被维护在索引中，所以回表时依据主键去搜索相关记录即可。而这个搜索过程，则是要像上面主键索引时提到的那样，探索一遍主键索引的那棵B树。

