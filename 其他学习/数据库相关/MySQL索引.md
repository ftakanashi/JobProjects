# MySQL索引
>参考
>
>https://zhuanlan.zhihu.com/p/352181863
>
>https://www.cnblogs.com/tianhuilove/archive/2011/09/05/2167795.html

## 索引是什么，干什么的？
索引的本质是一种结构巧妙的数据结构。他的作用，是帮助快速检索。
更具体来说，当你在SQL中发出带有WHERE条件的SELECT语句时，没有任何索引辅助的情况下，最简单的思路就是一行一行搜索，
将符合条件的行全部返回。显然复杂度是O(n)的。

而有了索引之后，可以借助索引的辅助，依照给出的具体条件，有可能可以以更快的速度比如O(logn)甚至O(1)等获取到相关的行。

需要注意，索引虽然能够加快检索的速度，但是对写操作的性能是有损害的。因为写操作改变表中数据后就要额外更新索引。

## 其他索引类型以及前序知识
广义上的索引，根据其用来加速检索的数据结构的不同，而分成很多类型。
MySQL中最常用的索引类型是B+ Tree。
但是在说B+ Tree之前， 不妨先来讲讲其他类型。

### 哈希索引
根据上面对具体索引是干什么的描述，其实很容易想到哈希就是一个可能的索引。
比如针对一个学生信息表，我维护了一个学号到姓名的哈希。而后只要你SELECT 姓名 WHERE 学号=x的话，不用扫描表，直接通过这个哈希对应就可返回数据。

乍一看哈希索引似乎很好，但是其也有很明显的确定。
首先，上述哈希的加速只能用于单条数据查询，比如我现在想要来个学号 LIKE xxx的查找，哈希就不行了。
其次，哈希不具备顺序性。比如我想知道学号是xxx后三个人的】姓名，（假设学号并不连续）哈希也不行。

事实上，常用的MySQL引擎InnoDB并不支持哈希索引。所以这里就看个乐吧。

### MySQL数据存储的底层实现
MySQL在存储方面，使用的最小存储单位叫数据页。一个数据页的默认大小是16K。
打个比方，一个数据页存放100行数据的话，那么显然为了存放第101个数据，需要开辟一个新的数据页。
数据页之间互相以双向链表的方式进行连接，因此通过一个数据页可以轻松地到达其后一个或者前一个数据页。

在数据页内部，行也是一个存储单位，内部具体结构根据不同的表定义而不同。但共通的一点是，数据页内的所有行，是根据主键的顺序从小到大排序的，并且
行之间通过单向链表的方式连接。
由于是单向链表，所以对行的遍历也是单向的。

除了数据页之外，我们还要引入一个概念叫主键目录。可以将其理解为一个特殊的数据页，内部每一行维护的，是指向一个数据页的指针、此数据页的编号、以及
此数据页的最小主键。
主键目录的意义在于，当我拿到一个主键后，想要搜索这条记录相关信息时，只要在住建目录上二分查找，就可以知道这个主键位于哪个数据页（根据数据页的最小主键确定范围），
进而快速地得到记录相关信息。
这个主键目录也被称为主键索引。泛泛来说这也算是索引的一种，且是最基础的一种索引。

上述结构如下图示：
![](https://pic3.zhimg.com/80/v2-774817ca13718769d799aaccc35463f2_720w.jpg)


## 索引页扩张以及B+树
从上面图中的状态，现在我们急剧扩大数据规模。假设主键从原来最大的6增大到30多。（当然这不是一个很大的量，这里只是比方说明）

这时引起一个问题，主键目录会变很长，从而导致即使二分查找也还是效率太差。
注意到主键目录本质上还是一个数据页，所以我们可以将其分页，然后创建一个新的特殊数据页用来指向这些被分开的主键目录。
这样的一个"主键目录的主键目录"称为索引页。这种索引页里，每一行维护的是指向每个"分主键目录"的指针以及该"分主键目录"的最小主键
而原先被分开的住建目录的各个页，也可以笼统地称为索引页。

但两种索引页不同的是，前者是主键目录的索引，后者是实际数据的索引。

上述方案可以以下面图示：
![](https://pic2.zhimg.com/80/v2-5f492391305b5a0971b28044b5f3fcc1_720w.jpg)

注意图中各个页都被标记成了索引页，但是索引页并不同。黑底的是索引页8是索引的索引（即二级索引），蓝底的索引页1和2是数据的索引。
按上图例子，比如现在我想找主键=20的数据在哪时，先在最上层的索引页找，发现20的索引被记录在索引页2，然后跳到索引页2，继续查找，发现20的数据在数据页5，
于是最后，到数据页5去找出想要的数据。

接着，如果数据进一步增多，导致二级索引页也过长了怎么办？分裂出一个三级索引呗。
以此类推，其实最终就会得到一个树形的结构。从根节点开始索引一级一级下降，到倒数第二层索引变成数据的索引，而叶子节点则是数据页。
整体图示如下：
![](https://pic1.zhimg.com/80/v2-e79c5057bed36c40ac34e265678eb38c_720w.jpg)

实际上，上面这棵树，是一个B+树。
这个多级索引页+数据页形成的树作为一个整体，被称为聚簇索引。

### 什么是B+树
二叉树大家都知道怎么回事。多叉树也是类似的。
下面针对一个多叉树的节点，我们对其内容物进行一个拓展。

一般来说，树节点的内容物就是一个简单的val值，而这里，我们将其定义为若干个指针块和数据块。这些块有顺序地排列在一起。
所有的叶子节点都是数据块。
对于一个节点如果其内部排序是`p1 d1 p2 d2`的话，那么所有`p1`指针指向的子节点及其所有后代节点的数据块的数据全部小于等于`d1`。
同理，`p2`指向的所有后代节点中的所有数据都大于等于`d1`但小于等于`d2`。
上面这样的一个树，叫做B树：
![](https://pic1.zhimg.com/80/v2-daf5fe2b640f9822a24b51210f8bed44_720w.jpg)

而把B树节点中的所有非叶子节点的数据块全部都去掉（或者说以合理的形式安排到其下属某个叶子节点中），得到的树就是B+树了。
显然，B+树每个非叶子节点只有指针，而指针之间又是互相有序的。前序指针的后代叶子节点中最大的数据，小于等于后续指针后代叶子节点中最小的数据。

### 为什么用B+树作为MySQL的索引？
- 相比于B树，B+树的节点只有指针，因此可以缩小树的高度，并且也方便统一管理
- B+树的所有数据都在叶子节点上，因此查找时遍历的层数总是稳定的，即查询速度稳定
- B+树所有数据都在叶子节点上，因此做全表扫描时只要把所有叶子节点拿出来就行，更方便高效

## 非主键索引与回表
上面我们都是默认以主键作为查询依据的情况，因此建立的索引也都称为主键索引。

但是实际上我们知道MySQL支持对非主键的列也建立索引。
比如对于学生表，我们假设对name和age两列建立索引时，我们期望的是当以name或者age作为搜索依据时能够加快检索。
比如`SELECT id WHERE age=1;`这样的句子。

此时，第一点不同之处在于，构建各级索引页以及数据页时的排序依据将会发生变化。原来是按照主键排序，现在则按照`name, age, id`的顺序排序。
是的，主键仍然要放在最后一个排序依据，以保底。
每个索引页中的键值自然也要改成这三个属性的值。

其次，数据页中不再存放完整的整行记录，而是只存放上述三个属性`name, age, id`。

综上，执行上面提到的那个SQL时，显然从root开始，根据age层层下行找数据页，找到数据页之后再去数据页找到相应记录。
将记录的id返回即可。

此时还有另一个问题，比如运行诸如`SELECT class WHERE age=1;`怎么办。
建立索引是，class并没有被包含在索引分析的列中，因此数据页中没有保存class的信息。
此时就会发生回表行为。顾名思义，我们要根据在索引中找到的记录，回溯到原表去找我们想要的信息。
由于主键id也被维护在索引中，所以回表时依据主键去搜索相关记录即可。而这个搜索过程，则是要像上面主键索引时提到的那样，探索一遍主键索引的那棵B树。


# 索引泛泛谈
## 两个引擎与索引间的联系

打开MySQL的数据文件存放位置，你可以看到表以数据文件的形式存在于此。

对于InnoDB引擎，会有大量的`表名.frm`和`表名.ibd`文件。其中前者保存的表的结构信息，后者保存的是InnoDB中一张表的数据以及索引。换言之InnoDB中索引和数据保存在一起。

对于MyISAM引擎而言，同样的位置你可以看到`表名.frm`、`表名.MYD`和`表名.MYI`文件。第一个仍然是结构，第二个保存表的数据，第三个保存表的索引。即MyISAM中，索引与数据分开文件存放。

## 索引优缺点

优点：
- 加快检索速度（废话）
- 将随机IO改为顺序IO（因为B+树的叶子节点彼此双向连接）
- 加速表与表的联结操作

缺点：
- 需要额外的空间存储索引
- 对写操作来说需要额外的时间更新索引

## 索引数据结构
哈希索引用哈希表。
默认的InnoDB的聚簇索引则基于B+树。B+树的索引优于哈希索引。因为其支持排序、范围查找、模糊查找等，且性能稳定。

## 索引分类
从底层数据结构将，索引可以分成哈希索引，B+树索引，R树索引（比较适合地理数据存储，不常用）。

从对数据的作用范围来讲可以分成主键索引、组合索引、唯一索引、全文索引、普通索引等。

## 聚簇索引和非聚簇索引
两者的区别在于，聚簇索引将数据和索引一起放在索引中存储，树的叶子节点保留了完整的数据行信息。
非聚簇索引不将或者只将部分数据列和主键与索引一起放在索引中存储，树的叶子节点保留一部分数据行信息，如果想要知道更完整的数据行信息，需要回表。

在主键上建立的索引称为主索引。主索引默认是聚簇索引。
在非主键上建立的索引为辅助索引。辅助索引默认是非聚簇索引。
因此走辅助索引检索时，若想要的数据没有存在索引的数据页中，则需要先走一遍辅助索引找到主键，再走一遍主索引，依据主键找到数据行。而后半操作，就是回表了。

## 不适用索引的场景
- 表不太大时，有时候全表扫描比走索引更快
- 对于过大的表，维护索引也很费力，应该考虑分库分表
- 如果写操作多余检索，则索引是吃力不讨好

## 创建、删除索引的具体语句
有多种创建方法，比如
```sql
-- 使用CREATE INDEX
CREATE INDEX index_name ON table_name (column_list);
```

```sql
-- 在CREATE TABLE时就创建
CREATE TABLE user(
    id INT PRIMARY KEY,
    information TEXT,
    FULLTEXT KEY (information)
);
```

```sql
-- 使用ALTER TABLE在现有表上创建索引
ALTER TABLE table_name ADD INDEX index_name (column_list);
```

删除索引如下：
```sql
ALTER TABLE table_name DROP KEY index_name;
```

## 索引的最左匹配原则
> 参考在这个页面（https://www.nowcoder.com/discuss/637486）上搜索最左匹配原则

最左匹配原则，用一个例子来解释。假设我们创建了一个表，包含了`id, name, age, gender`字段。随后我们在`name, age, gender`上建立了组合索引。接下来，下面的一些SQL，有些可以走索引，有些走不了索引：

下面这些SQL是走了索引的

```sql
SELECT * FROM t WHERE name='zhangsan';
SELECT * FROM t WHERE name='zhangsan' AND age=18;
SELECT * FROM t WHERE name='zhangsan' AND age=18 AND gender=0;
SELECT * FROM t WHERE age=18 AND name='zhangsan';
SELECT * FROM t WHERE name='zhangsan' AND age > 18;
SELECT * FROM t WHERE name like 'zhang%';
```

下面这些则是没能走索引的：

```sql
SELECT * FROM t WHERE age=18;
SELECT * FROM t WHERE age=18 AND gender=0;
SELECT * FROM t WHERE name='zhangsan' AND gender=0;
SELECT * FROM t WHERE name='zhangsan' AND age > 18 AND gender < 1;
SELECT * FROM t WHERE name like '%san';
SELECT * FROM t WHERE name='zhangsan' OR age=18;
```

总结一下，索引的最左匹配规律是指，当一个表上有a,b,c等列组成的组合索引，使用SELECT语句对相关列进行查询时，WHERE条件经过优化后必须按照a,b,c的顺序从左到右连续的匹配，且最多只能在最后一个判别式中出现一次范围检索。

能走索引的第1，2，3行都是标准的从左到右连续匹配。第4行虽然不是严格的从左到右，但是MySQL的优化器会对WHERE条件重新排序成从左到右的顺序，因此也是会走索引。第五行虽然有范围查询(`>, <`)，但是大于18相当于只要找到等于18的最后一个就行了，所以本质上和等于18没区别。最后一行like的匹配表达式中通配符不在开头位置，因此没问题。

再来看不能走索引的这些，前三行，即使经过优化器的优化，依然不满足从左到右连续的能匹配name, age, gender，因此不行。第四行有两个不等号，因此不行。第5行则是`%`在开头，所以不行。最后一行，不是全部条件以AND连接的情况，通通不行。

以上说明还存在一个坑，就是当表只有`id, name, age, gender`四个字段时，你会发现，不走索引第一行第二行等也都是走索引的。这是因为在没有额外的列的情况下，基于主键建立的聚簇索引和基于`name, age, gender`建立的联合索引本质上是相同的（都保存了每列数据）。因为一些原因，不知道为啥就是可以走索引……。这也是看似索引无效，实际索引有效的例子。

## 索引在哪些情况下无效
- 原SQL不符合最左匹配原则
- 条件中带有or
- 对索引相关列进行计算或者任何函数处理
- 对索引相关列进行任何隐式数据类型转换
- 字符串匹配时以%开头的匹配模式
- 使用!=, <>, is null, is not null等符号判断

## 走查索引过程中的几个名词

回表：当前SQL给出的条件决定了走什么索引。而如果所选列中有部分没有被这个索引覆盖，那么就需要进行回表，回到聚簇索引以获取完整的数据。

索引覆盖：当前SQL走的索引恰好覆盖了所选列，因此直接走一遍索引即可，无需回表。这个就叫发生了索引覆盖。

索引的最左匹配原则：见上面说明

索引的选择性：指建立索引的时候，应该尽量选择值的区分度大的列。比如80%的值都是唯一值的。这是很好理解的。因为走索引本质上是一个二分查找的过程，如果有很多很多同值记录，那么二分查找要找到具体例子就只能在同值区间内挨个遍历了。区分度越大，我们就说索引选择性越大，索引也就越有效。