# MySQL锁
当数据库有并发事务的时候，保证数据访问顺序的机制就是锁机制。

默认情况下，事务可以在其中某个地方对某个数据进行加锁操作（比如`for update`子句就是对UPDATE操作的加锁，具体可百度）
当事务COMMIT的时候自动将锁解锁。

## 锁的分类
### 按粒度分类
按照不同标准有不同的分类方法。比如以锁的粒度从精细到粗放，可以分为行锁、页面锁、表锁等。当然，粒度越精细，需要耗费的资源就更多，加锁速度也会越慢。
MyISAM默认使用表级锁，而InnoDB默认使用行级锁。

### 按性质分类
按照锁的性质分类，大致可以分成共享锁和排他锁。
这两种锁又分别称为读锁（S锁）和写锁（X锁）。

顾名思义，当事务要对数据对象进行读操作的时候，对其上S锁。
某个数据被上了S锁之后，仍然接受其他事务的S锁请求（即可以多事务同时读），但是会拒绝其他事务的X锁请求。
另一方面，当事务要对数据对象进行写操作的时候，对其上X锁。某个数据上了X锁后，会拒绝其他事务的任何锁请求。

即整体的兼容情况如下表：

| |请求读锁|请求写锁|
|---|---|---|
|当前读锁|可|不可|
|当前写锁|不可|不可|

## 意向锁
行锁存在这么一个问题：如果事务A想要给某表加X锁，自然就需要检查有没有其他事务已经持有该表（任意一行）的S或X锁。
此时要针对每一行都扫描一遍，效率太差。
InnoDB内部还设置了两个意向锁，分别是意向读锁（IS）和意向写锁（IX）。
这两种锁都是表锁。InnoDB规定，任何事务想要给某行加S锁时必须先获取IS锁；想要给某行加X锁时必须先获取IX锁。

这样，在上述情况中，当A试图加X锁时，只需要查看有没有其他事务有IS或者IX锁就可以了。
扩张了两种意向锁后，当前锁和请求锁之间的兼容关系如下：

|当前锁↓  请求锁→|X|IX|S|IS|
|---|---|---|---|---|
|X|否|否|否|否|
|IX|否|是|否|是|
|S|否|否|是|是|
|IS|否|是|是|是|

## InnoDB的默认锁
InnoDB的默认锁有两个特点。第一，是行锁。第二，其上锁对象不是数据，而是索引。
若没有显式建立的索引，则通过隐藏行ID的聚簇索引来进行加锁。

另外，如果检索数据的SQL不走索引，MySQL就无法在索引中对相应的记录上锁。为了安全，MySQL还是会对表中所有行都上锁。效果上来说就和上表锁一样了。

## 乐观锁和悲观锁
首先应当明确，乐观锁和悲观锁并不是狭义上的锁的分类。而是广义上的，防止数据冲突的两种不同的并发控制机制。

悲观锁，顾名思义，考虑最坏的情况，即每次访问数据（包括读和写）时数据都是不稳定的。为了避免这种情况，悲观锁机制要求任何数据访问者在访问前必须获得锁。
上面提到的所有MySQL中的锁（狭义的锁）都属于悲观锁范畴。

乐观锁，反过来，考虑最好的情况。即每次访问数据时，默认数据是稳定的。如果访问数据是指修改数据的写操作，那么乐观锁会在提交的时候最后进行一次
数据一致性检查。乐观锁通常通过版本号、CAS算法等外部机制实现，与狭义上的MySQL的锁并无太大关系。

悲观锁采取比较保守的上锁策略，因此并发控制的效果更高，但是由于降低了并行性，整体运行效率更低。悲观锁还有可能引起死锁。
乐观锁则相反，可以想象，如果所有事务都是读数据的话，那么乐观锁是可行的。换言之，在读多写少的场景中，乐观锁可以更好地促进效率。

## 死锁
设想事务A和B分别对数据X和Y进行操作。
第一步，A和B分别对X和Y进行写操作，于是A获得X的写锁，B获得Y的写锁。
第二部，A和B分别对Y和X进行读操作，于是他们会尝试去获得相应数据的读锁。但是我们知道，这两个数据已经被上了写锁，
于是此时A为了获取对Y的读锁，而被阻塞。然而要想打破阻塞，B必须放开对Y的写锁，可这个操作的前提就是A要放开对X的写锁。而A此时被阻塞。

因此进入了死循环，形成了死锁。

防止死锁的策略大概有如下：
- 尽量让多个事务以同样的顺序存取数据
- 尽量使用索引访问数据，使用行锁，不使用表锁，通过精细粒度的访问防止死锁
等等。

