# 基础知识

> https://www.cnblogs.com/franknihao/p/8856972.html
>
> https://blog.csdn.net/living_ren/article/details/79166436

## 基础操作和概念

redis的基本命令不区分大小写。可以通过`redis-cli`进入客户端界面。加上`-h, -p`参数还可指定某个主机的某个端口如`redis-cli -h 192.168.178.59 -p 6379`。
命令`AUTH xxx`可以进行通过密码的授权。密码授权也可以通过命令行中写上`-a 密码明文`实现。

Redis开启后默认有16个数据分库，分别编号为0-15。`select`用于数据库间的切换。比如`SELECT 1`可以进入第一个数据库。
`keys *`可以查看当前数据库中所有的key。后面的通配符`*`也可以换做其他的key的前缀。

一些与Redis服务相关的配置信息，可以通过`INFO`命令查看。

Redis的最基本数据存储方式就是键值对，因此最基本的两个操作是`SET`和`GET`，如：

```
127.0.0.1:6379> SET var 1
OK
127.0.0.1:6379> GET var
"1"
```

另外对于键值对还应该有删除操作和判存在操作。这两个分别用`DEL`和`EXISTS`。如：

```
127.0.0.1:6379> EXISTS var
(integer) 1
127.0.0.1:6379> DEL var
(integer) 1
127.0.0.1:6379> EXISTS var
(integer) 0
```

另外一个使用Redis字符界面客户端值得注意的点，是对于输入的非法语句/字符，Redis并不会给出相关的错误信息，而是直接选择不输出任何东西，需要注意这个特点。

Redis对于命令大小写不敏感，但对变量名（键的值）大小写敏感。通常为了区分命令和键，会将命令全大写。

## 五大基础数据类型

Redis中有五个基础数据类型。可以通过`TYPE <key>`的方式查询某个键的值是哪种类型。

### 字符串 (String)

注意，Redis中的字符串不是传统意义上的字符串。
首先，其单个键值对能够存放值的最大容量达到512M，所以Redis的字符串类型甚至可以存储比如格式化成字符串格式的图片、音乐数据等。
其次，更重要的一点，一般编程语言中常提到的比如int, float之类的类型在Redis中也统一视作字符串。（这也是为什么上面示例中`get var`返回的结果是字符串形式的`"1"`）

当然，整型数或者浮点数会有一些不同于一般字符串的操作，发生这些操作时Redis会自动进行类型转换。

下面是一些字符串类型常见的操作：

| 操作                               | 说明                                                   |
| ---------------------------------- | ------------------------------------------------------ |
| `STRLEN <key>`                     | 返回某个字符串的长度（整数、浮点数等自动转换成字符串） |
| `APPEND <key> xxx`                 | 向某个字符串后面追加上xxx                              |
| `MGET <key1> <key2> ...`           | 一次性获取多个键的值                                   |
| `MSET <key1> <val1> <key2> <val2>` | 一次性设置多个键的值                                   |
| `GETBIT <key> <offset>`            | 获取键值右移`offset`位后的尾值                         |
| `SETBIT <key> <offset> <val>`      | 设置键值右移`offset`位后的尾值为指定值                 |
| `INCR <key>`                       | 将键值自增1（仅限于整型，会返回自增后的值，下同）      |
| `INCRBY <key> <increment>`         | 将键值自增指定整数值（仅限于整型）                     |
| `INCRBYFLOAT <key> <increment>`    | 将键值自增指定浮点数值（仅限于整型）                   |
| `DECR/DECRBY/DECRBYFLOAT`          | 自减操作，类比上面三个（仅限于整型）                   |

### 列表 (List)

说是列表，其实是一个双端队列结构。支持的操作有

| 操作                                       | 说明                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| `RPUSH <key> <ele1> <ele2> ...`            | 从队尾推入(多个)元素                                         |
| `RPOP <key>`                               | 从队尾弹出元素                                               |
| `LPUSH/LPOP`                               | 类似的，只不过是从队头操作                                   |
| `LLEN <key>`                               | 返回队列长度                                                 |
| `LRANGE <key> <start> <end>`               | 切片队列。注意这里start和end都是闭合的，因此和Python的切片不同。 |
| `LINDEX <key> <index>`                     | 获取指定下标的元素的值                                       |
| `LSET <key> <index> <val>`                 | 设置指定下标的元素为指定值                                   |
| `LINSERT <key> BEFORE/AFTER <pivot> <val>` | 在队列中找到某个特定值pivot，然后将新值val插入到其前面或后面 |
| `LTRIM <key> <start> <end>`                | 只保留指定队列片段内容，其余删除                             |
| `LREM <key> <cnt> <val>`                   | 删除前cnt个元素中值为val的元素                               |
| `RPOPLPUSH <src> <dst>`                    | 从src队列rpop出一个元素，然后将其lpush入dst队列              |

Redis中的List底层实现是双端队列+哈希表，所以可以做到O(1)时间内检索、弹出、压入等操作。

### 哈希表 (Hash)

Redis的最基本存储形式其实就像是一个哈希表，而这个内部的哈希表，是嵌套在哈希表中的哈希表啦。
一些基本的操作如下：（注意下列操作中，`<key>`代表的是哈希表对象本身的键，而`field`才代表对象内部的键）

| 操作                                | 说明                                                   |
| ----------------------------------- | ------------------------------------------------------ |
| `HSET <key> <field> <val>`          | 为以`key`作为标识的哈希表设置键值对`field: val`        |
| `HGET <key> <field>`                | 获取哈希表特定键`field`对应的值。若不存在返回空值(nil) |
| `HGETALL <key>`                     | 获取哈希表中所有键值对，以一行键一行值的形式逐行输出   |
| `HMSET/HMGET`                       | 类比`mset/mget`，批量设置/获取键值                     |
| `HEXISTS <key> <field>`             | 判断某个`field`是否存在于哈希表中                      |
| `HSETNX <key> <field> <val>`        | 逻辑是`if not key.field:  hset key.field = val`        |
| `HINCRBY <key> <field> <increment>` | 自增某字段值                                           |
| `HDEL <key> <field>`                | 删除某个字段                                           |
| `HKEYS/HVALS <key>`                 | 列举哈希表内所有键/值                                  |
| `HLEN <key>`                        | 查看哈希表长度                                         |

### 集合 (Set)

和Python中的集合类型类似，底层是一个哈希集保证了元素的唯一性以及O(1)时间的元素判是否存在。另一方面，也实现了并集、交集、补集等集合的基本操作。

基本的操作如下：

| 操作                                | 说明                                                |
| ----------------------------------- | --------------------------------------------------- |
| `SADD <key> <member>`               | 向集合中添加某个元素，返回成功添加的元素个数        |
| `SREM <key> <member>`               | 删除集合中的某个元素，返回成功删除的元素个数        |
| `SMEMBERS <key>`                    | 查看所有集合中的元素                                |
| `SISMEMBER <key> <member>`          | 查看某个元素是否是集合内的                          |
| `SUNION/SINTER/SDIFF <setA> <setB>` | 求两个集合的并集、交集、补集（两个集合都用key表示） |
| `SCARD <key>`                       | 获取集合中元素的个数                                |
| `SRANDMEMBER <key>`                 | 随机获取一个集合中的元素                            |
| `SPOP <key>`                        | 随机从集合中弹出一个元素                            |

### 有序集合 (ZSet)

有序集合，或者称之为带权集合。在上面的一般集合中，所有元素彼此之间的地位都是相等的，换言之，并没有顺序。
而在有序集合中，每一个元素除了其本身的值，还带有一个score值，作为一个权重。

有了权重之后，自然所有元素之间就可以用权重值来排序，因此称为有序集合。另一方面，其也保持着集合本身的性质，即O(1)时间的查找。

有序集合的基本操作包括下面这些：

| 操作                                 | 说明                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| `ZADD <key> <score> <member>`        | 添加一个元素入集合，其权值是score                            |
| `ZSCORE <key> <member>`              | 获取某个集合内元素的权值                                     |
| `ZRANGE <key> <start> <end>`         | 将集合内元素按照`(权值, 值)`的顺序进行排序，并将下标在`[start, end]`闭区间的子集返回出来 |
| `ZREVRANGE <key> <start> <end>`      | 和上一条基本类似，只不过是从大到小排序                       |
| `ZRANGEBYSCORE <key> <min> <max>`    | 将集合内元素按照`(权值, 值)`的顺序进行排序，并将权重score在`[min, max]`闭区间的子集返回出来 |
| `ZREVRANGEBYSCORE <key> <max> <min>` | 同上，倒序排序                                               |
| `ZINCRBY <key> <increment> <member>` | 给某个元素的**权重分**加分，若`increment`设置为负数，那就是减分 |



#### 一些更细节的说明

ZSet相关的操作其实还有很多细节没有提到

- `ZRANGEBYSCORE`

  默认的min和max都是闭区间的，如果想要执行开区间的筛选，则需要在相关数字前面加上一个小括号如`ZRANGEBYSCORE <key> (80 100`。此外，这两个值可以写`+inf`或者`-inf`来表示最大最小值。

  另外，这个指令还支持类似于SQL中的LIMIT机制。比如`ZRANGEBYSCORE <key> <min> <max> LIMIT 0 3`表示对筛选出来的项，只取下标0开始的三项，即前三项。

  在指令后加上`WITHSCORES`，则可以让Redis不仅输出元素本身的值，还输出相应的分数。

- `ZRANGE`

  和上面类似，可以加`WITHSCORES`输出所有元素的权重分数。

#### 剩余辅助性命令补充

| 操作                                  | 说明                                               |
| ------------------------------------- | -------------------------------------------------- |
| `ZCARD <key>`                         | 查询当前有序集合中的元素个数                       |
| `ZCOUNT <key> <min> <max>`            | 获取指定分数范围内的元素个数，适用上述开闭写法规则 |
| `ZREM <key> <member>`                 | 删除某特定值的元素                                 |
| `ZREMRANGEBYRANK <key> <start> <end>` | 删除start到end间这段闭区间对应的元素               |
| `ZREMRANGEBYSCORE <key> <min> <max>`  | 删除分数位于指定区间内的元素，适用上述开闭写法规则 |
| `ZRANK <key> <member>`                | 返回某指定元素在集合中的排名（下标值）             |
| `ZREVRANK <key> <member>`             | 上条的反向                                         |



 ## 其他基础命令

一些最基本的命令包括`GET, SET, DEL, EXISTS, TYPE`等前面都有提过了，下面再来补充一些：

### 序列化与反序列化

Redis中的所有类型的值都可以被序列化。所谓的序列化，就是将一个值在内存中的内容以字符串的形式固化。这样只要给出一模一样的字符串，进行反序列化，就可以对原值进行再现。

| 操作                        | 说明                                          |
| --------------------------- | --------------------------------------------- |
| `DUMP <key>`                | 返回将某个值序列化后的内容。                  |
| `RESTORE <key> <ttl> <str>` | 反序列化。可以指定TTL。TTL为0则表示永不过期。 |

### 过期机制

Redis中的每个键都可以设置有效期，即在多少时间之后键会过期。过期的键会被Redis自动删除。当然通常Redis并不是实时扫描删除，而是采用了延迟删除的策略，即获取某个值的时候先查看其是否在有效期内，如果是则返回，如果否则将其删除。

| 操作                    | 说明                                       |
| ----------------------- | ------------------------------------------ |
| `EXPIRE <key> <sec>`    | 设置某个键在指定秒数后过期。               |
| `EXPIREAT <key> <time>` | 设置某个键在指定时间戳后过期。             |
| `PERSIST <key>`         | 持久化保存某个键，即取消其有效期机制。     |
| `TTL/PTTL <key>`        | 查询多少秒后过期，`PTTL`返回的单位是毫秒。 |

另外还请注意，`EXPIRE <key> 0`或者`-1`之类的命令是无效的，或者说其等价于直接删除相关键。若想持久化保存，还是得使用`PERSIST`命令。

### 命名相关

| 操作                       | 说明                                                         |
| -------------------------- | ------------------------------------------------------------ |
| `RENAME <key> <new_key>`   | 将键重命名。需要注意，重命名时不会检查新名是否有冲突。比如库中已经存在`new_key`时，Redis也不会管，而是直接进行覆盖。 |
| `RENAMENX <key> <new_key>` | 和上条基本相同，只不过会对`new_key`进行存在性检查，若命名冲突则默认不修改（因此返回值也变成0） |
| `MOVE <key> <db>`          | 将某个键移动到另一个数据库                                   |
| `RANDOMKEY`                | 从库中随机选取一个键返回                                     |

### 认证相关

上面说过`AUTH`命令可以用来进行密码认证。现在详细说说。
首先，Redis和MySQL等关系型数据库不同，其本身不提供分用户的密码认证功能。即整个Redis服务只认一个密码。
默认情况下Redis安装后不开启密码认证，需要去相关配置文件中，将`requirepass`一行注释去掉，并将后面改成自己的密码。这样Redis服务启动之后就自带密码了。

对于未开启密码但是已经启动的Redis，可以在命令行中输入如下命令：

```
CONFIG SET requirepass xxx
```

来设置密码。若想重新设置回无密码认证，则可以

```
CONFIG SET requirepass ''
```

### 客户端连接管理

| 操作                      | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `CLIENT LIST`             | 列出当前所有客户端连接的信息，当中有诸如id, addr, name等诸多字段 |
| `CLIENT SETNAME <name>`   | 为当前客户端连接设置一个别名，体现在上条返回中的name字段（默认是空的） |
| `CLIENT GETNAME`          | 获取当前连接的别名                                           |
| `CLIENT PAUSE <mili_sec>` | 为当前连接设置一个挂起毫秒数。==此指令完成后，输入下一个指令后必须被挂起指定毫秒数才会被执行==<br />另外，该被挂起的指令除了正常返回值，还会返回被挂起秒数作为第二个返回。 |
| `CLIENT KILL <IP>:<port>` | 强行关闭某个连接                                             |



# 缓存三大问题

缓存系统的三大问题是指缓存穿透、击穿、雪崩。
这里说的缓存，特指狭义上，放在Web应用层之后，数据库层之前的缓存系统。一般来说，将热点查询数据放在缓存中，可以快速响应请求，减轻数据库压力的作用。

一般的缓存处理的流程如下图：

![img](https://img-blog.csdn.net/20180919143214712?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmd0aWFvNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## 缓存穿透
==缓存穿透是指用户请求中，请求的数据并不存在于缓存或数据库中，系统返回空结果的现象。==
此时，由于系统会绕过缓存去进行库查询，称为穿透。

缓存穿透现象本身是一个中性的词，但是有攻击者会故意编造一些明显不存在的数据请求比如`id=-1`之类的，并发起大量类似请求，迫使系统不断查询数据库，导致数据库压力上涨。
由于缓存系统本身的作用就是减轻数据库压力，所以这种行为可以视为是针对缓存机制的一种攻击。

###  解决方案概览

- 在应用层进行一些最基本的请求过滤。如对于上述`id=-1`这种异常ID值，直接在引用层拒绝掉就可以了。
- 第一次到数据库中查询发现空数据后，在缓存中写入`key-null`对相关信息。这样之后相同的请求在缓存层面就可直接返回空结果，避免了刷库。

## 缓存击穿

==缓存击穿指某个热点数据的缓存在某一时刻突然失效，而此时又有大量请求在并发访问这个数据。由于缓存中没了，所以在一瞬间有大量请求直接击穿至数据库，导致数据库压力陡增的现象。==

### 解决方案概览

- 一个显然的方案就是，将热点数据有效期设置为永久有效。
- 只有大量不互斥的并发才会导致击穿，所以可以加互斥锁控制并发。换言之，当热点数据缓存过期，大量请求到了之后，只有获取互斥锁的线程才能去取数。第一个线程取完数之后直接将数据加入缓存，之后的数据取数就可以直接读缓存，避免了击穿。

## 缓存雪崩

==缓存雪崩指缓存中的数据大批量地到期，一瞬间所有访问那些失效数据的请求都要查询数据库，导致库压力陡增的现象==

与缓存击穿比较，缓存击穿指某个热点数据的失效；雪崩则更加形象，指多个数据的失效。

### 解决方案概览

- 和缓存击穿类似，可以将部分热点数据设置为永不失效，这样也就不会有雪崩了。
- 避免缓存有效期的周期同步，即让不同的数据失效时间尽量均匀分布。