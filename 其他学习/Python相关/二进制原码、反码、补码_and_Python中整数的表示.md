>参考：https://zhuanlan.zhihu.com/p/91967268?utm_source=wechat_session

# 二进制码
在数学中，我们可以将一个十进制数转化为一串0和1变成二进制数。而正负号是额外加的。
比如5的二进制表示是`101`。那么-5可以写作`-101`。

而在实际的计算机中，因为要做到在计算机中区分正负数，通常选择将固定位数表示整数时，最高位当做符号位。
自然的，符号位0表示正数，1表示负数。

这么一来，在计算机中表示的二进制数就有一个"机器数"和"真值"之间的对应关系。
比如5和-5在计算机中用8位表示分别可以写作`0000 0101`，`1000 0101`。
对于-5，其虽然表示成`1000 0101`，但是其真值是`-5`，因为考虑了符号。而不是机器数的`133`。

## 原码、反码、补码的定义以及转换规则
以上定义的，最高位作为符号位，其余位表绝对值的表示形式，称为"原码"。
比如1的原码是`0000 0001`。
比如-1的原码是`1000 0001`。
原码还是比较接近人类的表达习惯，看起来并不难懂。

反码是计算机中原码之外另一种二进制表示整数的方式。（不要问为什么需要这么一种拐弯抹角的表示方式，下面会说。
具体的，反码分类讨论。如果是正数，则保留其原码形式。
如果是负数，则是在原码的基础上保留符号位，反转其余所有位置得到的结果。
比如1的反码是`0000 0001`。
比如-1的反码是`1111 1110`。

补码是原码和反码外的第三种方式。
仍然分类讨论，如果是整数，保留原码形式。
如果是负数，则在原码的基础上保留符号位，反转其余所有位置，再+1。即在反码的基础上再加一。
比如1的补码是`0000 0001`。
比如-1的补码是`1111 1111`。

简单总结一下，
对于正数，三码合一。
对于负数，反码是原码的"真值部分取反"，补码是原码的"真值部分取反+1"。

### 补码的小性质
在n位表示的前提下，若一个负数`a`，将其补码的符号位置零得到一个正数`b`之后，有如下关系：
`b = a + 2^(n-1)`。
比如8位的-5是`1111 1011`。通过置零符号位得到`0111 1011`即123。
-5 + 2^7 = 123 或者表示为 123 - 2^7 = -5。

另一方面，8位整数中`-5`的表示若放到更高的位数比如32位中，显然这就是一个正数了。
这个数显然就是`0111 1011` + `1000 0000`，即123 + 2^7 = 251。

以上几个数之间的关系整理如下， 最好能运用的滚瓜烂熟：
```text
8位整数的前提下、
-5 和 123 是差一个符号位。
-5 = 123 - 2^7
-5 和 251 是8位和更高位定义的同一个二进制表示， 251 = 123 + 2^7
```


## 为什么要用反码、补码
本来，如果可以愉快地使用易懂的原码表示整数并且进行运算，那么最好了。

但是人们发现用原码表示计算机中的整数并不是很方便。
这也主要是因为受到了计算机的机能限制。计算机的计算有两个特点。
第一，只计算加法，因此减去一个数其实是当做加上一个负数来计算的。
第二，算一个加法可以说是计算机中最最简单的操作，为了计算效率应该让电路设计的十分简单。

于是，用原码保存数据并进行计算的缺点出现了。由于第二个特点，我希望不要在电路上多余设计一个模块来分割判断符号。
同时，减去一个数是加上其相反数的操作。
如果使用原码，则做`1 - 1 = 0`的计算时，会发生以下情况：
```text
1是 0000 0001
-1是 1000 0001
两者相加得到 1000 0010 = -2
```
于是聪明的科学家尝试采用反码计算。如果用反码，上述计算可以变成：
```text
0000 0001 + 1111 1110 = 1111 1111 == -0
```
结果是`1111 1111`，别忘了这也是个反码所以转换成原码后我们发现其恰好是`-0`，从数学意义上来说已经得到正确答案了。

但是显然，使用反码也不是最佳方案。究其根本，反码的0对应了两种编码`0000 0000`和`1111 1111`。
我们当然希望数和编码时一一对应的。

于是，最终方案，补码登场。
用补码计算上述`1-1=0`时，由于-1的补码，是原码"真值部分取反+1"，是`1111 1111`：
```text
0000 0001 + 1111 1111 = 1 0000 0000
由于我们限定做8位整数的加法，因此截除首位1，得到0000 0000，这也恰好是0的补码。 
```
另一方面，看`-1 + -127`这个计算：
```text
1111 1111 + 1000 0001 = 1 1000 0000 => 1000 0000
```
这个计算正确结果应该是-128，绝对值超出了7个真值位可表达的范围，本来算溢出了。
而在补码形式中，`1000 0000`这个编码又不对应任何数。
（补码转回原码时要"真值部分-1取反"，可此处真值已经是0，不能再减小）

于是，将`1000 0000`这个编码定义为`-128`，一举两得。
一方面解决了`-0`问题，另一方面还扩大了一个可表示的数字范围。

## Python中的整数表示
Python中提供了int和long两种整数类型，但是并没有明确位数，这也就带来了很多比较迷惑的问题。

通常，在确定某个数字可以用n位带符号整数表示的时候，可以通过类似以下的办法来获得其二进制表达：
```python
def show_binary(num, bit):
    res = []
    for i in range(bit):
        res.append(num << i & 1)
    res.reverse()
    return ''.join(str(i) for i in res)
```
换言之，如果以上函数输出的二进制表达，首位符号与输入的num的实际符号不匹配，则说明出现了溢出的情况。

另一方面，从二进制去构造一个数的时候也要注意限制条件的位数。比如告诉你要构造一个32位整数的时候，
当遍历到第32位二进制位，就该意识到这个是个符号位。
如果其值是0还好办，如果是1，那么就该意识到要求的输出是个负数，不能直接`|= 2**31`（因为那样会变成更大的正数），
而是采用上面那条补码的性质，`-= 2**31`
上述可见`LC.137`作为练习题。

