# 文本处理命令三剑客grep, sed, awk
三剑客指文本流处理中的grep,sed,awk三个命令。

grep擅长查找内容，sed擅长取行以及替换，awk擅长取列以及格式化输出。

## grep
grep的使用方法通常接在一个pipeline的后面。
另一方面，其实其官方的使用方法应该是`grep pattern file`。

常用的grep参数包括
```text
-i      忽略大小写
-v      不匹配
-o      只显示匹配到的部分而不显示整行
-E      使用扩展正则表达式
-A      (After) 输出匹配以及后X行，是这个option的参数值
-B      (Before) 同上，输出的是匹配行及其前X行
-C      (Context) 同上，输出的是匹配行及其前后各X行
以上参数都是修饰pattern的，即 grep [参数] pattern file

-r      递归搜索指定目录中所有文件内容，比如 grep 123 -r ./ 就会搜当前目录及其递归子目录下所有文件中所有带有123的行
以上参数是修饰file的，即 grep pattern [参数] file
```

## sed
sed后面跟的参数比较复杂，需要分成几个层面来看。

首先，sed本身可以带几个参数，因此形成了模式`sed [-nefr] '[编辑动作]'`。各个参数的含义是：
```text
-n      使用安静模式。默认非安静模式下所有内容都会被输出
-i      在文件中原地编辑 in-place
-i.bak  in-place编辑的同时备份源文件
-f      指定一个sed的"脚本文件"，里面每一行都是一个编辑动作。-f指定脚本后会按照顺序依次执行动作
-r      让后续动作中支持扩展正则表达式
```

接着，看编辑动作的格式。注意编辑动作要用单引号引起来。编辑动作大概可以分成两部分，`[addr][option]`。
其中addr是寻址表达式，意思是给出一些条件如行号或者正则式匹配，通过这些条件从而定位若干行。
option则是动作表达式。表示对寻址表达式匹配到的行进行相应操作。

注意两者并不总是concat在一起，根据不同情况可能会有不同。总之记住编辑动作的两个要素，定位和操作。

寻址可以是单寻址（定位一行）或者多寻址（定位多行）。
单寻址的例子：
```text
42      第42行
$       最后一行
/pat/   能够匹配到pat这个正则式的**第一行**
```
多寻址的例子
```text
42,45   第42到第45行，总共是42,43,44,45四行
42,+4   第42行开始的四行，等效于上面的
x~y     步进，如1~2是所有奇数行，2~2是所有偶数行
```

接着是操作，主要有以下几种
```text
d       删除寻址找到的行（后面称这些行为指定行）
p       打印指定行，因为打印追加在stdout最后，所以通常和-n参数配合使用
aTEXT   在指定行下面append新的一行文本TEXT，TEXT中可以带有转义字符如\n以实现多行插入，下同
iTEXT   在指定行上面prepend新的一行文本TEXT
cTEXT   替换指定行为文本TEXT。注意这个操作如果针对连续行，则将连续行替换成一个而非多个
w/path  将指定行写入到新文件/path
=       在指定行上面prepend一行行号。配合-n参数可以打印指定行的行号。
!       取反指定行，需要接在其他操作指令的前面比如 !p 或者 !=。
s/a/b/g 替换操作
        关于这个替换操作，首先，s前可以加寻址式以进一步限定范围，比如1,5s/a/b/g
        其次，g是最常用的全局替换标识。除此之外还可以是p 只打印替换后的行，w/path 将替换后的行保存到新文件等。
```

>更多sed的使用例：https://blog.csdn.net/vanvan_/article/details/91397655


## awk
awk的基本工作格式是`awk '条件类型1{动作1} 条件类型2{动作2} ...' FILE`。

### 动作格式字符串
先来看动作。动作是一串格式化字符串，其中带有一些动态含义的变量或者关键字。
因为awk是主要用于每一行的列字段处理，所以最常见的动作比如`print $1 "\t" $3`这种。

除了`$0`表示整行以及`$n`表示第n个字段的值以外，动作格式字符串中还可以有如下变量：
```text
NF      每一行($0)拥有的字段总数
NR      目前awk处理的是第几行数据，即行号
FS      分隔符，默认是空白        
```

注意动作格式字符串中，那些写死的字符串用双引号引用出来，并且字符串之间不需要额外的符号，默认是连接在一起的。如：
```text
awk '{print $1 "\t lines:" NR "\t columns:" NF}'
```

注意上述变量除了读之外，其实还可以写。比如某行不使用默认空白作为分隔符时，需要手动指定分隔符，就可以操作如下：
```text
awk '{FS=":"} {print $1}'
```
注意以上做法还有点小问题，第一行数据无法正确输出字段而是输出整行。
这是因为awk命令的机理，是先读取一行数据，然后进行awk后面定义的操作的。在读取第一行的时候，FS还未被定义成冒号而是用了默认的空白，因此无法正确输出。

解决办法是使用BEGIN关键字如下：
```text
awk 'BEGIN {FS=":"} {print $1}'
```
跟在BEGIN关键字后面的动作将会在读取第一行开始前就执行，因此第一行也可以用我们定义的冒号进行分割了。

### 条件类型
awk的条件，指的并不是像sed那样的寻址条件。
因为awk关注的是每一列的字段，因此其条件也是基于字段的值进行判断的条件。

具体来说，对于字段是数字的情况，其实条件是一些自然的逻辑运算，包括`< > <= >= == !=`。

结合上面的知识，可以写下面这样一个awk：
```text
awk 'BEGIN {FS=":"} $3<1000 {print $1}' /etc/passwd
```
这个命令的作用就是扫描/etc/passwd文件，用冒号作为每行的分割符，将每行第三个字段拿出来（其实是UID）看其是否小于1000，如果是就输出第一个
字段的值（其实是用户名）


awk命令还有很多很多细节可以学习。先写到这里
