>参考资料：https://leetcode-cn.com/leetbook/read/awesome-linux-handbook/egz2fh/

# 进程与线程

## 基本概念
通过fork可以创建子进程。执行成功后，fork函数本身存在于父进程中，因为拷贝了一遍，所以也存在于子进程中。

此时，父进程和子进程中的两个fork函数都会各自返回一个值。
返回非零值的是父进程的fork函数，其返回值其实是子进程的pid。
相对的，子进程中的fork返回0。

## 进程间通信

### 信号
`kill -l`可以查看到Linux下所有进程间通信用的信号。

进程接收到信号之后，可以选择忽略信号，但是SIGKILL和SIGSTOP两个信号不能被忽略。这两个信号分别是通知进程停止运行和执行关闭操作的。

操作系统会中断进程，然后给进程发送信号。从进程的角度来说，收到的信号并没有严格的处理流程或者顺序，甚至也可以忽视信号。

`SIGINT`信号指示中断进程，Ctrl + C就是发送SIGINT的方法之一。

`SIGKILL`信号指示强制退出进程。在SIGINT或者SYSTERM(和前者的作用类似)无响应时，执行它。

### 管道
管道是同步的，前序进程往管道中输出字节流，后序进程就直接从管道中读取到字节流。

### 共享内存
最快的通信方法。

### FIFO队列（命名管道）
和管道类似，只不过管道的载体是直接在内存中，一旦前序输出完毕，后序读取完毕，这部分管道用内存就直接被OS回收。
而命名管道的载体可以是磁盘中的文件，即使两个进程通信结束，这个文件也可以继续保留供后续其他通信用。

### 消息队列
每个消息队列都单独服务两个特定的进程。由IPC符标识。
和命名管道相比，消息队列支持更加复杂的数据结构的交流而不是单纯的字节流。

### 套接字

### 系统调用

#### 关于CPU上下文切换
CPU有一个寄存器。当某个进程要继续往前运行时，需要将这个进程的信息（PCB中内容）加载到CPU的寄存器中才行。
加载前，寄存器中可能还保留着上一个进程的内容。此时需要将上一个进程的内容保存，然后加载本进程内容。
这个过程就是CPU上下文切换。

CPU上下文切换通常分成两类。
第一类就是如上面所描述的，两个不同进程使用CPU进行交接时发生的切换。也叫进程的上下文切换。
第二类，同一个进程内，当发生系统调用，进程要从用户态进入内核态时，因为执行内核代码需要内核的一套栈、指针之类的。因此也会发生切换。
这种切换只涉及一个进程，是其内部的切换。

当内核态代码执行完毕，最终还是要回到用户态，此时又会发生一次切换。因此总的来说每系统调用一次，都要发生两次切换。

---end---

常见的跟进程管理相关的系统调用包括
`fork`, `exec`等等。

## Linux启动过程
1. BIOS进行开机自检，检测各个硬件是否正常并初始化
2. BIOS从磁盘的MBR（主引导记录）中将boot程序加载到内存中
3. boot程序读取`/boot`目录下的内核文件，启动内核，并将控制权交给内核
4. 内核启动后先对所有硬件进行配置，随后启动init进程
5. init进程检查运行级别配置，根据要求启动rc脚本（其实这些脚本都是软链在/etc/init.d下的），进行系统初始化。
6. 上述rc脚本中，其中有一个会读取`/etc/ttys`中保存的终端信息，并且创建终端。接着就是用户登录了。

## 文件系统
现代Linux常用ext打头的索引式文件系统。
所谓索引式文件系统，就是整个磁盘被分成了超级块区域、inode块区域和data块区域。
超级块用于维护一些文件系统整体的信息，每个文件又对应一个inode块和若干个data块。
文件属性如权限属性，时间属性等保存在inode中。此外inode中还有该文件对应的data块索引。

读取文件时，只要找到其inode，就可以顺势读出所有相关data块。但有个问题是如果多个data块过于分散，那么读取起来就不太方便。
所以ext式文件系统时不时需要进行一下data块重整，让同一个文件的data块不要那么分散。

相对的，比如FAT式的文件系统，采用的是链表式的寻址方法。每个data块保存指向下一个data块的指针。

### 每个block group的内部结构
为了方便管理，文件系统会将一个大磁盘划分成几个类似的小结构，成为group block，每个group block中带有上述内容。下面详细讲一下每个block的内容。
>图示可参考鸟哥Linux P.346

#### data block
data block的基础单位大小大概有1K,2K,4K等。现代文件系统一般都选择4K了。
data block具有以下特点：
- 一旦格式化完成，data block的大小和数量就不能改变
- 一个block只能存放一个文件的内容。这意味着小文件可能会引起block的空间的浪费。

#### inode table
即上述inode block，也成为table。
每个文件的inode table中保存的信息包括：
- 文件的rwx属性
- 文件的时间属性
- owner和group
- 容量
- 指向data block的指针

每个文件的inode还具有下述特点：
- inode大小为256B(新的ext4中)
- 每个文件有且只有一个inode，但inode总数优先，因此一个操作系统中可创建总文件数也有限
- 发生文件访问时先找到inode，只有权限符合inode内要求时才会继续访问data block

32位系统中，一个data block的地址是4个字节，而inode本身最大也就256，所以其能够保存的指针数目也是有限的。
为了能尽可能大地保存文件，inode的保存指针的部分有层级结构。
简而言之，让inode中一部分指针指向的data block不真的保存data，而是保存更多data block的指针。

以采用1K的data block的情况为例。一个一级指针只能定位一个data block即1K大小。
一个二级指针指向的一个1K大小的block，其中可以存放256个指针，指向256个block。如果这些block全部都是data block，那么最大就有256K。
同理，一个三级指针则有256*256K，即64M数据。

#### Superblock
每个block group还有一个超级块，用于保存如下信息：
- inode和block的单位大小
- inode和block各自的使用量/未使用量
- 该group所属的磁盘的挂载信息

可以通过命令`dump2fs`来查看相关superblock信息。

#### Filesystem Description
记录了各个区域的开始和结束为止。也可以通过`dump2fs`来查看。

#### inode bitmap和block bitmap
记录具体哪些inode和block已经被使用了，哪些还未被使用。
新分配的时候从未被使用的里面挑选。

### 目录在文件系统中
从文件系统的角度来说，目录也算是一种文件。
所以文件系统为目录也分配inode和block。
唯一不同的是，block中记录的不是具体的data，而是指向目录下各个文件inode的指针。

