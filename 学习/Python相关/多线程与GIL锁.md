# Python的多线程

## 进程和线程
一般意义上，我们知道进程是运行的程序的抽象。为了运行程序除了程序本身他还要维护很多其他信息。

在任意时刻一个CPU上只能运行一个进程，而由于CPU可以高速切换不同进程实例，所以即便只有一个CPU，对于用户来说似乎还是多进程在运行。

线程则是对进程的进一步轻量化。
一个进程可以包含多个不同的线程。同一个进程下不同线程间可以享用同一块地址空间，相同的全局变量等等。相对的，每个线程也有一些自己独有的信息，比如
程序计数器，堆栈等等。

进程和线程可维护的数据区别如下：
![](https://pic.leetcode-cn.com/1612667575-cWbpmB-os8-7.png)

需要注意的是，虽然不同线程持有的信息可以分化，但是这种分化的独立性并不是很强（至少比不同进程间的分化弱）。
因此，一个线程理论上是可以读取、写入甚至删除另一个线程的所有信息。
这一块需要程序员自己控制，这也是为什么线程安全如此被重视。

相对的，线程-进程关系和进程-OS关系其实很像，但是进程间独立性更强。
对于进程间共享的内存内容，一定是只读的；而可写的内存内容，一定不是共享的。

## 一般意义上的多线程
一个操作系统可以有多个进程，一个进程又可以有多个线程。
而每个CPU在任意一个瞬间只能运行一个进程。这句话更具体一些，其实每个瞬间一个CPU只能运行一个进程的一个线程。

现代操作系统的线程调度通常是可以跨核的。即如果你有多个CPU，那么就可以真并行的运行同一个进程的几个不同线程。
>这个问题其实还牵扯到线程的实现模式。这里不深究，还需要进一步学习。


## Python的多线程与GIL锁
一句话说Python，但是实际上Python有好多种不同的实现。
其中最著名也是官方的实现就是基于C语言的实现即CPython。

CPython的一个特点就是，所有程序都通过Python解释器这个进程执行，而且其规定了，任意一个时刻Python解释器只能执行一个线程。
这个其实就可以完全类比单CPU执行多进程的场景。虽然看起来是并发的，但是只是CPU切换得快，任意一个时刻都只有单个进程在跑。

而保证任意一个瞬间只有一个线程在跑的机制，就是GIL锁。
使用Python解释器运行一次Python代码时，只会产生一个GIL锁。
换句话说，Python官方使用了最粗暴的机制保证了线程安全，即通过全局锁，只让一个线程运行。

具体来说，Python解释器运行步骤如下：
```text
1. 将GIL锁给到某个线程
2. 将上下文切换到对应线程
3. 运行
4. 结束运行，修改线程状态
5. 拿回GIL锁
```
在拿回GIL锁之前，线程状态可能会被修改为就绪态或者阻塞态。
如果是阻塞态，说明此时线程要进行I/O操作，而在其进行I/O操作的同时，拿回GIL锁后的解释器可以着手进行另一个线程的运行。

因此，对于I/O密集型任务如Web访问、文件读取等，即线程经常会变成阻塞态的情况，Python的多线程机制可以起到一定的促进效率的作用。
但是对于CPU计算密集型任务，线程即使运行完成也只是变成就绪态，还要等下一次运行，那么这其实和单线程没有本质区别，因此发挥不了很大作用。

## 其他
在CPython实现的前提下，如果想要实现真正的多线程运行，一种解决办法是从更高层级进行并发，比如多进程。
比如利用Python中的`multiprocessing`库可以进行多进程的并发，每个进程相当于一个独立的解释器，因此可以实现真多线程。

另一种可能的解决办法是使用C语言编写线程程序并且通过链接库的形式在Python代码中引用。
据说解释器会检测到某段程序是C而非Python，从而在这段程序作为线程执行的时候不上GIL锁。
这一块并不熟悉就不多说了。

总的来说，泛泛的多线程因为可以做到 1.CPU并行 和 2.IO并行 所以提高了程序运行的效率。
但是Python由于GIL的原因，即便你的CPU有100个核，每个时刻都只会有一个核在跑一个线程。
因此Python是放弃了CPU并行的。但是IO并行的特点仍然存在。

## 为什么要GIL？
一个简单的知见：Python开发初期用了很多C/C++库，而这些库都是线程不安全的。
因为Python的初衷是要简单快速地编程，因此就粗暴地利用一把全局锁GIL强行实现了线程安全。
这样后续的开发者就不需要再考虑线程不安全的风险。当然这么做的代价就是如上所说，其通过多线程可以提升的效率受到限制。

