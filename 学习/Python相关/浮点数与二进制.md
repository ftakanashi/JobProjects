>参考https://zhuanlan.zhihu.com/p/58731780

# 浮点数与二进制表示
计算机中所有数据都得用二进制存储。
整数数据总体来说比较方便理解，毕竟二进制和整数是一一对应的。

可带有小数点的浮点数该如何处理呢。

其实这和Python也没太大关系，而是所有计算机语言实现时，都统一采用了IEEE.754这个标准。
这个标准，其实就是一个二进制和浮点数之间互相映射的协议，大家都遵守。

这个标准中规定了两种类型的浮点数，占32位字节的单精度型(float)和占64位字节的双精度型(double)。

两者大同小异，下面默认以双精度型进行说明。

## 二进制转换浮点数
下面看这样一串64位二进制字符串：
```text
0100000000101001000101111000110101001111110111110011101101100100
```
顺便一提，如果这串字符串表示的是一个整数（因为是64位，还是个long型整数），那么他是
`4623252388170382180`。
转换规则很简单，首位是0说明其是一个正数，完了一位一位解析即可。

现在，我们要把这串字符串当成一个double型浮点数进行解析。
我们将其分成下面三个部分：
```text
0               (第1位)
10000000010     (第2位-第12位，共计11位)
1001000101111000110101001111110111110011101101100100    （剩余所有位）
```
为什么按照这样的长度分成这样三部分？这是IEEE规定的。

### 每一部分的解析规则
这三部分分别表示了组成一个浮点数的三部分，分别是sign(符号位)，指数(exponent)，小数(fraction)。
我们只要从字符串中将这三个要素解析出来，然后进行简单的计算组合就可以得到浮点数的值。

先来说说三个部分分别如何解析。
首先，符号位，很好理解，和符号整型数一样，0代表正数、1代表负数。

然后，指数部分表示的是一个不带符号的整形数`c`，但`c`并不直接表示指数，而是取用`c - 1023`表示指数exponent。
其中，1023称为"指数偏移量"。
因为10位表示的不带符号的整数`c`的范围是`[0, 2047]`，所以此处`c-1023`即exponent的取值范围是`[-1023, 1024]`。
在最后计算结果的时候，乘以`2 ^ exponent`，这也是这部分被称为指数部分的理由。

最后，fraction表示的是一个范围在`[1,2)`间的小数。和指数部分一样，fraction中的二进制并不直接表示什么内容。
这52位的解析方式是这样的：
如果将其写作`m1 m2 m3 ... m52`，那么其表示的数是`sum(2 ** (-i) for i in {1...52} if mi == '1')`。
也就是说，第`i`位（注意i不是下标）如果是1，那么结果就加上`1 / (2^i)`。
显然，如果这52位都是1，那么得到的结果是`1 - 2**(-52)`，这是一个很接近1的数了。
另外别忘了定义的这个fraction是一个`[1,2)`之间的数，所以还要再加上1，才得到fraction。
没有加1的这部分小于1的数被称为尾数，也写做`m`。
根据上面描述，fraction部分的取值范围显然是`[1, 2-2**(-52)]`。

得到上面三部分的结果之后，最后计算总的结果，公式如下：
```text
res = (-1)^(sign) * 2^(exponent) * fraction
```
显然，当exponent最大，fraction也最大时，能取到double型数据的上限大约是`2*10^(308)`
当exponent最小，fraction也最小的时候，能取到double型表示的最小正数大约是`2*10^(-308)`
另外，当上述`c=0,m=0`的情况，即整个二进制表示都是0的时候，此时虽然数学值是`2^(-1023)`，但是为了和浮点数定义统一，这种情况定义为0。

### 实际操作
好的，根据以上规则我们来实际演示一下如何解析。
再次重申一下，最初的64位二进制字符串，被分成了如下三部分：
```text
0               (第1位)
10000000010     (第2位-第12位，共计11位)
1001000101111000110101001111110111110011101101100100    （剩余所有位）
```
我们看到，符号位是0，说明这是一个正数。

接着解析指数部分。`10000000010`解析出来是`c = 1026`。
得到`exponent = c - 1023 = 3`。

再解析尾数部分。可以用下列代码解析：
```python
m, base = 0, 1
for c in s:
    if c == '1':
        m += 2**(-base)
    base += 1
```
运行上面代码得到`m = 0.56825`

接着拼凑各个部分：
```python
res = -1**(0) * 2**(3) * (1 + m)
```
也就得到了最终结果res是`12.546`。
即，上面这个二进制字符串如果被解析成double型数据，将会是12.546。

### 解析用Python代码
```python
def bin2double(s):
    assert len(s) == 64
    sign, expo, frac = s[0], s[1:12], s[12:]

    sign = 1 if sign == '0' else -1
    expo = int(expo, 2) - 1023

    def str2mant(subs):
        m, base = 0, 1
        for c in subs:
            if c == '1':
                m += 2**(-base)
            base += 1
        return m

    frac = str2mant(frac) + 1

    return sign * 2**(expo) * frac
```

## 单精度型float以及浮点数的精度问题
以上例子以双精度型为例，其实单精度型大同小异。
只不过单精度型中，exponent和fraction的位数分别是8位和23位。

从上面的实操中可以看到，即使double尾数有52位，但是其表达的精度始终是有限的。
如果一个数的精细度低于`2^(-52)`这个量级，那么double也是能对其做一个近似而非准确的表达。
这也是浮点数大部分情况下都是近似而非准确表达的原因。
当然因为尾数的位数double比float要多，所以其精度自然也就高。

这种思想倒和量子力学有点像。我们的世界看似是连续的，其实是一个个非常小的普朗克单位的时间和能量叠加起来的。
在double的世界中，一个"普朗克"量是`2 ** (-52)`约等于`2.22 * 10^(-16)`。
所以用double表示数据时，只保证前15位有效数字，而第16位及以后只能做到部分精确。
类似的，float是前7位有效数字，往后是部分精确。

## 浮点数转换二进制
具体的算法这里先不提了，先给个工具：
>http://www.binaryconvert.com/convert_double.html
>这个网站可以基于IEEE协议，将某个小数转化成相应形式的二进制数据。
