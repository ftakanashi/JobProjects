#!/usr/bin/env python
# -*- coding:utf-8 -*-

'''
    桶排序：
    桶排序Bucket Sort与其说是一种排序算法不如说是一种排序的思想。
    因为桶排序算法本身不像其他经典排序算法一样，它不能直接应用于任意实数数组的排序。
    （基于桶排序思想进行任意实数数组排序的具体实现的一种是基数排序，见RadixSort）

    桶排序的内容，简单来说就是当所有数据用于排序的性质，总体的种类数目是有限个的时候.
    扫描一遍全数据，把数据全部放入对应的桶中，然后按桶的顺序再讲桶里的数据依次读出，就可以形成一个有序的序列。

    这里还存在一个小问题就是桶内如何保持有序。
    基本上两种方案。第一，妥协一下桶内部使用其他排序办法比如快排。
    第二，递归地使用桶排序，即将桶内排序视为一个子问题，启用排序第二特征，进行桶内排序。

    桶排序的性质来说，
    最大的特点是，当数据的分布不是很极端（比如所有第一排序特征全部一样）的情况下， 桶排序的时间复杂度是
    O(n)而不是O(nlogn)的。另外，显然其空间复杂度最大也是O(n)。因此，在一些极端要求排序速度的情况下可以使用桶排序。
    另外有些任务的特点本身就很适合桶排序。
    比如（抄自百度百科…）当我们要排序一个省所有人的高考分数。总样本数可能有几百万个，而每个样本的值都
    在100-900之间。那么此时nlogn可能会比n要花很多时间。而样本值得种类就那么几百个。
    所以采用桶排序，是更好更快的办法。
'''

def BucketSort(lst):
    '''
    :param lst: 这里想定，lst里全是小写英文字母。这样一共可以设置26个桶进行排序。
    '''
    buckets = [0 for _ in range(26)]
    for ch in lst:    # 用O(n)的时间进行数据入桶
        buckets[ord(ch) - ord('a')] += 1

    j = 0
    for i, n in enumerate(buckets):    # 再用O(n)的时间进行数据的出桶
        ch = chr(ord('a') + i)
        for _ in range(n):
            lst[j] = ch
            j += 1

if __name__ == '__main__':
    l = list('fdajklfjdklasfjkladsf')
    BucketSort(l)
    print(l)