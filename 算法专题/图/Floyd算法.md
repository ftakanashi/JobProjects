
## 多源最短路径问题
给出一个图，要求你求这个图中任意两个点间的最短路径。
显然，输出会是一个`n * n`的矩阵。

## Floyd算法
联系Dijkstra算法，那个是解决单源最短路径问题的算法。
显然，解决多源最短路径的一个最朴素的想法，就是针对所有节点各自调用一次Dijkstra算法。

但是这么做的话，显然会有很多重复计算。
与其思考如何优化这个方案，不如另起炉灶，于是就有了Floyd算法。

Floyd算法是属于，思想描述起来比较复杂，但是实际写代码比较简单的算法。

简单来说，首先初始化一个最短路径矩阵`path`，刚开始其就是一个图的邻接矩阵的副本。

接下来遍历每个节点，将其视作某条最短路径的"中间节点"。
针对这样的每个节点`k`，再遍历所有可能的起始点和终点，`i`和`j`。
看从`i`到`j`的路径如果让其经过`k`的话能否缩短路径。如果能，则更新最短路径矩阵。

有时如果需要将每两点间的最短路径也一起输出，那么可以额外维护一个`nxt_node`矩阵。这个矩阵的值`nxt_node[i][j]`表示
`i`到`j`的最短路径上，从`i`出发的下一节点是什么。如果是`j`，那说明这就是一条边。如果是一个第三方节点`x`，那么首先知道了`i -> x`这条边，
然后继续查看`nxt_node[x][j]`的值，以此类推即可。

说了一大堆 代码其实如下：
```python
import copy
F = float('inf')
def floyd(graph):
    n = len(graph)
    path = copy.deepcopy(graph)
    nxt_node = [[-1 if graph[i][j] == F else j for j in range(n)] for i in range(n)]
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if path[i][j] > path[i][k] + path[k][j]:
                    path[i][j] = path[i][k] + path[k][j]
                    nxt_node[i][j] = nxt_node[i][k]

    return path, nxt_node
```

### 三层循环顺序是否可以交换
第一次看到Floyd算法，一个很自然的疑惑就是，能否交换三层循环。
因为把k放在最外面显得有些不自然，如果是`for i -> for j -> for k`的话，感觉好记很多。

但是答案是不能的。以下面这个例子说明。
假如我们有图
```text
0    100    20    1
100  0      30    F
20   30     0     1
1    F      1     0
```
如果以`i -> j -> k`的顺序安排循环，那么`i=0,j=1,k=2`时，`path[i][j]`可以降为`20+30=50`。
然而继续，`k=3`时，明明可以将`path[i][j]`降得更低，成`30+1=31`，但是由于此时`1`和`3`两个节点之间的`path[1][3]`
仍然是无穷大，无法更新，因此就将错误的答案维护到了path中。
因为`i,j`组合只能在循环中遇到一次，所以这个错误答案会保留到最后。

相对的，如果使用`k -> i -> j`顺序安排循环，`k=2`时不仅可以将`path[0][1]`降低到50，更可以将`path[1][3]`降低到31。
这样，之后`k=3`的时候，就可以顺利的使用`path[1][3]`的信息，将`path[0][1]`降低到32了。

以上例子只属于一个反例，并不严谨。严谨证明可以查看书本。这也是Floyd代码很简单但是证明起来很麻烦的原因之一了。

## 分析
显然，Floyd算法的时间复杂度是`O(n^3)`。
空间上，根据实现不同而不同，像上面的代码因为用了两个`n*n`的矩阵作为工作区，所以是`O(n^2)`。

相比于进行n次Dijkstra算法，复杂度应该是`O(n * ElogE)`（E是边的总数）
可以发现，如果图是稠密图，即边数量远远大于节点数量的情况，使用Floyd算法比多次Dijkstra算法要更好。